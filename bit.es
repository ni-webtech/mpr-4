#!/usr/bin/env ejs

/*
    bit.es -- Build It! -- Embedthis Build It Framework
 */

module embedthis.bit {

require ejs.unix

class Bit 
{
    private const RC: String = '.bitrc'
    private const VERSION: Number = 0.1

    private var appName: String = 'bit'
    private var cmd: CmdArgs
    private var currentBit: Path            // Name of the bit file being currently loaded

    /*
        Aggregate Bit configuration. This has all bit files blended into one object.
     */
    private var spec: Object = { components: {} }

    private var targets: Array = []         // Ordered set of targets
    private var cmdTargets                  // Command line targets to build

    private var posix = ['MACOSX', 'LINUX', 'UNIX', 'FREEBSD', 'SOLARIS']
    private var windows = ['WIN', 'WINCE']

    function Bit() {
    }

    private var cmdOptions = [
        [ 'build', String ],
        [ 'config', String ],
        [ 'debug' ],
        [ 'init', String ],
        [ 'dev' ],
        [ 'host' ],
        [ 'init', String ],
        [ 'overwrite' ],
        [ 'show' ],
        [ ['verbose', 'v'] ],
        [ 'version' ],
        [ 'why' ],
    ]

    function usage(): Void {
        print('\nUsage: ' + appName + ' [options] [targets] ...\n' +
            '  Options:\n' + 
            '    --build path           # Use the specified build.bit\n' +
            '    --config configuration # Use the build configuration\n' +
            '    --debug                # Debug the build\n' +
            '    --dev                  # Build the dev tools only\n' +
            '    --host                 # Build for the host only\n' +
            '    --init path-to-source  # Initialize for building\n' +
            '    --log logFile          # Send log output to a log file \n' +
            '    --overwrite            # Overwrite when generating files\n' +
            '    --show                 # Show commands executed\n' +
            '    --version              # Dispay the bit version\n' +
            '    --verbose              # Use --log stderr:2\n' +
            '')
        App.exit(1)
    }

    function main() {
        global._b = this
        global.spec = spec
        try {
            cmd = CmdArgs(cmdOptions)
        } catch (e) {
            App.log.error(e)
            usage()
        }
        try {
            processOptions(cmd)
            if (cmd.options.init) {
                initialize()
            } else {
                process()
            }
        } catch (e) {
            if (e is String) {
                msg = e
                App.log.error('bit: Error: ' + msg + '\n')
            } else {
                msg = e.message
                App.log.error('bit: Error: ' + msg + '\n')
            }
            App.exit(2)
        } finally {
        }
    }

    function processOptions(cmd: CmdArgs) {
        let options = cmd.options
        if (options.version) {
            print(version)
            App.exit(0)
        }
        if (options.verbose && !options.log) {
            options.log = 'stderr:1'
        }
        if (options.log) {
            App.log.redirect(options.log)
            App.mprLog.redirect(options.log)
        }
        currentBit = options.build
        cmdTargets = cmd.args
    }

    function getDevPlatform() {
        return 'x86_64-apple-macosx.bit'
    }

    function initialize() {
        let dev = getDevPlatform()
        //  MOB - 
        let platform = Path('bit').join(dev).joinExt('bit')
        loadWrapper(platform)
        loadWrapper('product.bit')
        trace('Init', spec.settings.title)

        expandTokens(spec)
        setTypes()
        findComponents()

        let nspec = { 
            '+blend' : [
                platform,
                'depend.bit',
                'product.bit',
            ],
            '+settings': spec.settings,
            components: spec.components,
        }
        let bbit: Path = 'build.bit'
        if (bbit.exists && !cmd.options.overwrite) {
            throw 'The ' + bbit + ' file already exists. Use bit --overwrite'
        }
        trace('Generate', bbit)
        bbit.write('/*\n    build.bit -- Build It for ' + spec.settings.title + 
            '\n\n    Generated by bit.\n */\n\nbit(' + 
            serialize(nspec, {indent: 4, commas: true}) + ')\n')
    }

    function findComponents() {
        trace('Find', 'Components')
        let dir = Path(cmd.options.init)
        for each (component in spec.required + spec.optional) {
            let path = dir.join('bit/components', component + '.bit')
            vtrace('Find', 'Component ' + component)
            if (path.exists) {
                try {
                    spec.components[component] ||= {}
                    loadWrapper(path)
                } catch (e) {
                    if (!(e is String)) {
                        App.log.debug(0, e)
                    }
                    let kind = spec.required.contains(component) ? 'Required' : 'Optional'
                    whyMissing(kind + ' componenent "' + component + '" ' + e)
                    spec.components[component] = { diagnostic: "" + e }
                }
            } else {
                throw "Unknown component " + path
            }
        }
    }

    public function probe(file: Path, options = {}): Path {
        let path: Path
        if (file.exists) {
            path = file
        } else {
            for each (s in options.search) {
                if (s.join(file).exists) {
                    path = s.join(file)
                    break
                }
            }
            path ||= Cmd.locate(file)
        }
        if (!path && !options.silent) {
            throw 'component not found'
        }
        if (options.fullpath) {
            return path
        }
        return path.toString().replace(RegExp('[/\\\\]' + file + '$'), '')
    }

    function process() {
        if (!currentBit) {
            findConfig()
        }
        loadWrapper(currentBit)
        expandTokens(spec)

        let host = spec.host
        host.cross ||= (host.arch != Config.CPU || host.os != Config.OS)
        if (host.cross) {
            build(!host.cross)
        }
        build()
    }

    function loadWrapper(path) {
        let saveCurrent = currentBit
        currentBit = path
        vtrace('Loading', currentBit)
        load(path)
        currentBit = saveCurrent
    }

    public function loadBitfile(o) {
        let toBlend = blend({}, o, {combine: true})
        /* Blending is depth-first. So blend existing spec over blended spec */
        /* Load blended bit files first */
        for each (path in toBlend.blend) {
            loadWrapper(currentBit.dirname.join(path))
        }
        spec = blend(spec, o, {combine: true})
    }

    function findConfig() {
        let base: Path = currentBit || '.'
        for (let d: Path = base; d.parent != d; d = d.parent) {
            let f: Path = d.join('build.bit')
            if (f.exists) {
                currentBit = f
                return
            }
        }
        throw 'Can\'t locate build.bit'
    }

    function prepBuild(cross) {
        setTokens(cross)
        getOrderedTargets()
        setTypes()
        expandWildcards()
        blendCommon()
        setTypes()
        setTargetPaths()

        debug('Bit Configuration: \n\nBit = ' + serialize(spec, {pretty: true}))
    }

    function getOrderedTargets() {
        if (cmdTargets.length > 0) {
            for each (target in cmdTargets) {
                orderTargets(target, spec.targets[target])
            }
        } else {
            for (let [name, target] in spec.targets) {
                if (target.type) {
                    orderTargets(name, target)
                }
            }
        }
        if (cmd.options.verbose) {
            let names = ''
            for each (target in targets) {
                names += target.name + ' '
            }
            trace('Targets', names)
        }
    }

    function orderTargets(tname, target) {
        if (target.depend) {
            for each (dname in target.depend) {
                let dep = spec.targets[dname]
                if (!dname) {
                    throw 'Unknown dependency "' + dname + '" in target "' + tname + '"'
                }
                if (!targets.contains(dep)) {
                    orderTargets(dname, dep)
                    targets.push(dep)
                    dep.name = dname
                }
            }
        }
        target.name = tname
        targets.push(target)
    }

    function setTargetPaths() {
        for each (target in targets) {
            if (!target.path) {
                if (target.type == 'lib') {
                    target.path = spec.directories.lib.join(target.name).joinExt(spec.extensions.shlib)
                } else if (target.type == 'obj') {
                    target.path = spec.directories.obj.join(target.name).joinExt(spec.extensions.obj)
                } else if (target.type == 'exe') {
                    target.path = spec.directories.bin.join(target.name).joinExt(spec.extensions.exe)
                } else {
                    target.path = target.name
                }
            }
        }
    }

    /*
        Expand target.sources include+exclude and create target.files[]
     */
    function expandWildcards() {
        let stable = targets.clone()
        for (index in stable) {
            let target = targets[index]
            let files
            let src = target.sources
            if (src) {
                if (src.include is RegExp) {
                    files = Path('.').glob('*', {include: src.include})
                } else if (src.include is Array) {
                    files = []
                    for each (pattern in src.include) {
                        files += Path('.').glob(pattern)
                    }
                } else {
                    files = Path('.').glob(src.include)
                }
                if (src.exclude) {
                    if (src.exclude is RegExp) {
                        files = files.reject(function (elt) elt.match(src.exclude)) 
                    } else if (src.exclude is Array) {
                        for each (pattern in src.exclude) {
                            files = files.reject(function (elt) { return elt.match(pattern); } ) 
                        }
                    } else {
                        files = files.reject(function (elt) elt.match(src.exclude))
                    }
                }
                let targetIndex = index
                target.files = []
                for each (file in files) {
                    let obj = spec.directories.obj.join(file.replaceExt(spec.extensions.obj).basename)
                    let newTarget = { name : file, path: obj, type: 'obj', files: [ file ], build: target.build }
                    if (spec.targets[file]) {
                        newTarget = blend(spec.targets[file], newTarget, {combined: true})
                    } else {
                        spec.targets[newTarget.name] = newTarget
                    }
                    targets.insert(targetIndex++, newTarget)
                    target.files.push(obj)
                }
            }
        }
    }

    function blendCommon() {
        let common = {}
        for (name in spec.common) {
            common['+' + name] = spec.common[name]
        }
        for each (target in targets) {
            if (target.type) {
                blend(target, common, {combine: true})
            }
        }
    }

    function setTypes() {
        for (let [key,value] in spec.directories) {
            spec.directories[key] = Path(value)
        }
    }

    function build(cross: Boolean) {
        prepBuild(cross)
        for each (target in targets) {
            buildTarget(target, cross)
        }
    }

    function buildTarget(target, cross: Boolean) {
        if (target.type == 'obj') {
            buildObj(target, cross)
        } else if (target.type == 'lib') {
            buildLib(target, cross)
        } else if (target.type == 'exe') {
            buildExe(target, cross)
        } else {
            throw 'Unknown target type in ' + target.path
        }
    }

    function buildExe(target, cross: boolean) {
        if (!stale(target, target.files)) {
            whySkip(target.path, 'is up to date')
            return
        }
        debug('Building:\n' + target.path + ' = ' + serialize(target, {pretty: true}))
        if (cmd.options.debug) {
            dump('TARGET', target)
        }
        let transition = 'EXE'
        let rule = spec.rules[transition]
        if (!rule) {
dump('FAILED', target)
            throw 'No rule to build target ' + target.path + ' for transition ' + transition
            return
        }
        spec.target = target
        spec.PREPROCESS = ''
        spec.OUT = target.path
        spec.IN = target.files.join(' ')
        spec.DEBUG = '-g'

        /* Double expand so rules tokens can use ${OUT} */
        let command = rule.expand(spec, {fill: ''})
        command = command.expand(spec, {fill: ''})
        trace('Link', target.name)
        debug(2, command)
        let run = runCmd(command)
        if (run.status != 0) {
            throw 'Build failure for ' + target.path + '\n' + run.error
        }
    }

    function buildLib(target, cross: boolean) {
        //  MOB - need libraries[] so we can stat them
        if (!stale(target, target.files)) {
            whySkip(target.path, 'is up to date')
            return
        }
        debug('Building:\n' + serialize(target, {pretty: true}))
        if (cmd.options.debug) {
            dump('TARGET', target)
        }
        let transition = 'LIB'
        let rule = spec.rules[transition]
        if (!rule) {
dump('FAILED', target)
            throw 'No rule to build target ' + target.path + ' for transition ' + transition
            return
        }
        spec.target = target
        spec.PREPROCESS = ''
        spec.OUT = target.path
        spec.IN = target.files.join(' ')
        spec.DEBUG = '-g'

        /* Double expand so rules tokens can use ${OUT} */
        let command = rule.expand(spec, {fill: ''})
        command = command.expand(spec, {fill: ''})
        trace('Link', target.name)
        let run = runCmd(command)
        if (run.status != 0) {
            throw 'Build failure for ' + target.path + '\n' + run.error
        }
    }

    function buildObj(target, cross: boolean) {
        if (!stale(target, target.files)) {
            return
        }
        debug('Building:\n' + serialize(target, {pretty: true}))
        if (cmd.options.debug) {
            dump('TARGET', target)
        }
        let ext = target.path.extension
        for each (file in target.files) {
            let transition = file.extension + '->' + target.path.extension
            let rule = spec.rules[transition]
            if (!rule) {
                rule = spec.rules[target.path.extension]
                if (!rule) {
                    dump('FAILED', target)
                    throw 'No rule to build target ' + target.path + ' for transition ' + transition
                    return
                }
            }
            spec.target = target
            spec.PREPROCESS = ''
            spec.OUT = target.path
            spec.IN = file
            spec.DEBUG = '-g'
            let command = rule.expand(spec, {fill: ''})
            trace('Compile', file)
            let run = runCmd(command)
            if (run.status != 0) {
                throw 'Build failure for ' + target.path + '\n' + run.error
            }
        }
    }

    function stale(target, inputs: Array) {
        let path = target.path
        if (!path.modified) {
            whyRebuild(path, 'Rebuild', 'is missing.')
            return true
        }
        for each (file in inputs) {
            if (file.modified > path.modified) {
                whyRebuild(path, 'Rebuild', 'ingredient ' + file + ' has been modified.')
                return true
            }
        }
        for each (dep in target.depend) {
            let file = spec.targets[dep].path
            if (file.modified > path.modified) {
                whyRebuild(path, 'Rebuild', 'dependent ' + file + ' has been modified.')
                return true
            }
        }
        debug('Building:\n' + serialize(target, {pretty: true}))
        return false
    }

    function depend(path) {
        let str = path.readString()
        let includes = str.match(/^#include.*"/gm)
        for (i in includes) {
            s = includes[i]
            includes[i] = includes[i].replace(/#include.*"(.*)"/, '$1')
        }
    }

    function setTokens(cross: Boolean) {
        if (cross) {
            spec.ARCH = spec.host.arch
            spec.OS = spec.host.os
        } else {
            spec.OS = Config.OS
            spec.ARCH = Config.CPU
        }
        trace('Building', spec.settings.title + ' for ' + spec.OS + ', ' + spec.ARCH);
    }

    function expandTokens(o) {
        for (let [key,value] in o) {
            if (value is String) {
                o[key] = value.expand(spec, {fill: '${}'})
            } else if (Object.getOwnPropertyCount(value) > 0) {
                o[key] = expandTokens(value)
            }
        }
        return o
    }

    function runCmd(command: String): Cmd {
        if (cmd.options.show) {
            App.log.activity('Run', command)
        }
        let run = Cmd(command)
        return run
    }

    function trace(tag, msg) {
        App.log.activity(tag, msg)
    }

    function vtrace(tag, msg) {
        if (cmd.options.verbose) {
            App.log.activity(tag, msg)
        }
    }

    function whyRebuild(path, tag, msg) {
        if (cmd.options.why) {
            App.log.activity(tag, path + ' because ' + msg)
        }
    }

    function whySkip(path, msg) {
        if (cmd.options.why) {
            App.log.activity('Target', path + ' ' + msg)
        }
    }

    function whyMissing(msg) {
        if (cmd.options.why) {
            App.log.activity('Init', msg)
        }
    }

    function debug(msg) {
        if (cmd.options.debug) {
            App.log.activity('Debug', msg)
        }
    }
}

} /* bit module */


require embedthis.bit

public var b: Bit = new Bit
b.main()

public function bit(o: Object) {
    b.loadBitfile(o)
}

public function probe(file: Path, options = {}): Path {
    return b.probe(file, options)
}
/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2012. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2012. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
