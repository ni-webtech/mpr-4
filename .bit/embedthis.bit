/*
    embedthis.bit -- Embedthis Build Actions
 */

Bit.load({
    '+modules': [
        'embedthis.es',
    ],

    internal: {
        runopt: {dir: bit.dir.src, show: true, toss: true}
        platforms: [ 'local' ],
    },

    settings: {
        depth: 1,
    },

    targets: {
        combo: {
            action: "
                let parts = bit.settings.package || 'binary dev'
                let keep = (bit.settings.keep) ? ' --keep' : ''
                run('makeInstall --package --root=' + bit.dir.out.join('combo') + ' combo', bit.target.runopt)
                run('makePackage --combo --root=' + bit.dir.out.join('combo') + keep + ' combo', bit.target.runopt)
            ",
        },

        deploy: {
            action: "
                stdout.write('Enter deployment directory: ')
                let got = stdin.readLine()
                let parts = bit.settings.package || 'binary dev'
                run('priv makeInstall --install --bare --root=' + bit.dir.out.join('pkg') + 
                    ' pre ' + parts + ' post', bit.target.runopt)
            ",
        },

        flat: {
            action: "
                let parts = bit.settings.package || 'binary dev'
                let keep = (bit.settings.keep) ? ' --keep' : ''
                run('makeInstall --package --root=' + bit.dir.out.join('flat') + ' flat', bit.target.runopt)
                run('makePackage --combo --root=' + bit.dir.out.join('flat') + keep + ' flat', bit.target.runopt)
            ",
        },

        projects: {
            action: "
                let ejs = 'ejs ' + Cmd.locate('bit')
                run(ejs + ' -without ssl configure generate', bit.target.runopt)
                run(ejs + ' -emulate linux-i686 -without ssl configure -gen sh,make', bit.target.runopt)
                run(ejs + ' -emulate macosx-i686 -without ssl configure -gen sh,make', bit.target.runopt)
                run(ejs + ' -emulate solaris-i686 -without ssl configure -gen sh,make', bit.target.runopt)
                run(ejs + ' -emulate win-i686 -without ssl configure -gen sh,make,vs', bit.target.runopt)
            ",
        },

        'projects-clobber': {
            action: "
                rm(['${dir.projects}/*.mk', '${dir.projects}/*.sh'])
                rmdir(['${dir.projects}/*-*-debug', '${dir.projects}/*-*-release'])
            "
        },

        _install: {
            action: "
                let parts = bit.settings.package || 'binary dev'
                run('priv makeInstall --install --root=' + bit.dir.out.join('pkg') + 
                    ' pre ' + parts + ' post', bit.target.runopt)
            ",
        },

        sync: {
            action: "
                for each (peer in bit.settings.sync) {
                    let dir = bit.dir.src.parent.join(peer + '/releases')
                    if (!dir.exists) {
                        dir = bit.dir.src.parent.join(peer + '/out/releases')
                    }
                    let from = dir.join(peer + '-combo.tgz')
                    run('syncup --sync ' + from, bit.target.runopt)
                }
            ",
        },

        _package: {
            action: "
                if (bit.settings.depth >= 2) {
                    let keep = (bit.settings.keep) ? ' --keep' : ''
                    let parts = bit.settings.package || 'binary dev'
                    run('fakePriv build/bin/makeInstall --package --root=' + bit.dir.out.join('pkg') +
                        ' pre ' + parts + ' post', bit.target.runopt)
                    run('fakePriv build/bin/makePackage --root=' + bit.dir.out.join('pkg') + keep + 
                        ' pre ' + parts + ' post', bit.target.runopt)
                } else {
                    trace('Info', 'Packaging skipped at build depth ' + bit.settings.depth)
                }
            ",
        },

        _package2: {
            action: "
                load(bit.dirs.src.join('.bit/combo.es'))
            ",
        },

        _uninstall: {
            action: "
                let parts = bit.settings.package || 'binary dev'
                run('priv build/bin/makeInstall --remove pre ' + parts + ' post', bit.target.runopt)
            ",
        },

        upload: {
            action: "
                if (bit.settings.depth < 2) {
                    trace('Info', 'Upload skipped at build depth ' + bit.settings.depth)
                } else {
                    let img = $(BLD_PRODUCT)-$(BLD_VERSION)-$(BLD_NUMBER)
                    let src = $(BLD_PRODUCT)-src-$(BLD_VERSION)-$(BLD_NUMBER)
                    let uri = App.getenv('BUILD_UPLOAD')
                    let key = App.getenv('BUILD_KEY')
                    if (key == '') {
                        throw 'Missing a BUILD_KEY authorization key'
                    }
                    if (uri == '') {
                        throw 'Missing a BUILD_UPLOAD uri'
                    }
                    for each (file in bit.dir.rel.glob('${settings.product}-${settings.version}-${settings.number}')) {
                        if (file.toString().contains('flat.tgz')) {
                            let latest = file.dirname.join('${settings.product}-latest-flat.tgz')
                            file.rename(latest)
                            file = latest
                        }
                        let http = new Http
                        http.upload(uri, {server: System.hostname, key: key}, file)
                        if (http.status != 200) {
                            throw 'Can\'t upload ' + file
                        }
                    }
                }
            "
        },

        utest: {
            type: 'test',
            action: "
                if (bit.packs.ejs && bit.packs.ejs.path) {
                    run(bit.packs.ejs.path + ' ' + bit.dir.top.join('.bit/bin/utest') + ' -v -d ' + bit.settings.depth, 
                        {dir: bit.dir.src.join('src')})
                }
            ",
        }

        version: {
            action: "print(bit.settings.version + '-' + bit.settings.buildNumber)",
        },

        /*
            Documentation targets 
         */
        doc: {
            depends: ['patch', 'man', 'api', 'clean-doc', 'ssi'],
        },

        api: {
            depends: ['package', 'man'],
            action: "
                rm(['${SRC}/doc/api/html', '${SRC}/doc/api/xml'])
                for each (dfile in ls('${SRC}/doc/api/*.dox')) {
                    let name = dfile.basename.trimExt()
                    let dox = Path('${LIB}/dox.tmp')
                    let data = Path('${SRC}/doc/api/' + name + '.dox').readString().replace(/^INPUT .*=.*$/m, 
                            'INPUT = ${PKG}/' + name + '-${settings.version}/src/deps/' + name + '/' + name + '.h')
                    Path(dox).write(data)
                    trace('Generate', 'API documentation for ' + name)
                    run('doxygen ' + dox, {dir: '${SRC}/doc/api'})
                    trace('Process', 'Post-process ' + name + ' API documentation (may take a while)')
                    run('ejs ${SRC}/.bit/bin/gendoc.es ' + 
                        '--title \"MPR - Multithreaded Portable Runtime Native API\" --out ' + name + '.html ' + 
                        (['xml/' + name + '_8h.xml'] + ls('xml/group*') + ls('xml/struct_*.xml')).join(' '), 
                        {dir: '${SRC}/doc/api'})
                    run('ejs ${SRC}/.bit/bin/gendoc.es --bare ' + 
                        '--title \"MPR - Multithreaded Portable Runtime Native API\" --out ' + name + 'Bare.html ' + 
                        (['xml/' + name + '_8h.xml'] + ls('xml/group*') + ls('xml/struct_*.xml')).join(' '), 
                        {dir: '${SRC}/doc/api'})
                    rm(['${SRC}/doc/api/html', '${SRC}/doc/api/xml'])
                }
            ",
        },

        man: {
            depends: ['package'],
            action: "
                for each (file in ls('../doc/man/*.1')) {
                    let name = file.basename
                    trace('Generate', 'Manual page for ' + name)
                    let man = run('man ' + file, {})
                    file.replaceExt('txt').write(man.response.replace(/.\b/g, ''))
                    let cmd = run('man2html -u', {detach: true})
                    cmd.write(run('man ' + file, {}).response)
                    cmd.finalize()
                    file.replaceExt('html').write(cmd.response)
                }
            ",
        },

        'clean-doc': {
            type: 'clean',
            action: "
                rmdir(['../doc/api/html', '../doc/api/xml'])
            "
        },
    
        patch: {},

        ssi: {
            action: "
                if (bit.packs.dsi.path) {
                    if (!bit.dir.src.join('doc/dsi').exists) {
                        trace('Skip', 'No server side includes')
                    } else {
                        trace('Process', 'HTML SSI')
                        for each (file in ls('../doc/**.html')) {
                            file = file.absolute
                            vtrace('Patch', file)
                            run([bit.packs.dsi.path, file], {dir: bit.dir.src.join('doc')})
                        }
                    }
                } else {
                    trace('Skip', 'ssi bacause ' + bit.packs.dsi.diagnostic)
                }
            ",
        },

        tidy: {
            depends: ['doc', 'ssi'],
            enable: false,
            action: "
                if (bit.packs.dsi.path) {
                    trace('Tidy', 'HTML doc')
                    for each (file in ls('../doc/**html')) 
                        trace('Tidy', file)
                        run(bit.packs.tidy.path + ' -q -config tidy.conf ' + file)
                    }
                } else {
                    trace('Skip', 'tidy bacause ' + bit.packs.dsi.diagnostic)
                }
            "
        },
    },
})
