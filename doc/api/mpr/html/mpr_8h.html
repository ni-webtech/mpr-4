<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mpr: mpr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="dir_3fd9df3bcf4b859f17f835baaaf16dcf.html">all</a>
  </div>
<div class="contents">
<h1>mpr.h File Reference</h1>Multithreaded Portable Runtime (MPR) is a portable runtime core for embedded applications.  
<a href="#_details">More...</a>
<p>

<p>
<a href="mpr_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_blk.html">MprBlk</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory Allocation Block Header.  <a href="struct_mpr_blk.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_cond.html">MprCond</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Condition variable for single and multi-thread synchronization.  <a href="struct_mpr_cond.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_dir_entry.html">MprDirEntry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory entry description.  <a href="struct_mpr_dir_entry.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_file_system.html">MprFileSystem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File system service.  <a href="struct_mpr_file_system.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_hash_table.html">MprHashTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash table control structure.  <a href="struct_mpr_hash_table.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_key_value.html">MprKeyValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key value pairs for use with MprList or MprHash.  <a href="struct_mpr_key_value.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_mutex.html">MprMutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multithreading lock control structure.  <a href="struct_mpr_mutex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_spin.html">MprSpin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multithreading spin lock control structure.  <a href="struct_mpr_spin.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_string.html">MprString</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe String Module.  <a href="struct_mpr_string.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_thread_local.html">MprThreadLocal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread local data storage.  <a href="struct_mpr_thread_local.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e2e7058ae62846bc72aa87a94998e35"></a><!-- doxytag: member="mpr.h::MPR_BACKGROUND_PRIORITY" ref="5e2e7058ae62846bc72aa87a94998e35" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5e2e7058ae62846bc72aa87a94998e35">MPR_BACKGROUND_PRIORITY</a>&nbsp;&nbsp;&nbsp;15</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">May only get CPU if idle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2548e612d40219745d36809427d5fd0"></a><!-- doxytag: member="mpr.h::MPR_BUF_INCR" ref="a2548e612d40219745d36809427d5fd0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a2548e612d40219745d36809427d5fd0">MPR_BUF_INCR</a>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default buffer growth inc. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d11f870f279dc0ae25037aa94cfb7159"></a><!-- doxytag: member="mpr.h::MPR_BUFSIZE" ref="d11f870f279dc0ae25037aa94cfb7159" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d11f870f279dc0ae25037aa94cfb7159">MPR_BUFSIZE</a>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reasonable size for buffers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e06415ae3af35c8ac27f34b10d3001e3"></a><!-- doxytag: member="mpr.h::MPR_CRITICAL_PRIORITY" ref="e06415ae3af35c8ac27f34b10d3001e3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e06415ae3af35c8ac27f34b10d3001e3">MPR_CRITICAL_PRIORITY</a>&nbsp;&nbsp;&nbsp;99</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">May not yield. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b06f41accf7c6527c8e29f0ce93bce4"></a><!-- doxytag: member="mpr.h::MPR_DEFAULT_ALLOC" ref="7b06f41accf7c6527c8e29f0ce93bce4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7b06f41accf7c6527c8e29f0ce93bce4">MPR_DEFAULT_ALLOC</a>&nbsp;&nbsp;&nbsp;64</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default small alloc size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c984410ca2b9c805e56da89d0bfc6c6d"></a><!-- doxytag: member="mpr.h::MPR_DEFAULT_HASH_SIZE" ref="c984410ca2b9c805e56da89d0bfc6c6d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c984410ca2b9c805e56da89d0bfc6c6d">MPR_DEFAULT_HASH_SIZE</a>&nbsp;&nbsp;&nbsp;23</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default size of hash table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="efea53f554fcb794283095d3b96c34bd"></a><!-- doxytag: member="mpr.h::MPR_DEFAULT_MAX_THREADS" ref="efea53f554fcb794283095d3b96c34bd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#efea53f554fcb794283095d3b96c34bd">MPR_DEFAULT_MAX_THREADS</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default max threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73941169dddea56ea21e373e25d6f630"></a><!-- doxytag: member="mpr.h::MPR_DEFAULT_MIN_THREADS" ref="73941169dddea56ea21e373e25d6f630" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#73941169dddea56ea21e373e25d6f630">MPR_DEFAULT_MIN_THREADS</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default min threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b682c50e795b73ee99bea8e24fc5c943"></a><!-- doxytag: member="mpr.h::MPR_DEFAULT_STACK" ref="b682c50e795b73ee99bea8e24fc5c943" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b682c50e795b73ee99bea8e24fc5c943">MPR_DEFAULT_STACK</a>&nbsp;&nbsp;&nbsp;(64 * 1024)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default thread stack size (64K). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c35c619d08e3fc977e60b9b3d0dee15"></a><!-- doxytag: member="mpr.h::MPR_EPOLL_SIZE" ref="7c35c619d08e3fc977e60b9b3d0dee15" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7c35c619d08e3fc977e60b9b3d0dee15">MPR_EPOLL_SIZE</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Epoll backlog. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b27e0a286fd6975d08929c2ef931ab6"></a><!-- doxytag: member="mpr.h::MPR_ERR" ref="4b27e0a286fd6975d08929c2ef931ab6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4b27e0a286fd6975d08929c2ef931ab6">MPR_ERR</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default error code. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e8036f0bee810b7d0a3fa6a752c77b2"></a><!-- doxytag: member="mpr.h::MPR_ERR_ABORTED" ref="5e8036f0bee810b7d0a3fa6a752c77b2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5e8036f0bee810b7d0a3fa6a752c77b2">MPR_ERR_ABORTED</a>&nbsp;&nbsp;&nbsp;-2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Action aborted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a19880d5b8b35cbd243601c3fdebc9a"></a><!-- doxytag: member="mpr.h::MPR_ERR_ALREADY_EXISTS" ref="0a19880d5b8b35cbd243601c3fdebc9a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#0a19880d5b8b35cbd243601c3fdebc9a">MPR_ERR_ALREADY_EXISTS</a>&nbsp;&nbsp;&nbsp;-3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Item already exists. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="919966956e7462c38d2a1575c32d9948"></a><!-- doxytag: member="mpr.h::MPR_ERR_BAD_ARGS" ref="919966956e7462c38d2a1575c32d9948" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#919966956e7462c38d2a1575c32d9948">MPR_ERR_BAD_ARGS</a>&nbsp;&nbsp;&nbsp;-4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bad arguments or paramaeters. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="930ee0c1f493bf582c968c45b1670e3d"></a><!-- doxytag: member="mpr.h::MPR_ERR_BAD_FORMAT" ref="930ee0c1f493bf582c968c45b1670e3d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#930ee0c1f493bf582c968c45b1670e3d">MPR_ERR_BAD_FORMAT</a>&nbsp;&nbsp;&nbsp;-5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bad input format. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c23aecc1451d49a5b30ec93eef8a82fa"></a><!-- doxytag: member="mpr.h::MPR_ERR_BAD_STATE" ref="c23aecc1451d49a5b30ec93eef8a82fa" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c23aecc1451d49a5b30ec93eef8a82fa">MPR_ERR_BAD_STATE</a>&nbsp;&nbsp;&nbsp;-7</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Module is in a bad state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba09adbb870ee2f433345e2f149e7170"></a><!-- doxytag: member="mpr.h::MPR_ERR_BAD_SYNTAX" ref="ba09adbb870ee2f433345e2f149e7170" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ba09adbb870ee2f433345e2f149e7170">MPR_ERR_BAD_SYNTAX</a>&nbsp;&nbsp;&nbsp;-8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input has bad syntax. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2223fd269b22204735c86aedfb75498d"></a><!-- doxytag: member="mpr.h::MPR_ERR_CANT_ACCESS" ref="2223fd269b22204735c86aedfb75498d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#2223fd269b22204735c86aedfb75498d">MPR_ERR_CANT_ACCESS</a>&nbsp;&nbsp;&nbsp;-12</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can't access the file or resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d015f30b291c6ddc172ee8401626201"></a><!-- doxytag: member="mpr.h::MPR_ERR_CANT_CREATE" ref="9d015f30b291c6ddc172ee8401626201" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#9d015f30b291c6ddc172ee8401626201">MPR_ERR_CANT_CREATE</a>&nbsp;&nbsp;&nbsp;-14</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can't create the file or resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="293c82c9a0891e2dcfd18caf2f515b87"></a><!-- doxytag: member="mpr.h::MPR_ERR_CANT_OPEN" ref="293c82c9a0891e2dcfd18caf2f515b87" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#293c82c9a0891e2dcfd18caf2f515b87">MPR_ERR_CANT_OPEN</a>&nbsp;&nbsp;&nbsp;-16</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can't open the file or resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4dad0ac2657323d3e0790744560d4404"></a><!-- doxytag: member="mpr.h::MPR_ERR_CANT_READ" ref="4dad0ac2657323d3e0790744560d4404" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4dad0ac2657323d3e0790744560d4404">MPR_ERR_CANT_READ</a>&nbsp;&nbsp;&nbsp;-17</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can't read from the file or resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8d350a5d245956ba8d0e6f461906d51"></a><!-- doxytag: member="mpr.h::MPR_ERR_CANT_WRITE" ref="f8d350a5d245956ba8d0e6f461906d51" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f8d350a5d245956ba8d0e6f461906d51">MPR_ERR_CANT_WRITE</a>&nbsp;&nbsp;&nbsp;-18</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can't write to the file or resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90f611631651c3bc10a50d12a43a4891"></a><!-- doxytag: member="mpr.h::MPR_ERR_GENERAL" ref="90f611631651c3bc10a50d12a43a4891" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#90f611631651c3bc10a50d12a43a4891">MPR_ERR_GENERAL</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General error. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21c86bc598c8c86c0347dd2e7a5d2948"></a><!-- doxytag: member="mpr.h::MPR_ERR_NO_MEMORY" ref="21c86bc598c8c86c0347dd2e7a5d2948" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#21c86bc598c8c86c0347dd2e7a5d2948">MPR_ERR_NO_MEMORY</a>&nbsp;&nbsp;&nbsp;-30</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory allocation error. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd3e5f02d6a87f8d974978e7a1bae790"></a><!-- doxytag: member="mpr.h::MPR_ERR_NOT_INITIALIZED" ref="dd3e5f02d6a87f8d974978e7a1bae790" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#dd3e5f02d6a87f8d974978e7a1bae790">MPR_ERR_NOT_INITIALIZED</a>&nbsp;&nbsp;&nbsp;-22</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Module or resource is not initialized. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#9f0e4f45ab378cf38c97d1f82ae97977">MPR_ERR_OK</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard MPR return and error codes.  <a href="#9f0e4f45ab378cf38c97d1f82ae97977"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d01a181e24b717f7e8cc209ecf9a1fd"></a><!-- doxytag: member="mpr.h::MPR_ERR_READ_ONLY" ref="1d01a181e24b717f7e8cc209ecf9a1fd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1d01a181e24b717f7e8cc209ecf9a1fd">MPR_ERR_READ_ONLY</a>&nbsp;&nbsp;&nbsp;-24</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The operation timed out. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b58f968604e9f630b90bd20b66f9fc6b">MPR_ERROR</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard logging trace levels are 0 to 9 with 0 being the most verbose.  <a href="#b58f968604e9f630b90bd20b66f9fc6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="207b6b4c4dd69cefc5d48e0898677ff1"></a><!-- doxytag: member="mpr.h::MPR_EVENT_CONTINUOUS" ref="207b6b4c4dd69cefc5d48e0898677ff1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#207b6b4c4dd69cefc5d48e0898677ff1">MPR_EVENT_CONTINUOUS</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auto reschedule the event. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a99bacd6ebae3f038383bf28e9c9b80"></a><!-- doxytag: member="mpr.h::MPR_EVENT_PRIORITY" ref="2a99bacd6ebae3f038383bf28e9c9b80" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#2a99bacd6ebae3f038383bf28e9c9b80">MPR_EVENT_PRIORITY</a>&nbsp;&nbsp;&nbsp;50</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal priority. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c5e08a31ad4866aee0214fe9177d5f4"></a><!-- doxytag: member="mpr.h::MPR_LIST_INCR" ref="4c5e08a31ad4866aee0214fe9177d5f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4c5e08a31ad4866aee0214fe9177d5f4">MPR_LIST_INCR</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default list growth inc. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9fbd54076ade37688f1e5ca2784e271"></a><!-- doxytag: member="mpr.h::MPR_MAX_ARGC" ref="d9fbd54076ade37688f1e5ca2784e271" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d9fbd54076ade37688f1e5ca2784e271">MPR_MAX_ARGC</a>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reasonable max of args. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bd8f55c7f348c463079b9e3da32f9a9d"></a><!-- doxytag: member="mpr.h::MPR_MAX_BUF" ref="bd8f55c7f348c463079b9e3da32f9a9d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#bd8f55c7f348c463079b9e3da32f9a9d">MPR_MAX_BUF</a>&nbsp;&nbsp;&nbsp;4194304</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max buffer size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6301f3ae68d98c76debdfea9b2ece4bc"></a><!-- doxytag: member="mpr.h::MPR_MAX_FNAME" ref="6301f3ae68d98c76debdfea9b2ece4bc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#6301f3ae68d98c76debdfea9b2ece4bc">MPR_MAX_FNAME</a>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reasonable filename size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9f0705ef414c63b94c34a8a4e0bb239a"></a><!-- doxytag: member="mpr.h::MPR_MAX_LOG_STRING" ref="9f0705ef414c63b94c34a8a4e0bb239a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#9f0705ef414c63b94c34a8a4e0bb239a">MPR_MAX_LOG_STRING</a>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum log message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06e26ea0168fbb293255ffdc62b288e0"></a><!-- doxytag: member="mpr.h::MPR_MAX_PATH" ref="06e26ea0168fbb293255ffdc62b288e0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#06e26ea0168fbb293255ffdc62b288e0">MPR_MAX_PATH</a>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reasonable path name size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab279a1400259da3572a2fd2a8681623"></a><!-- doxytag: member="mpr.h::MPR_MAX_STRING" ref="ab279a1400259da3572a2fd2a8681623" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ab279a1400259da3572a2fd2a8681623">MPR_MAX_STRING</a>&nbsp;&nbsp;&nbsp;1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum (stack) string size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4b31c87cc1ce41278fae6a17c23e3199">MPR_MAX_URL</a>&nbsp;&nbsp;&nbsp;512</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max URL size.  <a href="#4b31c87cc1ce41278fae6a17c23e3199"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00253cececc72225524d098e29d552a9"></a><!-- doxytag: member="mpr.h::MPR_NORMAL_PRIORITY" ref="00253cececc72225524d098e29d552a9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#00253cececc72225524d098e29d552a9">MPR_NORMAL_PRIORITY</a>&nbsp;&nbsp;&nbsp;50</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal (default) priority. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6072e168871ce4b65725049d214965a1"></a><!-- doxytag: member="mpr.h::MPR_REQUEST_PRIORITY" ref="6072e168871ce4b65725049d214965a1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#6072e168871ce4b65725049d214965a1">MPR_REQUEST_PRIORITY</a>&nbsp;&nbsp;&nbsp;50</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal priority. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7bbe6982e4e64f2f034971b88d3da3af"></a><!-- doxytag: member="mpr.h::MPR_SECURE_CLIENT" ref="7bbe6982e4e64f2f034971b88d3da3af" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7bbe6982e4e64f2f034971b88d3da3af">MPR_SECURE_CLIENT</a>&nbsp;&nbsp;&nbsp;((struct MprSsl*) 1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag for mprCreateSocket to use the default SSL provider. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6d5205a6c355e6e3c5cb78db9b57a7f"></a><!-- doxytag: member="mpr.h::MPR_SERVICE_ONE_THING" ref="c6d5205a6c355e6e3c5cb78db9b57a7f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c6d5205a6c355e6e3c5cb78db9b57a7f">MPR_SERVICE_ONE_THING</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for one event or one I/O. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26b2bbf78247ef8fd3528aabea7aa32"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_BLOCK" ref="a26b2bbf78247ef8fd3528aabea7aa32" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a26b2bbf78247ef8fd3528aabea7aa32">MPR_SOCKET_BLOCK</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use blocking I/O. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="99a15ede7932c340743a75f118ca16c6"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_BROADCAST" ref="99a15ede7932c340743a75f118ca16c6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#99a15ede7932c340743a75f118ca16c6">MPR_SOCKET_BROADCAST</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broadcast mode. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f98ea149c4bce9ffe816678bbc49f0d"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_CLIENT" ref="1f98ea149c4bce9ffe816678bbc49f0d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1f98ea149c4bce9ffe816678bbc49f0d">MPR_SOCKET_CLIENT</a>&nbsp;&nbsp;&nbsp;0x800</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket is a client. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9899fbaf22958ef4d2fbb5bce6cbb898"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_CLOSED" ref="9899fbaf22958ef4d2fbb5bce6cbb898" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#9899fbaf22958ef4d2fbb5bce6cbb898">MPR_SOCKET_CLOSED</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MprSocket has been closed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5e870cae7f4f67d9d9da412128ee8f1"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_CONNECTING" ref="d5e870cae7f4f67d9d9da412128ee8f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d5e870cae7f4f67d9d9da412128ee8f1">MPR_SOCKET_CONNECTING</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MprSocket has been closed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3af7ac22e43b6d66754503bf4b038823"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_DATAGRAM" ref="3af7ac22e43b6d66754503bf4b038823" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3af7ac22e43b6d66754503bf4b038823">MPR_SOCKET_DATAGRAM</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use datagrams. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84190073ab879726ad4f3c97206fd01b"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_EOF" ref="84190073ab879726ad4f3c97206fd01b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#84190073ab879726ad4f3c97206fd01b">MPR_SOCKET_EOF</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seen end of file. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0dcff326be6be22f7382a95cf01fcc15"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_LISTENER" ref="0dcff326be6be22f7382a95cf01fcc15" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#0dcff326be6be22f7382a95cf01fcc15">MPR_SOCKET_LISTENER</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MprSocket is server listener. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51675ba1c7573f654989a489c0803f8b"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_NODELAY" ref="51675ba1c7573f654989a489c0803f8b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#51675ba1c7573f654989a489c0803f8b">MPR_SOCKET_NODELAY</a>&nbsp;&nbsp;&nbsp;0x100</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable Nagle algorithm. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83a3df553a14edcbf46c671097860f20"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_NOREUSE" ref="83a3df553a14edcbf46c671097860f20" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#83a3df553a14edcbf46c671097860f20">MPR_SOCKET_NOREUSE</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dont set SO_REUSEADDR option. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38565a33ada00883ec935b577d1811ab"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_PENDING" ref="38565a33ada00883ec935b577d1811ab" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#38565a33ada00883ec935b577d1811ab">MPR_SOCKET_PENDING</a>&nbsp;&nbsp;&nbsp;0x1000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pending buffered read data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3d6547888a1ecdcb880bccfc8511dd0"></a><!-- doxytag: member="mpr.h::MPR_SOCKET_THREAD" ref="f3d6547888a1ecdcb880bccfc8511dd0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f3d6547888a1ecdcb880bccfc8511dd0">MPR_SOCKET_THREAD</a>&nbsp;&nbsp;&nbsp;0x400</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process callbacks on a worker thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2d5fc1b9d658c93d2833e75ed45eb99"></a><!-- doxytag: member="mpr.h::MPR_SSL_BUFSIZE" ref="e2d5fc1b9d658c93d2833e75ed45eb99" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e2d5fc1b9d658c93d2833e75ed45eb99">MPR_SSL_BUFSIZE</a>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSL has 16K max. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d29febaeaca5d39a1ad539c1a3b6225"></a><!-- doxytag: member="mpr.h::MPR_TICKS_PER_SEC" ref="3d29febaeaca5d39a1ad539c1a3b6225" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3d29febaeaca5d39a1ad539c1a3b6225">MPR_TICKS_PER_SEC</a>&nbsp;&nbsp;&nbsp;1000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time ticks per second. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9900ec15eb1619e4a9bc5a675f0a4cdd"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_CMD" ref="9900ec15eb1619e4a9bc5a675f0a4cdd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#9900ec15eb1619e4a9bc5a675f0a4cdd">MPR_TIMEOUT_CMD</a>&nbsp;&nbsp;&nbsp;60000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Command Request timeout (60 sec). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd2002df57aac80b02daa2f187cd4b4c"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_HANDLER" ref="cd2002df57aac80b02daa2f187cd4b4c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#cd2002df57aac80b02daa2f187cd4b4c">MPR_TIMEOUT_HANDLER</a>&nbsp;&nbsp;&nbsp;10000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait period when removing a wait handler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a9a50e1c8d7de296f8d822c1ecc24d3"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_LINGER" ref="3a9a50e1c8d7de296f8d822c1ecc24d3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3a9a50e1c8d7de296f8d822c1ecc24d3">MPR_TIMEOUT_LINGER</a>&nbsp;&nbsp;&nbsp;2000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close socket linger timeout. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7aac261496b3ad0f1adea76a959e34fd"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_LOG_STAMP" ref="7aac261496b3ad0f1adea76a959e34fd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7aac261496b3ad0f1adea76a959e34fd">MPR_TIMEOUT_LOG_STAMP</a>&nbsp;&nbsp;&nbsp;3600000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time between log time stamps (1 hr). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2eb3f4af9584897ff6ec601fcca4c3c"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_PRUNER" ref="a2eb3f4af9584897ff6ec601fcca4c3c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a2eb3f4af9584897ff6ec601fcca4c3c">MPR_TIMEOUT_PRUNER</a>&nbsp;&nbsp;&nbsp;600000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time between pruner runs (10 min). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cefcf294650f2254b1fcb335af931da"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_SOCKETS" ref="0cefcf294650f2254b1fcb335af931da" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#0cefcf294650f2254b1fcb335af931da">MPR_TIMEOUT_SOCKETS</a>&nbsp;&nbsp;&nbsp;10000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General sockets timeout. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="edd536c5e56ec128b69e540bc2926dd3"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_START_TASK" ref="edd536c5e56ec128b69e540bc2926dd3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#edd536c5e56ec128b69e540bc2926dd3">MPR_TIMEOUT_START_TASK</a>&nbsp;&nbsp;&nbsp;2000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time to start tasks running. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b16c71cdee0d3ca77efef483c13ee84"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_STOP" ref="1b16c71cdee0d3ca77efef483c13ee84" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1b16c71cdee0d3ca77efef483c13ee84">MPR_TIMEOUT_STOP</a>&nbsp;&nbsp;&nbsp;5000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait when stopping resources. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3607582e032513bfb634178e569f6340"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_STOP_TASK" ref="3607582e032513bfb634178e569f6340" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3607582e032513bfb634178e569f6340">MPR_TIMEOUT_STOP_TASK</a>&nbsp;&nbsp;&nbsp;10000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time to stop or reap tasks. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c71168dee2c19a44b17981748e1127c3"></a><!-- doxytag: member="mpr.h::MPR_TIMEOUT_STOP_THREAD" ref="c71168dee2c19a44b17981748e1127c3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c71168dee2c19a44b17981748e1127c3">MPR_TIMEOUT_STOP_THREAD</a>&nbsp;&nbsp;&nbsp;10000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time to stop running threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a46345d16dbc9d60b67e7418a2c2a09"></a><!-- doxytag: member="mpr.h::MPR_WORKER_PRIORITY" ref="1a46345d16dbc9d60b67e7418a2c2a09" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1a46345d16dbc9d60b67e7418a2c2a09">MPR_WORKER_PRIORITY</a>&nbsp;&nbsp;&nbsp;50</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal priority. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ea34ea35e2d8b1a0be44e799fa4d2fb"></a><!-- doxytag: member="mpr.h::MPR_XML_BUFSIZE" ref="5ea34ea35e2d8b1a0be44e799fa4d2fb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5ea34ea35e2d8b1a0be44e799fa4d2fb">MPR_XML_BUFSIZE</a>&nbsp;&nbsp;&nbsp;4096</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XML read buffer size. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int64 size, int64 total, bool granted)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory allocation error callback.  <a href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7">MprBufProc</a> )(struct MprBuf *bp, void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer refill callback function.  <a href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory context type.  <a href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mpr memory block destructors prototype.  <a href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> )(void *data, struct MprEvent *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event callback function.  <a href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#ga4064169552596b7923bc734da239f96">MprListCompareProc</a> )(cvoid *arg1, cvoid *arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List comparison procedure for sorting.  <a href="group___mpr_list.html#ga4064169552596b7923bc734da239f96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689">MprLogHandler</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int flags, int level, cchar *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log handler callback type.  <a href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g12f3bd6503c42b00ef185eb5a7b3073f">MprModuleEntry</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loadable module entry point signature.  <a href="group___mpr_module.html#g12f3bd6503c42b00ef185eb5a7b3073f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb">MprModuleProc</a> )(struct MprModule *mp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Module start/stop point function signature.  <a href="#1d9d70fd98eb69a8c870f2202bee22eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#86674106f5fcb47ba730f66375407e0a">MprSocketProc</a> )(void *data, int mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket I/O callback procedure.  <a href="#86674106f5fcb47ba730f66375407e0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mpr time structure.  <a href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99">MprWorkerProc</a> )(void *data, struct MprWorker *worker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Worker thread callback signature.  <a href="#1c2789aea11b60b13644c3b4e7c54f99"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprSocket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#8e5dff8e25775b63954faa81e54c7f82">mprAcceptSocket</a> (MprSocket *listen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept an incoming connection.  <a href="#8e5dff8e25775b63954faa81e54c7f82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHash *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#g6cac9e79143bfdc2c884590446e5edaf">mprAddDuplicateHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, cchar *key, cvoid *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a duplicate symbol value into the hash table.  <a href="group___mpr_hash.html#g6cac9e79143bfdc2c884590446e5edaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHash *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#gdd7d9c74e9073729c721efe1e5dec0aa">mprAddHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, cchar *key, cvoid *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a symbol value into the hash table.  <a href="group___mpr_hash.html#gdd7d9c74e9073729c721efe1e5dec0aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gbf10109abc063c47702769c0e89442cf">mprAddItem</a> (MprList *list, cvoid *item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an item to a list.  <a href="group___mpr_list.html#gbf10109abc063c47702769c0e89442cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g159c096de4aec192e25b275f1f5e031d">mprAddNullToBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a null character to the buffer contents.  <a href="group___mpr_buf.html#g159c096de4aec192e25b275f1f5e031d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g61c8f33c54c45ad4d6bf33d8d72543c1">mprAdjustBufEnd</a> (MprBuf *buf, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the buffer end position.  <a href="group___mpr_buf.html#g61c8f33c54c45ad4d6bf33d8d72543c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g1fbe536bbdd8bc3f68a5246f69305994">mprAdjustBufStart</a> (MprBuf *buf, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the buffer start position.  <a href="group___mpr_buf.html#g1fbe536bbdd8bc3f68a5246f69305994"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec">mprAlloc</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory.  <a href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1817af523c1a6f663c792c74190c7ae4">mprAllocArena</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint arenaSize, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory arena.  <a href="group___mpr_mem.html#g1817af523c1a6f663c792c74190c7ae4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g81a5827a39d536c462e9ed1145b50248">mprAllocHeap</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint heapSize, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory heap.  <a href="group___mpr_mem.html#g81a5827a39d536c462e9ed1145b50248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g95dfa054deaafadfbfdb740f0d7d97c3">mprAllocObj</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object of a given type.  <a href="group___mpr_mem.html#g95dfa054deaafadfbfdb740f0d7d97c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb61e0804fdc8e8398bacd18e06ed0b2e">mprAllocObjWithDestructor</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor) extern void *mprAllocObjWithDestructorZeroed(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object of a given type with a destructor.  <a href="group___mpr_mem.html#gb61e0804fdc8e8398bacd18e06ed0b2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g4681a304da368211a957c3d7f40c107e">mprAllocObjZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a zeroed object of a given type.  <a href="group___mpr_mem.html#g4681a304da368211a957c3d7f40c107e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb4a28f8d8793b16758bef0cb22acc299">mprAllocSlab</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint objSize, uint count, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory slab heap.  <a href="group___mpr_mem.html#gb4a28f8d8793b16758bef0cb22acc299"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def">mprAllocWithDestructor</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object block of memory.  <a href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g9765c5e6c3653ed716df99f1eb883fd3">mprAllocWithDestructorZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object block of memory and zero it.  <a href="group___mpr_mem.html#g9765c5e6c3653ed716df99f1eb883fd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb6e0fd9b58e841c28bb49ec2ab37072d">mprAllocZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a zeroed block of memory.  <a href="group___mpr_mem.html#gb6e0fd9b58e841c28bb49ec2ab37072d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprList *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g5f81ae14eecf28b6e6bdd64677860e39">mprAppendList</a> (MprList *list, MprList *add)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a list.  <a href="group___mpr_list.html#g5f81ae14eecf28b6e6bdd64677860e39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#47b6a089018e38316476e97b49bb8d82">mprAsprintf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int maxSize, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a string into an allocated buffer.  <a href="#47b6a089018e38316476e97b49bb8d82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b2b1ebf1965beac947ab9b77970f49c5">mprAtoi</a> (cchar *str, int radix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a string to an integer.  <a href="#b2b1ebf1965beac947ab9b77970f49c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprFile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#ge05c883c658aef3c2e9da52e82e2a39b">mprAttachFd</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int fd, cchar *name, int omode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach to an existing file descriptor.  <a href="group___mpr_file.html#ge05c883c658aef3c2e9da52e82e2a39b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#gc5203b2138474e781207b39ac4726c1b">mprBreakpoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trigger a breakpoint.  <a href="group___mpr.html#gc5203b2138474e781207b39ac4726c1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gcf49292693e22c7bdc43fbb41a83817d">mprClearList</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the list of all items.  <a href="group___mpr_list.html#gcf49292693e22c7bdc43fbb41a83817d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#gc48a59b1bfc4f3944a88e152863c3d32">mprCloseCmdFd</a> (MprCmd *cmd, int channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the command channel.  <a href="group___mpr_cmd.html#gc48a59b1bfc4f3944a88e152863c3d32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g5bd6e40cb8a29c92a8f5e1ce9529b726">mprCloseSocket</a> (MprSocket *sp, bool graceful)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a socket.  <a href="group___mpr_socket.html#g5bd6e40cb8a29c92a8f5e1ce9529b726"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gab2501188e2f3f59008f8f27e14732e9">mprCompactBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compact the buffer contents.  <a href="group___mpr_buf.html#gab2501188e2f3f59008f8f27e14732e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#087ffc47d75b5f88dbfcabb8c3cd2d21">mprCompareTime</a> (<a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> t1, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two times.  <a href="#087ffc47d75b5f88dbfcabb8c3cd2d21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5f3e1db5d7e207edaa4dde272a63c5fa">mprConfigureSsl</a> (struct MprSsl *ssl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure SSL based on the parsed MprSsl configuration.  <a href="#5f3e1db5d7e207edaa4dde272a63c5fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#g84a5c66179387a6fc1090f5117d49af1">mprCopyHash</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a hash table.  <a href="group___mpr_hash.html#g84a5c66179387a6fc1090f5117d49af1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g64b04ef8c2be20d2d952ecfa22b7ce54">mprCopyList</a> (MprList *dest, MprList *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a list.  <a href="group___mpr_list.html#g64b04ef8c2be20d2d952ecfa22b7ce54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g5819b28cca6734f98b1fe114c5620d8a">mprCopyPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *from, cchar *to, int omode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a file.  <a href="group___mpr_path.html#g5819b28cca6734f98b1fe114c5620d8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Mpr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#g4e84f505d5b6f74de677ffff29806906">mprCreate</a> (int argc, char **argv, <a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a> cback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an instance of the MPR.  <a href="group___mpr.html#g4e84f505d5b6f74de677ffff29806906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprBuf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#ga2d850779c9881637028fcf54a1ebe30">mprCreateBuf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int initialSize, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new buffer.  <a href="group___mpr_buf.html#ga2d850779c9881637028fcf54a1ebe30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprCmd *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#gbc453ad9cdcd6046373ebfce72ce1fd6">mprCreateCmd</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Command object.  <a href="group___mpr_cmd.html#gbc453ad9cdcd6046373ebfce72ce1fd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f">mprCreateCond</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a condition lock variable.  <a href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#39e6373ded494a2d3154004e58a53caa">mprCreateDispatcher</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, int enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new event dispatcher.  <a href="#39e6373ded494a2d3154004e58a53caa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprEvent *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#gf292a0f7982192dba8e5f7535d24377d">mprCreateEvent</a> (MprDispatcher *dispatcher, cchar *name, int period, <a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> proc, void *data, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new event.  <a href="group___mpr_event.html#gf292a0f7982192dba8e5f7535d24377d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Mpr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#g045dc3d2476aebeecee838dacd0c63ba">mprCreateEx</a> (int argc, char **argv, <a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a> cback, void *shell)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an instance of the MPR.  <a href="group___mpr.html#g045dc3d2476aebeecee838dacd0c63ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#gf653f8353d355f27d6fc00883daa82d9">mprCreateHash</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int hashSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a hash table.  <a href="group___mpr_hash.html#gf653f8353d355f27d6fc00883daa82d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_key_value.html">MprKeyValue</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g6dc1e2980f934578a5a88f9f987adcf5">mprCreateKeyPair</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *key, cchar *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a key / value pair.  <a href="group___mpr_list.html#g6dc1e2980f934578a5a88f9f987adcf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprList *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gd5e29adbb51053e84bcb52b9f6756e37">mprCreateList</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a list.  <a href="group___mpr_list.html#gd5e29adbb51053e84bcb52b9f6756e37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g825387252381219bd94edfa9c60855fa">mprCreateLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Mutex lock object.  <a href="group___mpr_synch.html#g825387252381219bd94edfa9c60855fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprModule *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g63bd240ada3d4cb53ead7b4404fd5014">mprCreateModule</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a module.  <a href="group___mpr_module.html#g63bd240ada3d4cb53ead7b4404fd5014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprSocket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9">mprCreateSocket</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, struct MprSsl *ssl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a socket.  <a href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#ge63f87a8d093d294bd1ce6747cbb42ec">mprCreateSpinLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a spin lock lock object.  <a href="group___mpr_synch.html#ge63f87a8d093d294bd1ce6747cbb42ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprThread *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#g026dcaf0b9eb162486103a9b99632939">mprCreateThread</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, MprThreadProc proc, void *data, int stackSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new thread.  <a href="group___mpr_thread.html#g026dcaf0b9eb162486103a9b99632939"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprEvent *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g67402fd2c25d36deed940433da8350d3">mprCreateTimerEvent</a> (MprDispatcher *dispatcher, cchar *name, int period, <a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> proc, void *data, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a timer event.  <a href="group___mpr_event.html#g67402fd2c25d36deed940433da8350d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprWaitHandler *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd">mprCreateWaitHandler</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int fd, int mask, MprDispatcher *dispatcher, <a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> proc, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a wait handler.  <a href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#6161ae2c822d03b9bda53ef7663f14f9">mprDecode64</a> (char *buffer, int bufsize, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deocde buffer using base-46 encoding.  <a href="#6161ae2c822d03b9bda53ef7663f14f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct tm *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#g1fe29b0b5a726295afe36d28ab027270">mprDecodeLocalTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, struct tm *timep, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a time value into a tokenized local time value.  <a href="group___mpr_date.html#g1fe29b0b5a726295afe36d28ab027270"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct tm *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#g4437f3ff3a58a9cf9d4d7d9e763fcc1a">mprDecodeUniversalTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, struct tm *timep, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a time value into a tokenized UTC time structure.  <a href="group___mpr_date.html#g4437f3ff3a58a9cf9d4d7d9e763fcc1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7fe4c3fb94490eb462405d86f71514d7">mprDedicateWorker</a> (MprWorker *worker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dedicate a worker thread to a current real thread.  <a href="#7fe4c3fb94490eb462405d86f71514d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f738be140726725efc160324b0d209e8">mprDedicateWorkerToHandler</a> (MprWaitHandler *wp, struct MprWorker *worker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dedicate a worker thread to a wait handler.  <a href="#f738be140726725efc160324b0d209e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g4e9f46a4287d3c8392e2bacfc45fea75">mprDeletePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a file.  <a href="group___mpr_path.html#g4e9f46a4287d3c8392e2bacfc45fea75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g66cccaaaa550e9d2cf381ff8854c2d7a">mprDisableCmdEvents</a> (MprCmd *cmd, int channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable command I/O events.  <a href="group___mpr_cmd.html#g66cccaaaa550e9d2cf381ff8854c2d7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g457be50126337e42f1df6c30af9db510">mprDisableFileBuffering</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable file buffering.  <a href="group___mpr_file.html#g457be50126337e42f1df6c30af9db510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#40585bcce880703910e75ff4599529da">mprDisableSocketEvents</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable socket events for a socket callback.  <a href="#40585bcce880703910e75ff4599529da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_wait_handler.html#gdb816527b96de477a69bb9e99098c9cf">mprDisableWaitEvents</a> (MprWaitHandler *wp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable wait events.  <a href="group___mpr_wait_handler.html#gdb816527b96de477a69bb9e99098c9cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g7562126cafba57260cd73634f1ee4aed">mprDisconnectCmd</a> (MprCmd *cmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect a command its underlying I/O channels.  <a href="group___mpr_cmd.html#g7562126cafba57260cd73634f1ee4aed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5f9301dbcddf9d1a62b40c69bc67fe40">mprDisconnectSocket</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect a socket by closing its underlying file descriptor.  <a href="#5f9301dbcddf9d1a62b40c69bc67fe40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#176d0ea8501110003ec63c0e3ecf24f8">mprDtoa</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, double value, int ndigits, int mode, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a double to ascii.  <a href="#176d0ea8501110003ec63c0e3ecf24f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprList *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gc6512c8fa92c1d91cf99f4e3ad6af2f1">mprDupList</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, MprList *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a list.  <a href="group___mpr_list.html#gc6512c8fa92c1d91cf99f4e3ad6af2f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g2fd38e2aaf8e7c2a1aed39aa1005155e">mprEnableCmdEvents</a> (MprCmd *cmd, int channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable command I/O events.  <a href="group___mpr_cmd.html#g2fd38e2aaf8e7c2a1aed39aa1005155e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b9239642f6f3418d97c779c410a9aa91">mprEnableDispatcher</a> (MprDispatcher *dispatcher)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a dispatcher to service events.  <a href="#b9239642f6f3418d97c779c410a9aa91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g1912be708fa60f6afde7e174413507bc">mprEnableFileBuffering</a> (MprFile *file, int size, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable file buffering.  <a href="group___mpr_file.html#g1912be708fa60f6afde7e174413507bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a2b9f1eb8ccbe19f2ca1c277e9e714e2">mprEnableSocketEvents</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable socket events for a socket callback.  <a href="#a2b9f1eb8ccbe19f2ca1c277e9e714e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_wait_handler.html#g3a2dba730e20be0baf6166050ac947d4">mprEnableWaitEvents</a> (MprWaitHandler *wp, int desiredMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable wait events.  <a href="group___mpr_wait_handler.html#g3a2dba730e20be0baf6166050ac947d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e57602feb972619422110f9fbd0d8341">mprEncode64</a> (char *buffer, int bufsize, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode buffer using base-46 encoding.  <a href="#e57602feb972619422110f9fbd0d8341"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#gba80d025830577c73b7fab45b3ecd256">mprError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log an error message.  <a href="group___mpr_log.html#gba80d025830577c73b7fab45b3ecd256"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#43b32087d8a020c9fc1ed976a8e4371d">mprEscapeCmd</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *cmd, int escChar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a string escaping typical command (shell) characters.  <a href="#43b32087d8a020c9fc1ed976a8e4371d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4f15488d5680bfabf4f243c863d98314">mprEscapeHtml</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *html)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a string by escaping typical HTML characters.  <a href="#4f15488d5680bfabf4f243c863d98314"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g44e05f9b1cb74a3abd9271d140f5d66d">mprFatalError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log a fatal error message and exit.  <a href="group___mpr_log.html#g44e05f9b1cb74a3abd9271d140f5d66d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g91dff182995e9e7f443373a5b27da4f4">mprFlush</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush any buffered write data.  <a href="group___mpr_file.html#g91dff182995e9e7f443373a5b27da4f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g453b62a6659fc9fa4d041165dad7461e">mprFlushBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the buffer contents.  <a href="group___mpr_buf.html#g453b62a6659fc9fa4d041165dad7461e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g1e94b295effb81620c20b7ecf6e0e1d0">mprFlushSocket</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a socket.  <a href="group___mpr_socket.html#g1e94b295effb81620c20b7ecf6e0e1d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#g70e43deb465cef84d2387800ae07a194">mprFormatLocalTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a time value to local time and format as a string.  <a href="group___mpr_date.html#g70e43deb465cef84d2387800ae07a194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#g315d7591e179c57cd2072796a8dce0c5">mprFormatTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt, struct tm *timep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a time value as a local time.  <a href="group___mpr_date.html#g315d7591e179c57cd2072796a8dce0c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#07783ffc93b6fd136de7b927ccceed19">mprFprintf</a> (struct MprFile *file, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a formatted message to a file descriptor.  <a href="#07783ffc93b6fd136de7b927ccceed19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045">mprFree</a> (void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a block of memory.  <a href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1d03816923ffb4392c095869ac37d0c0">mprFreeChildren</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all the children blocks allocated of a block.  <a href="#1d03816923ffb4392c095869ac37d0c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g6d804c1b812c9ea7a1d0fb09764def90">mprGetAbsPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a path to an absolute path.  <a href="group___mpr_path.html#g6d804c1b812c9ea7a1d0fb09764def90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprAlloc *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c1c737cca87de821e71f45c89b965365">mprGetAllocStats</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current allocation memory statistics block.  <a href="#c1c737cca87de821e71f45c89b965365"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#de408e459ab57104df4b4c1376d3ff22">mprGetAppDir</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the application directory.  <a href="#de408e459ab57104df4b4c1376d3ff22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ee21b01fdc7627c3511f24c98252a706">mprGetAppName</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the application name defined via mprSetAppName.  <a href="#ee21b01fdc7627c3511f24c98252a706"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b4545c6b9e0fc0e129525b3a7c3f41f5">mprGetAppPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the application executable path.  <a href="#b4545c6b9e0fc0e129525b3a7c3f41f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_worker_service.html#gf26e38fd431360fd0099279a28acdd9b">mprGetAvailableWorkers</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the count of available worker threads Return the count of free threads in the worker thread pool.  <a href="group___mpr_worker_service.html#gf26e38fd431360fd0099279a28acdd9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g3a1388925b9ab4a209b0610cd674139f">mprGetBlockFromBuf</a> (MprBuf *buf, char *blk, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a block of data from the buffer.  <a href="group___mpr_buf.html#g3a1388925b9ab4a209b0610cd674139f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gbd1fae7a41a8c38220de4f06e6d0e053">mprGetBufEnd</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the end of the buffer contents.  <a href="group___mpr_buf.html#gbd1fae7a41a8c38220de4f06e6d0e053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g4d39e8467818e491ecec68a4db8df054">mprGetBufLength</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer content length.  <a href="group___mpr_buf.html#g4d39e8467818e491ecec68a4db8df054"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g962aeff07a87ab52da3bcd1973fe801b">mprGetBufOrigin</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the origin of the buffer content storage.  <a href="group___mpr_buf.html#g962aeff07a87ab52da3bcd1973fe801b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7">MprBufProc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g2791daeb72ae2e3f455250dfba72aa67">mprGetBufRefillProc</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffer refill procedure.  <a href="group___mpr_buf.html#g2791daeb72ae2e3f455250dfba72aa67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#ga609f1dc4e3f8315949c4cf93e27aff1">mprGetBufSize</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current size of the buffer content storage.  <a href="group___mpr_buf.html#ga609f1dc4e3f8315949c4cf93e27aff1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g6c6646d8f5933dfbf31983a374b491e7">mprGetBufSpace</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the space available to store content.  <a href="group___mpr_buf.html#g6c6646d8f5933dfbf31983a374b491e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gc982291efef3d49cce4bc2ecec6566e5">mprGetBufStart</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the start of the buffer contents.  <a href="group___mpr_buf.html#gc982291efef3d49cce4bc2ecec6566e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g33e438e507e4e5effcddb2cc103e5c26">mprGetc</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a character from the file.  <a href="group___mpr_file.html#g33e438e507e4e5effcddb2cc103e5c26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gf128b71005bdd12507110e1f21b483d4">mprGetCharFromBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a character from the buffer.  <a href="group___mpr_buf.html#gf128b71005bdd12507110e1f21b483d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprBuf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g68cf4226027c07ba3f3e5b30ecd48590">mprGetCmdBuf</a> (MprCmd *cmd, int channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying buffer for a channel.  <a href="group___mpr_cmd.html#g68cf4226027c07ba3f3e5b30ecd48590"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g4dcefa4a65ff85b78c9b6580abac0a62">mprGetCmdExitStatus</a> (MprCmd *cmd, int *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the command exit status.  <a href="group___mpr_cmd.html#g4dcefa4a65ff85b78c9b6580abac0a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#gb286ce3b057579a16b84ec56997ae63f">mprGetCmdFd</a> (MprCmd *cmd, int channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying file descriptor for an I/O channel.  <a href="group___mpr_cmd.html#gb286ce3b057579a16b84ec56997ae63f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprOsThread&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#ga499ec9a691d9b74753edeac24afbcdc">mprGetCurrentOsThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the O/S thread.  <a href="group___mpr_thread.html#ga499ec9a691d9b74753edeac24afbcdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#8b5d0f5ed666f1ec48caaf65a9304acb">mprGetCurrentPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current working directory.  <a href="#8b5d0f5ed666f1ec48caaf65a9304acb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprThread *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#gf7be9fb3ab99388b3e83093a78a74265">mprGetCurrentThread</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the currently executing thread.  <a href="group___mpr_thread.html#gf7be9fb3ab99388b3e83093a78a74265"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#09693a2d0138d474b5825bdc4d742fcc">mprGetCurrentThreadName</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of the current thread.  <a href="#09693a2d0138d474b5825bdc4d742fcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#g1392efc11ff7ec56f8cb2e3b6fa1168c">mprGetDebugMode</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the debug mode.  <a href="group___mpr.html#g1392efc11ff7ec56f8cb2e3b6fa1168c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a3492a2cff32689b04b0989a834d7bca">mprGetDispatcher</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the MPR primary dispatcher.  <a href="#a3492a2cff32689b04b0989a834d7bca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ebad4782acd4f2cd541ce68737f98471">mprGetElapsedTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> mark)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the elapsed time since a time mark.  <a href="#ebad4782acd4f2cd541ce68737f98471"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#gf184a06275222c97f80e0a8d807418ac">mprGetError</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error code for the most recent system or library operation.  <a href="group___mpr.html#gf184a06275222c97f80e0a8d807418ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprOffset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g96273fe03aa3e5e1de8820e8aaba7e5c">mprGetFilePosition</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current file position.  <a href="group___mpr_file.html#g96273fe03aa3e5e1de8820e8aaba7e5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprOffset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#gb1ae4e8c4128773497a609e444dbe8c7">mprGetFileSize</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the file.  <a href="group___mpr_file.html#gb1ae4e8c4128773497a609e444dbe8c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHash *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#g56c37e6def80582b297fa3c27cd5a15e">mprGetFirstHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first symbol in a symbol entry.  <a href="group___mpr_hash.html#g56c37e6def80582b297fa3c27cd5a15e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g34b6f80710796e4d3d766299ebf37078">mprGetFirstItem</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first item in the list.  <a href="group___mpr_list.html#g34b6f80710796e4d3d766299ebf37078"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#gb18f7a0015706d7c7ded172357978875">mprGetHashCount</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the count of symbols in a symbol entry.  <a href="group___mpr_hash.html#gb18f7a0015706d7c7ded172357978875"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g4535837cc644f208063b1ca3e2ae46c2">mprGetItem</a> (MprList *list, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an list item.  <a href="group___mpr_list.html#g4535837cc644f208063b1ca3e2ae46c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g629c61d9bfbea110851227fd61569093">mprGetLastItem</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last item in the list.  <a href="group___mpr_list.html#g629c61d9bfbea110851227fd61569093"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gc47331b3442493d84405d32ffcb98aba">mprGetListCapacity</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current capacity of the list.  <a href="group___mpr_list.html#gc47331b3442493d84405d32ffcb98aba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g8710190bcf91677b3758890b7deefd75">mprGetListCount</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of items in the list.  <a href="group___mpr_list.html#g8710190bcf91677b3758890b7deefd75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689">MprLogHandler</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#gdfefb0345bcaca30d7d86650b06d6bae">mprGetLogHandler</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current MPR debug log handler.  <a href="group___mpr_log.html#gdfefb0345bcaca30d7d86650b06d6bae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5a047d643f4c0b4f2dc2760aeea3e61c">mprGetLogLevel</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current logging level.  <a href="#5a047d643f4c0b4f2dc2760aeea3e61c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_worker_service.html#g5ec8913eb20bf209312f10f69005667a">mprGetMaxWorkers</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum count of worker pool threads Get the maximum limit of worker pool threads.  <a href="group___mpr_worker_service.html#g5ec8913eb20bf209312f10f69005667a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a5fff86cf2f5455dba2476c579ca3efb">mprGetMD5Hash</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *buf, int len, cchar *prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an MD5 checksum.  <a href="#a5fff86cf2f5455dba2476c579ca3efb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g33859b7b158056a95d73f106f76fe7fb">mprGetModuleSearchPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the module search path.  <a href="group___mpr_module.html#g33859b7b158056a95d73f106f76fe7fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g2de05fa43e494c05da7b2e941f3f407d">mprGetNativePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a path formatted according to the native O/S conventions.  <a href="group___mpr_path.html#g2de05fa43e494c05da7b2e941f3f407d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHash *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#gba1514fa60bf0b72bf528b2c1fbecfc3">mprGetNextHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, MprHash *last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next symbol in a symbol entry.  <a href="group___mpr_hash.html#gba1514fa60bf0b72bf528b2c1fbecfc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gf84ab68545207f073e9f916adc8817e4">mprGetNextItem</a> (MprList *list, int *lastIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next item in the list.  <a href="group___mpr_list.html#gf84ab68545207f073e9f916adc8817e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g94ae6e9571d7089105a11a38b758d808">mprGetNormalizedPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a path.  <a href="group___mpr_path.html#g94ae6e9571d7089105a11a38b758d808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#gd2fa15bdd6890ff1df432ae25f4c981c">mprGetOsError</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the O/S error code.  <a href="group___mpr.html#gd2fa15bdd6890ff1df432ae25f4c981c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#144c637773024a22bbc1be9a257555ef">mprGetPageSize</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current O/S virtual page size.  <a href="#144c637773024a22bbc1be9a257555ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ga2917f1fe62535e7f18549bad3c87c3f">mprGetParent</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the memory parent of a block.  <a href="group___mpr_mem.html#ga2917f1fe62535e7f18549bad3c87c3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g40b746d52c5d360b93e62cd7f151e790">mprGetPathBase</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the base portion of a path.  <a href="group___mpr_path.html#g40b746d52c5d360b93e62cd7f151e790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g0b13450482bec406bd1ca4f97e8b0ac9">mprGetPathDir</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the directory portion of a path.  <a href="group___mpr_path.html#g0b13450482bec406bd1ca4f97e8b0ac9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g2aca381507c3d8455a896015d3532421">mprGetPathExtension</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file extension portion of a path.  <a href="group___mpr_path.html#g2aca381507c3d8455a896015d3532421"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprList *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#gbee132c7baac86f676fa60f28d387341">mprGetPathFiles</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *dir, bool enumDirs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a directory list of files.  <a href="group___mpr_path.html#gbee132c7baac86f676fa60f28d387341"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g57c6c3e051b4c39dc2f320adbb27df9d">mprGetPathInfo</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, MprPath *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return information about a file represented by a path.  <a href="group___mpr_path.html#g57c6c3e051b4c39dc2f320adbb27df9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g85a7b4f2de356310207f30d416e4b64e">mprGetPathNewline</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file newline character string for a given path.  <a href="group___mpr_path.html#g85a7b4f2de356310207f30d416e4b64e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g962d4a24986091501b0db73e3d55d2b2">mprGetPathParent</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent directory of a path.  <a href="group___mpr_path.html#g962d4a24986091501b0db73e3d55d2b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g15dd176c544a6d52fa77c32cec9ab45d">mprGetPathSeparators</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the path directory separator.  <a href="group___mpr_path.html#g15dd176c544a6d52fa77c32cec9ab45d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g8679aa877fd97feb7173442aab53b308">mprGetPortablePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a portable path.  <a href="group___mpr_path.html#g8679aa877fd97feb7173442aab53b308"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g701e2771ac787973c94e523898d596a6">mprGetPrevItem</a> (MprList *list, int *lastIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the previous item in the list.  <a href="group___mpr_list.html#g701e2771ac787973c94e523898d596a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g947673b01c05ec0b68cdebb4159bddee">mprGetRelPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a relative path.  <a href="group___mpr_path.html#g947673b01c05ec0b68cdebb4159bddee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#gc0334d0cee72fb5d5bd9a5dd63b62b03">mprGetRemainingTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> mark, uint timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the time remaining until a timeout has elapsed.  <a href="group___mpr_date.html#gc0334d0cee72fb5d5bd9a5dd63b62b03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g15a5b5e70b74166eb1aea7d278d11358">mprGets</a> (MprFile *file, char *buf, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a line from the file.  <a href="group___mpr_file.html#g15a5b5e70b74166eb1aea7d278d11358"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g8240b2dc5540ae928d19410447c2bab0">mprGetSocketBlockingMode</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the socket blocking mode.  <a href="group___mpr_socket.html#g8240b2dc5540ae928d19410447c2bab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g64ccf4250b432690a73bb66f0a639f7a">mprGetSocketError</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a socket error code.  <a href="group___mpr_socket.html#g64ccf4250b432690a73bb66f0a639f7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g4ed3619958eac42ab4e8136464ae00c3">mprGetSocketFd</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the socket file descriptor.  <a href="group___mpr_socket.html#g4ed3619958eac42ab4e8136464ae00c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#ga4d2f67f80f168a4be7e5f3b96541bab">mprGetSocketPort</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the port used by a socket.  <a href="group___mpr_socket.html#ga4d2f67f80f168a4be7e5f3b96541bab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprFile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7084bfea78dcf720c82e7163b9dbc4da">mprGetStderr</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a file object for the Stderr I/O channel.  <a href="#7084bfea78dcf720c82e7163b9dbc4da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprFile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f260b8f2c8c000a6f4ec1ac7569e8416">mprGetStdin</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a file object for the Stdin I/O channel.  <a href="#f260b8f2c8c000a6f4ec1ac7569e8416"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprFile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#29ffea058d6f735313ee8a81fd3334dd">mprGetStdout</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a file object for the Stdout I/O channel.  <a href="#29ffea058d6f735313ee8a81fd3334dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g5539f40a5da3f48b5b2db3ea90e28221">mprGetTempPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *tmpDir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a temporary file.  <a href="group___mpr_path.html#g5539f40a5da3f48b5b2db3ea90e28221"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#gc98816057bf8f47f8d15131e68ae12f7">mprGetThreadName</a> (MprThread *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread name.  <a href="group___mpr_thread.html#gc98816057bf8f47f8d15131e68ae12f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#g0edd7ee5a80c5566dbcd079293280b1a">mprGetThreadPriority</a> (MprThread *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the thread priroity.  <a href="group___mpr_thread.html#g0edd7ee5a80c5566dbcd079293280b1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_date.html#gedc887ffd106e62ff9f4e69044910c92">mprGetTime</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the system time.  <a href="group___mpr_date.html#gedc887ffd106e62ff9f4e69044910c92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#gadb495c2337079742752f4e8e572d975">mprGetTransformedPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform a path.  <a href="group___mpr_path.html#gadb495c2337079742752f4e8e572d975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a071656602927b54f839595f162336a9">mprGetUsedMemory</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the amount of memory currently used by the application.  <a href="#a071656602927b54f839595f162336a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#38c5795e4d552281fbf168b679d89704">mprGetWordTok</a> (char *buf, int bufsize, cchar *str, cchar *delim, cchar **tok)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next word token.  <a href="#38c5795e4d552281fbf168b679d89704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g934273252bb4202c8adeb9d8841769a4">mprGlobalLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally lock the application.  <a href="group___mpr_synch.html#g934273252bb4202c8adeb9d8841769a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g9af03d596ad19cd7974d85d82a8c27ca">mprGlobalUnlock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the global mutex.  <a href="group___mpr_synch.html#g9af03d596ad19cd7974d85d82a8c27ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g6c40bdb62af47cbae761c6bfdc7da11b">mprGrowBuf</a> (MprBuf *buf, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow the buffer.  <a href="group___mpr_buf.html#g6c40bdb62af47cbae761c6bfdc7da11b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g46b725c5e3a7818e3051401b016f7902">mprHasAllocError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the MPR has encountered memory allocation errors.  <a href="group___mpr_mem.html#g46b725c5e3a7818e3051401b016f7902"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#634f21ee23b89c3612785f8a59d27103">mprHasSecureSockets</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if SSL is available.  <a href="#634f21ee23b89c3612785f8a59d27103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g9ba5a2637bcf166c5b3f4289e590bb39">mprHasSocketPendingData</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the socket has buffered read data.  <a href="group___mpr_socket.html#g9ba5a2637bcf166c5b3f4289e590bb39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b136a423c6fa64f6b9c3b05576ed07ba">mprInitBlock</a> (void *ptr, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a block of memory.  <a href="#b136a423c6fa64f6b9c3b05576ed07ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#gd1638be85f9f4424a91c7fff288a4f74">mprInitEvent</a> (MprDispatcher *dispatcher, MprEvent *event, cchar *name, int period, <a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> proc, void *data, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an event.  <a href="group___mpr_event.html#gd1638be85f9f4424a91c7fff288a4f74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gc1b1433c9a3b963c78572f53cf2a6fd8">mprInitList</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a list structure.  <a href="group___mpr_list.html#gc1b1433c9a3b963c78572f53cf2a6fd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#ge5ac7172314ec00d74bc8a5b61ee98fa">mprInitLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="struct_mpr_mutex.html">MprMutex</a> *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a statically allocated Mutex lock object.  <a href="group___mpr_synch.html#ge5ac7172314ec00d74bc8a5b61ee98fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gd0e8debf5fc06d66c839ef8979d8e4c9">mprInitSpinLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a statically allocated spinlock object.  <a href="group___mpr_synch.html#gd0e8debf5fc06d66c839ef8979d8e4c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprWaitHandler *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_wait_handler.html#g4aba5720db6c4d68637f34019eea4559">mprInitWaitHandler</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, MprWaitHandler *wp, int fd, int mask, MprDispatcher *dispatcher, <a class="el" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">MprEventProc</a> proc, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statically initialize a wait handler.  <a href="group___mpr_wait_handler.html#g4aba5720db6c4d68637f34019eea4559"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g6f91b177cd36508c9d470636b04fa7b5">mprInsertCharToBuf</a> (MprBuf *buf, int c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a character into the buffer.  <a href="group___mpr_buf.html#g6f91b177cd36508c9d470636b04fa7b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gf3e8599ae4707459cf42ad960256af98">mprInsertItemAtPos</a> (MprList *list, int index, cvoid *item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an item into a list at a specific position.  <a href="group___mpr_list.html#gf3e8599ae4707459cf42ad960256af98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g081cac7e87fa8a3800d0cdd3112d5c08">mprIsAbsPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a path is absolute.  <a href="group___mpr_path.html#g081cac7e87fa8a3800d0cdd3112d5c08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g5ac545e5959e115b2cd633004f5d949b">mprIsCmdRunning</a> (MprCmd *cmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the command is still running.  <a href="group___mpr_cmd.html#g5ac545e5959e115b2cd633004f5d949b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#g1dfe792f44331fa47bb8e8cb8c04a2c7">mprIsExiting</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the MPR should exit.  <a href="group___mpr.html#g1dfe792f44331fa47bb8e8cb8c04a2c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#ge2e81ff8178627822dcac584dc719326">mprIsRelPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a path is relative.  <a href="group___mpr_path.html#ge2e81ff8178627822dcac584dc719326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g122966f272c5d7d00bab8f66d569d362">mprIsSocketEof</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the other end of the socket has been closed.  <a href="group___mpr_socket.html#g122966f272c5d7d00bab8f66d569d362"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#gbeeb5c489632e55d36e2139f8ac0f423">mprIsSocketSecure</a> (MprSocket *sp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the socket is secure.  <a href="group___mpr_socket.html#gbeeb5c489632e55d36e2139f8ac0f423"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#eb1d9013dbfca5d9080b881e0fde2cde">mprIsValid</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test is a pointer is a valid memory context.  <a href="#eb1d9013dbfca5d9080b881e0fde2cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c44ccf179c55dbbcf7aa04ba86090463">mprItoa</a> (char *buf, int size, int64 value, int radix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an integer to a string.  <a href="#c44ccf179c55dbbcf7aa04ba86090463"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g4d312924fd21c6cb9067857a0225782f">mprJoinPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *dir, cchar *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join paths.  <a href="group___mpr_path.html#g4d312924fd21c6cb9067857a0225782f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g4ef9ac6d0d8789279fef742255d56879">mprJoinPathExt</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *dir, cchar *ext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join an extension to a path.  <a href="group___mpr_path.html#g4ef9ac6d0d8789279fef742255d56879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprModule *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g62c9cd99f99d97a0ee2cecfe6bc4cd06">mprLoadModule</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, cchar *entryPoint, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a module.  <a href="group___mpr_module.html#g62c9cd99f99d97a0ee2cecfe6bc4cd06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprModule *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7f73646ba41280e4da88fd7ff89bd383">mprLoadSsl</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, bool lazy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the SSL module.  <a href="#7f73646ba41280e4da88fd7ff89bd383"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede">mprLock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock access.  <a href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g86f03e0fb54d0f897fec0981d3671c41">mprLog</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int level, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a message to the diagnostic log file.  <a href="group___mpr_log.html#g86f03e0fb54d0f897fec0981d3671c41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g9ae5abc2e8c8b3359ca450e505564359">mprLookAtLastCharInBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the last character in the buffer.  <a href="group___mpr_buf.html#g9ae5abc2e8c8b3359ca450e505564359"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gbe01ab970d735db5a92cea5f9456de5e">mprLookAtNextCharInBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the next character in the buffer.  <a href="group___mpr_buf.html#gbe01ab970d735db5a92cea5f9456de5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cvoid *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#gf3613de4c34a09b684aebddadc0851cb">mprLookupHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, cchar *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup a symbol in the hash table.  <a href="group___mpr_hash.html#gf3613de4c34a09b684aebddadc0851cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHash *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#g69e2a6c5e3b8f36892d841d7019a657f">mprLookupHashEntry</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, cchar *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup a symbol in the hash table and return the hash entry.  <a href="group___mpr_hash.html#g69e2a6c5e3b8f36892d841d7019a657f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g8b3d6afe4be8d416e28f64d05e8391eb">mprLookupItem</a> (MprList *list, cvoid *item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an item and return its index.  <a href="group___mpr_list.html#g8b3d6afe4be8d416e28f64d05e8391eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">cchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#92480f400bf2488c4901993123df7de6">mprLookupMimeType</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *ext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mime type for an extension.  <a href="#92480f400bf2488c4901993123df7de6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprModule *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g3ffc2650baf7a3b10490450ea5defb48">mprLookupModule</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup a module.  <a href="group___mpr_module.html#g3ffc2650baf7a3b10490450ea5defb48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g79b9d648fb26331b46aab5d8d6b0bce4">mprMakeCmdIO</a> (MprCmd *cmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the I/O channels to send and receive data to and from the command.  <a href="group___mpr_cmd.html#g79b9d648fb26331b46aab5d8d6b0bce4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g3b396266e71364659d4d0fe25c41c052">mprMakeDir</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, int perms, bool makeMissing)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a directory.  <a href="group___mpr_path.html#g3b396266e71364659d4d0fe25c41c052"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#6d8444f927dac1b01ccb48450c2cb0d1">mprMapAlloc</a> (uint size, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory virtual memory into the applications address space.  <a href="#6d8444f927dac1b01ccb48450c2cb0d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#2c5d14b85515f1d8155856285e50611f">mprMapFree</a> (void *ptr, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free (unpin) a mapped section of virtual memory.  <a href="#2c5d14b85515f1d8155856285e50611f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g6f84759fa62171fd5ff1dae1bff70e08">mprMapSeparators</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, char *path, int separator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map the separators in a path.  <a href="group___mpr_path.html#g6f84759fa62171fd5ff1dae1bff70e08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1775b8543a4e3b0559f0e279bb5e37a6">mprMemcmp</a> (cvoid *b1, int b1Len, cvoid *b2, int b2Len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two byte strings.  <a href="#1775b8543a4e3b0559f0e279bb5e37a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#bcb752b124b706ebff6798cfeafc9f99">mprMemcpy</a> (void *dest, int destMax, cvoid *src, int nbytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe copy for a block of data.  <a href="#bcb752b124b706ebff6798cfeafc9f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g53e8e5ceb47594177a2db18c5acc5f65">mprMemoryError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log a memory error message.  <a href="group___mpr_log.html#g53e8e5ceb47594177a2db18c5acc5f65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprFile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g4f97953317f303fe033be11fcbcec4e9">mprOpen</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *filename, int omode, int perms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a file.  <a href="group___mpr_file.html#g4f97953317f303fe033be11fcbcec4e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g52aa9a1c6e3f411df5f4cdd9e787ed16">mprOpenClientSocket</a> (MprSocket *sp, cchar *hostName, int port, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a client socket.  <a href="group___mpr_socket.html#g52aa9a1c6e3f411df5f4cdd9e787ed16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#ge3e24d3cf87c63f71440aed20b5486cc">mprOpenServerSocket</a> (MprSocket *sp, cchar *ip, int port, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a server socket.  <a href="group___mpr_socket.html#ge3e24d3cf87c63f71440aed20b5486cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#978aa9d1ee3d0fe7b50e566f3d471ed3">mprParseIp</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *ipSpec, char **ip, int *port, int defaultPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an IP address.  <a href="#978aa9d1ee3d0fe7b50e566f3d471ed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#gbdd09f63c16165c91f22a479d29c6ffe">mprPathExists</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, int omode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a file exists for a path name and can be accessed.  <a href="group___mpr_path.html#gbdd09f63c16165c91f22a479d29c6ffe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#gb50f74711c89a6eb57363aee8090b6bb">mprPeekc</a> (MprFile *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-destructively read a character from the file.  <a href="group___mpr_file.html#gb50f74711c89a6eb57363aee8090b6bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g9aee91a4b53a03ea5dcf603b3c2437b8">mprPollCmdPipes</a> (MprCmd *cmd, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll for I/O on the command pipes.  <a href="group___mpr_cmd.html#g9aee91a4b53a03ea5dcf603b3c2437b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3413b2b0b86894f0ca40efa0f7156bea">mprPrintAllocReport</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a memory usage report to stdout.  <a href="#3413b2b0b86894f0ca40efa0f7156bea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#dfbd1fa43e7b737e566661e5d6ab6c36">mprPrintf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formatted print.  <a href="#dfbd1fa43e7b737e566661e5d6ab6c36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#13f99df19731bdfca83cd7ab64b6dd90">mprPrintfError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a formatted message to the standard error channel.  <a href="#13f99df19731bdfca83cd7ab64b6dd90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#gba03b8d6ddac9b5e4dce96bc470e5af7">mprPumpEvents</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int delay, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pump events.  <a href="group___mpr_event.html#gba03b8d6ddac9b5e4dce96bc470e5af7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g3a8934d430c8345cd1e19b42173b1336">mprPutBlockToBuf</a> (MprBuf *buf, cchar *ptr, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a block to the buffer.  <a href="group___mpr_buf.html#g3a8934d430c8345cd1e19b42173b1336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#gda34b4c0fbd1cd04fd636ab49e7dcb71">mprPutc</a> (MprFile *file, int c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a character to the file.  <a href="group___mpr_file.html#gda34b4c0fbd1cd04fd636ab49e7dcb71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g5ab66b5d96db8b33e3bb0c3bbb9c90e2">mprPutCharToBuf</a> (MprBuf *buf, int c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a character to the buffer.  <a href="group___mpr_buf.html#g5ab66b5d96db8b33e3bb0c3bbb9c90e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g87bc8fae31c0dc3ffae2c7d4fb4aa49b">mprPutFmtToBuf</a> (MprBuf *buf, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a formatted string to the buffer.  <a href="group___mpr_buf.html#g87bc8fae31c0dc3ffae2c7d4fb4aa49b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g117b7d1d0a1b08b7395a2ad67a1a5ccc">mprPutIntToBuf</a> (MprBuf *buf, int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put an integer to the buffer.  <a href="group___mpr_buf.html#g117b7d1d0a1b08b7395a2ad67a1a5ccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g3a72ff88a352a7d2a5cd01e46fb1fdd1">mprPutPadToBuf</a> (MprBuf *buf, int c, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put padding characters to the buffer.  <a href="group___mpr_buf.html#g3a72ff88a352a7d2a5cd01e46fb1fdd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#ge172b6c82656af8d7a4f82bdff01977c">mprPuts</a> (MprFile *file, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a string to the file.  <a href="group___mpr_file.html#ge172b6c82656af8d7a4f82bdff01977c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g482c21dd3356edd53d804b14c5c9f253">mprPutStringToBuf</a> (MprBuf *buf, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a string to the buffer.  <a href="group___mpr_buf.html#g482c21dd3356edd53d804b14c5c9f253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g41b37490b7840471fb6a03288f00df06">mprPutSubStringToBuf</a> (MprBuf *buf, cchar *str, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a substring to the buffer.  <a href="group___mpr_buf.html#g41b37490b7840471fb6a03288f00df06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g0a9fa25c6efe71b9f18314f79335fe2f">mprQueueEvent</a> (MprDispatcher *dispatcher, MprEvent *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue a new event for service.  <a href="group___mpr_event.html#g0a9fa25c6efe71b9f18314f79335fe2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#52f88939c5c03270beff007574b4aeb0">mprQueueIOEvent</a> (MprWaitHandler *wp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue an IO event for dispatch on the wait handler dispatcher.  <a href="#52f88939c5c03270beff007574b4aeb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g54e411388517de37fddd5537b0339e07">mprRawLog</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int level, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a raw log message to the diagnostic log file.  <a href="group___mpr_log.html#g54e411388517de37fddd5537b0339e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#ge3052b9893259fb2f245d5e08310d9c5">mprRead</a> (MprFile *file, void *buf, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a file.  <a href="group___mpr_file.html#ge3052b9893259fb2f245d5e08310d9c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g4a9036d982e301eb389e36b3b6a2bee7">mprReadCmdPipe</a> (MprCmd *cmd, int channel, char *buf, int bufsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the I/O channels to send and receive data to and from the command.  <a href="group___mpr_cmd.html#g4a9036d982e301eb389e36b3b6a2bee7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#gbff8106d1e1a3b5aa108542d3241f0b5">mprReadSocket</a> (MprSocket *sp, void *buf, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a socket.  <a href="group___mpr_socket.html#gbff8106d1e1a3b5aa108542d3241f0b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g3fa0c34d79f33c76f6d6813f0774b8b4">mprRealloc</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, void *ptr, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocate a block.  <a href="group___mpr_mem.html#g3fa0c34d79f33c76f6d6813f0774b8b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#2493bcee3c3b7f8351e16c731dd401f6">mprReallocStrcat</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int max, char *buf, cchar *src,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append strings to an existing string and reallocate as required.  <a href="#2493bcee3c3b7f8351e16c731dd401f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g5644e84254f86b9f85374e90d081f0fc">mprReapCmd</a> (MprCmd *cmd, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reap the command.  <a href="group___mpr_cmd.html#g5644e84254f86b9f85374e90d081f0fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_wait_handler.html#gd95b0d5c47ddbc6f5219a4a2c0678ab9">mprRecallWaitHandler</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recall a wait handler.  <a href="group___mpr_wait_handler.html#gd95b0d5c47ddbc6f5219a4a2c0678ab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g9e7451ec61507706a06c6c8149bebc52">mprRefillBuf</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refill the buffer with data.  <a href="group___mpr_buf.html#g9e7451ec61507706a06c6c8149bebc52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#dae3b874e39e0d5e0155d5179f1d83cc">mprReleaseWorker</a> (MprWorker *worker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a worker thread.  <a href="#dae3b874e39e0d5e0155d5179f1d83cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e0e96f55e5ae3bd167e1b51f563e580d">mprReleaseWorkerFromHandler</a> (MprWaitHandler *wp, struct MprWorker *worker)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a worker thread.  <a href="#e0e96f55e5ae3bd167e1b51f563e580d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g9163bc8e37a8ff05c0c957cfcc86e02e">mprRemoveEvent</a> (MprEvent *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an event.  <a href="group___mpr_event.html#g9163bc8e37a8ff05c0c957cfcc86e02e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_hash.html#g18a3c4ccbb662c68f32d6eff52f045bf">mprRemoveHash</a> (<a class="el" href="struct_mpr_hash_table.html">MprHashTable</a> *table, cchar *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a symbol entry from the hash table.  <a href="group___mpr_hash.html#g18a3c4ccbb662c68f32d6eff52f045bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g2206c8d8a7049ad6f26ff74c215f32a7">mprRemoveItem</a> (MprList *list, void *item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an item from the list.  <a href="group___mpr_list.html#g2206c8d8a7049ad6f26ff74c215f32a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#gc758d5af71b0bbf943bb6a1e263a494c">mprRemoveItemAtPos</a> (MprList *list, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an item from the list.  <a href="group___mpr_list.html#gc758d5af71b0bbf943bb6a1e263a494c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g85633d8034896cf4f056caa1857bf4a8">mprRemoveLastItem</a> (MprList *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last item from the list.  <a href="group___mpr_list.html#g85633d8034896cf4f056caa1857bf4a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g16748fa2520761d373cebe4b39be3e8e">mprRemoveRangeOfItems</a> (MprList *list, int start, int end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a range of items from the list.  <a href="group___mpr_list.html#g16748fa2520761d373cebe4b39be3e8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a7e94f04dd2634590ebf35d099bc3c63">mprRemoveWaitHandler</a> (MprWaitHandler *wp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect a wait handler from its underlying file descriptor.  <a href="#a7e94f04dd2634590ebf35d099bc3c63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#1f9db7dccdae9651f616f3e0740d6c81">mprReparent</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cvoid *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reparent a block.  <a href="#1f9db7dccdae9651f616f3e0740d6c81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#gf33d646f5cdb5e2e798b22e1b941e79b">mprRescheduleEvent</a> (MprEvent *event, int period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reschedule an event.  <a href="group___mpr_event.html#gf33d646f5cdb5e2e798b22e1b941e79b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g8a1a2ca6fb1f9e1cd45660ba1004e9a2">mprResetAllocError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the memory allocation error flag.  <a href="group___mpr_mem.html#g8a1a2ca6fb1f9e1cd45660ba1004e9a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#ge6f9d70c3aab3eb2d9235a1c2a8f63a8">mprResetBufIfEmpty</a> (MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the buffer.  <a href="group___mpr_buf.html#ge6f9d70c3aab3eb2d9235a1c2a8f63a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3db47bdecb58c2c52197d625377cf71b">mprResetCond</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset a condition variable.  <a href="#3db47bdecb58c2c52197d625377cf71b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g413a694581512471730fcc80c2b5338a">mprResolvePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, cchar *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve paths.  <a href="group___mpr_path.html#g413a694581512471730fcc80c2b5338a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g6fa51ab06c56baaad50f1b4df7efc1d4">mprRestartContinuousEvent</a> (MprEvent *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart an event.  <a href="group___mpr_event.html#g6fa51ab06c56baaad50f1b4df7efc1d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g7f80cf889cf937a284d78552298667b3">mprRunCmd</a> (MprCmd *cmd, cchar *command, char **out, char **err, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a command using a string command line.  <a href="group___mpr_cmd.html#g7f80cf889cf937a284d78552298667b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#gfcea6f14d60761368a0644eb0c0de2aa">mprRunCmdV</a> (MprCmd *cmd, int argc, char **argv, char **out, char **err, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a command using an argv[] array of arguments.  <a href="group___mpr_cmd.html#gfcea6f14d60761368a0644eb0c0de2aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g1fe179d2b59869522057af90f9d0e28e">mprSamePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path1, cchar *path2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two paths if they are the same.  <a href="group___mpr_path.html#g1fe179d2b59869522057af90f9d0e28e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g00858c33bad20e8a653f74078fcc4a6e">mprSamePathCount</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path1, cchar *path2, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two paths if they are the same for a given length.  <a href="group___mpr_path.html#g00858c33bad20e8a653f74078fcc4a6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e1063b22696a3419f15470bfc8f4d68a">mprSearchForModule</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *module, char **path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a module on the current module path.  <a href="#e1063b22696a3419f15470bfc8f4d68a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g158aef4d8a9c0162832198421198f6e8">mprSearchPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, int flags, cchar *search,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a path.  <a href="group___mpr_path.html#g158aef4d8a9c0162832198421198f6e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g6510f5de249f68beee6bbbe880549793">mprSeek</a> (MprFile *file, int seekType, long distance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek the I/O pointer to a new location in the file.  <a href="group___mpr_file.html#g6510f5de249f68beee6bbbe880549793"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#gd10813ca9e8ff44df3a8116171d44246">mprServiceEvents</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int delay, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Service events.  <a href="group___mpr_event.html#gd10813ca9e8ff44df3a8116171d44246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#468c8ed0890483fb12b7630afcfc72d5">mprSetAllocCallback</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a> cback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a notifier callback.  <a href="#468c8ed0890483fb12b7630afcfc72d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5afb03370eb13fda6f023dc6d928b477">mprSetAllocError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an memory allocation error condition on a memory context.  <a href="#5afb03370eb13fda6f023dc6d928b477"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1aba81525e6f3570db267f1a71c96d1d">mprSetAllocLimits</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint redline, uint maxMemory)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the application memory limits.  <a href="group___mpr_mem.html#g1aba81525e6f3570db267f1a71c96d1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#7e77eb84ba0cafd84b73bcc10a95376e">mprSetAppName</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, cchar *title, cchar *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the application name, title and version.  <a href="#7e77eb84ba0cafd84b73bcc10a95376e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gea06aa1b68fc99c1038e07066136fee3">mprSetBufMax</a> (MprBuf *buf, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum buffer size.  <a href="group___mpr_buf.html#gea06aa1b68fc99c1038e07066136fee3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g7f74f8c3d5af9db8c064b365f39cae2c">mprSetBufRefillProc</a> (MprBuf *buf, <a class="el" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7">MprBufProc</a> fn, void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffer refill procedure.  <a href="group___mpr_buf.html#g7f74f8c3d5af9db8c064b365f39cae2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#gb66fa4b1cc3c02e8808811b027d54898">mprSetBufSize</a> (MprBuf *buf, int size, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffer size.  <a href="group___mpr_buf.html#gb66fa4b1cc3c02e8808811b027d54898"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g8288e08dc7387c14e0536d214eba6049">mprSetCmdCallback</a> (MprCmd *cmd, MprCmdProc callback, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a callback to be invoked to receive response data from the command.  <a href="group___mpr_cmd.html#g8288e08dc7387c14e0536d214eba6049"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#ga0e753a2136410b79e480713aaf97b89">mprSetCmdDir</a> (MprCmd *cmd, cchar *dir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the home directory for the command.  <a href="group___mpr_cmd.html#ga0e753a2136410b79e480713aaf97b89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g731bf3b3b53862f42249d5a771107363">mprSetCmdEnv</a> (MprCmd *cmd, cchar **env)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the command environment.  <a href="group___mpr_cmd.html#g731bf3b3b53862f42249d5a771107363"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#ga809ed728aec623d30af5c895d3bd5c3">mprSetCurrentThreadPriority</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the thread priroity for the current thread.  <a href="group___mpr_thread.html#ga809ed728aec623d30af5c895d3bd5c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#a0451f6be62ac9d8c4c9d57df6a4acfb">mprSetDebugMode</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, bool on)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn on debug mode.  <a href="#a0451f6be62ac9d8c4c9d57df6a4acfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gdeb570e7b9f2ee67eef01e574baaecb4">mprSetDestructor</a> (void *ptr, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the destructor for a block of memory.  <a href="group___mpr_mem.html#gdeb570e7b9f2ee67eef01e574baaecb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g20dffb6f04ddb568db844dd1a83025f7">mprSetItem</a> (MprList *list, int index, cvoid *item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a list item.  <a href="group___mpr_list.html#g20dffb6f04ddb568db844dd1a83025f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g38bd862a8bc3076d86b0185d5bd81aa6">mprSetListLimits</a> (MprList *list, int initialSize, int maxSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the list size limits.  <a href="group___mpr_list.html#g38bd862a8bc3076d86b0185d5bd81aa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#gb2ac022607500626163a8c3bb997c5c8">mprSetLogHandler</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689">MprLogHandler</a> handler, void *handlerData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an MPR debug log handler.  <a href="group___mpr_log.html#gb2ac022607500626163a8c3bb997c5c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g303a698e00e918f656e35e450f0ec7eb">mprSetLogLevel</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current logging level.  <a href="group___mpr_log.html#g303a698e00e918f656e35e450f0ec7eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#c6a350c9fbbcd569b8c265b9c65845cd">mprSetMaxSocketClients</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum number of client sockets that are permissable.  <a href="#c6a350c9fbbcd569b8c265b9c65845cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_worker_service.html#gdb937865f624afea0be874b043260672">mprSetMaxWorkers</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum count of worker threads Set the maximum number of worker pool threads for the MPR.  <a href="group___mpr_worker_service.html#gdb937865f624afea0be874b043260672"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_worker_service.html#g2c7a32b885496896b69c928c7f08ffe7">mprSetMinWorkers</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the minimum count of worker threads Set the count of threads the worker pool will have.  <a href="group___mpr_worker_service.html#g2c7a32b885496896b69c928c7f08ffe7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g166fe35db17d76f46a260c4ecf72c438">mprSetModuleSearchPath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, char *searchPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the module search path.  <a href="group___mpr_module.html#g166fe35db17d76f46a260c4ecf72c438"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#ge2baa591f0466c9c64f0cf0147ada904">mprSetSocketBlockingMode</a> (MprSocket *sp, bool on)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the socket blocking mode.  <a href="group___mpr_socket.html#ge2baa591f0466c9c64f0cf0147ada904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#27866b4c10d6e45ffd96604b221cf314">mprSetSocketEof</a> (MprSocket *sp, bool eof)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an EOF condition on the socket.  <a href="#27866b4c10d6e45ffd96604b221cf314"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g51594bafaa2003511990ffd804189a31">mprSetSocketNoDelay</a> (MprSocket *sp, bool on)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the socket delay mode.  <a href="group___mpr_socket.html#g51594bafaa2003511990ffd804189a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#g60bd7071428f6043d834c48ee8914560">mprSetThreadPriority</a> (MprThread *thread, int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the thread priroity.  <a href="group___mpr_thread.html#g60bd7071428f6043d834c48ee8914560"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#33ba4772eb9d6ea4725f2c3bec6947f8">mprSetWorkerStackSize</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default worker stack size.  <a href="#33ba4772eb9d6ea4725f2c3bec6947f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b">mprSignalCond</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a condition lock variable.  <a href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#gf86c5f0e03d6476670810091ba6a8d3c">mprSignalExit</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal the MPR to exit gracefully.  <a href="group___mpr.html#gf86c5f0e03d6476670810091ba6a8d3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_list.html#g50c9e84e551dffe01dfe6a2697464f5d">mprSortList</a> (MprList *list, <a class="el" href="group___mpr_list.html#ga4064169552596b7923bc734da239f96">MprListCompareProc</a> compare)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort a list.  <a href="group___mpr_list.html#g50c9e84e551dffe01dfe6a2697464f5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795">mprSpinLock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a spinlock.  <a href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e">mprSpinUnlock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a spinlock.  <a href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#6cedd059c2f7ea313fbf7bc136ab2909">mprSprintf</a> (char *buf, int maxSize, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a string into a statically allocated buffer.  <a href="#6cedd059c2f7ea313fbf7bc136ab2909"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#efdcc565b19075801a65604d388715d0">mprStackCheck</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Monitory stack usage and check if the stack has grown since last monitoring.  <a href="#efdcc565b19075801a65604d388715d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#721856d6348713ef443f924013c42349">mprStart</a> (Mpr *mpr, int startEventsThread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the Mpr services.  <a href="#721856d6348713ef443f924013c42349"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g63558463aa20f047dbd03cae5b6dab7b">mprStartCmd</a> (MprCmd *cmd, int argc, char **argv, char **envp, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the command.  <a href="group___mpr_cmd.html#g63558463aa20f047dbd03cae5b6dab7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_thread.html#g35c53df918c2f52e2e1f6961e35ee8d1">mprStartThread</a> (MprThread *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a thread.  <a href="group___mpr_thread.html#g35c53df918c2f52e2e1f6961e35ee8d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#da0a427a03ab3475fb0faab39d3f5459">mprStartWorker</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99">MprWorkerProc</a> proc, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a worker thread.  <a href="#da0a427a03ab3475fb0faab39d3f5459"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g0c03cfaa89967bee56ef3eebb36b4713">mprStaticAssert</a> (cchar *loc, cchar *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output an assertion failed message.  <a href="group___mpr_log.html#g0c03cfaa89967bee56ef3eebb36b4713"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g4d8c3a25cdbb3771266ee265a46156dd">mprStaticError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a message to the diagnostic log file without allocating any memory.  <a href="group___mpr_log.html#g4d8c3a25cdbb3771266ee265a46156dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#4d6edb96beee6c995edc3197556536f5">mprStaticPrintf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a message to the applications standard output without allocating memory.  <a href="#4d6edb96beee6c995edc3197556536f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ba7d5ea137f728040a397b62bb308455">mprStaticPrintfError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a message to the standard error channel without allocating memory.  <a href="#ba7d5ea137f728040a397b62bb308455"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#0174635f1fe63aac33da9554b476c3f2">mprStealBlock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cvoid *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reassign a block from its current parent context to a new context.  <a href="#0174635f1fe63aac33da9554b476c3f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_buf.html#g5800cbdbb6bac03b54fba8af893603b0">mprStealBuf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, MprBuf *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Steal the buffer memory from a buffer.  <a href="group___mpr_buf.html#g5800cbdbb6bac03b54fba8af893603b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f3f765dac52a91c673b6ff9f5d24da68">mprStop</a> (Mpr *mpr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the MPR and shutdown all services.  <a href="#f3f765dac52a91c673b6ff9f5d24da68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g73dbe983174ac25e4af6a1fea4d8f966">mprStopCmd</a> (MprCmd *cmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the command.  <a href="group___mpr_cmd.html#g73dbe983174ac25e4af6a1fea4d8f966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_event.html#g1f2c85a20242ec0c1e4830ccd25c7bb7">mprStopContinuousEvent</a> (MprEvent *event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop an event.  <a href="group___mpr_event.html#g1f2c85a20242ec0c1e4830ccd25c7bb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d3156f9075164b2fee835a66f62eb4aa">mprStrcat</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int max, cchar *src,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Catenate strings.  <a href="#d3156f9075164b2fee835a66f62eb4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#937b35fb3e4a7cdac84e1c6985db6cc8">mprStrcmp</a> (cchar *str1, cchar *str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare strings.  <a href="#937b35fb3e4a7cdac84e1c6985db6cc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#e15c6b644b07a706125e13656d3be03b">mprStrcmpAnyCase</a> (cchar *str1, cchar *str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare strings ignoring case.  <a href="#e15c6b644b07a706125e13656d3be03b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#12ece4a3c6060f5c09051b17212f14f8">mprStrcmpAnyCaseCount</a> (cchar *str1, cchar *str2, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare strings ignoring case.  <a href="#12ece4a3c6060f5c09051b17212f14f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#239b2debb47dd4553372d0ad89294521">mprStrcpy</a> (char *dest, int destMax, cchar *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a string.  <a href="#239b2debb47dd4553372d0ad89294521"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#af8ce98847bb93316ca5f0c0ca9fcb67">mprStrcpyCount</a> (char *dest, int destMax, cchar *src, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy characters from a string.  <a href="#af8ce98847bb93316ca5f0c0ca9fcb67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86">mprStrdup</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe replacement for strdup.  <a href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d672f4f5cd20ea78325864b263460133">mprStrlen</a> (cchar *src, int max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of a string.  <a href="#d672f4f5cd20ea78325864b263460133"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#b9c7e8c93945fa0bc4aa3608ea2b9802">mprStrLower</a> (char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a string to lower case.  <a href="#b9c7e8c93945fa0bc4aa3608ea2b9802"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g857ed05b61f4112d319fe75545d0a081">mprStrndup</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *str, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a string.  <a href="group___mpr_mem.html#g857ed05b61f4112d319fe75545d0a081"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#3707c7892d469df5810a249fa1a51a69">mprStrnstr</a> (cchar *str, cchar *pattern, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a substring.  <a href="#3707c7892d469df5810a249fa1a51a69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#607579dc34bc84ebea2b67d7f9d55641">mprStrTok</a> (char *str, cchar *delim, char **last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tokenize a string.  <a href="#607579dc34bc84ebea2b67d7f9d55641"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#cab0129f8454deb9debf1513ddf15738">mprStrTrim</a> (char *str, cchar *set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim a string.  <a href="#cab0129f8454deb9debf1513ddf15738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f746a3a94464da0f6991d88d3d76ae75">mprStrUpper</a> (char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a string to upper case.  <a href="#f746a3a94464da0f6991d88d3d76ae75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr.html#gedafb2bdaadd9bccf0938e8e6e31f539">mprTerminate</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, bool graceful)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate the MPR.  <a href="group___mpr.html#gedafb2bdaadd9bccf0938e8e6e31f539"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#gb8e93fa1d44e924d6bb6845c86d5607d">mprTrimPathExtension</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim an extension from a path.  <a href="group___mpr_path.html#gb8e93fa1d44e924d6bb6845c86d5607d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_path.html#g5d652358240a8e968114cfa718b420ab">mprTruncatePath</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *path, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncate a path.  <a href="group___mpr_path.html#g5d652358240a8e968114cfa718b420ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d">mprTryLock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock access.  <a href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gc257b932fcc7140852e6830640d2301b">mprTrySpinLock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock access on a spin lock.  <a href="group___mpr_synch.html#gc257b932fcc7140852e6830640d2301b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_module.html#g7850e66f8a93866bbf3c149a65f33172">mprUnloadModule</a> (MprModule *mp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unload a module.  <a href="group___mpr_module.html#g7850e66f8a93866bbf3c149a65f33172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad">mprUnlock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#64b669a1f52e62b8010fe14094db885b">mprUpdateWaitHandler</a> (MprWaitHandler *wp, bool wakeup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply wait handler updates.  <a href="#64b669a1f52e62b8010fe14094db885b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#42505a60e5679606bc22d8c1aa1dc4ba">mprUriDecode</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a URI string by de-scaping URI characters.  <a href="#42505a60e5679606bc22d8c1aa1dc4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ff8a0ff793cc8e580ace3501d6949173">mprUriEncode</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *uri, int map)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode a string by escaping URI characters.  <a href="#ff8a0ff793cc8e580ace3501d6949173"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_log.html#g0b7873bee991ee0160420868906eeb8c">mprUserError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display an error message to the user.  <a href="group___mpr_log.html#g0b7873bee991ee0160420868906eeb8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#d5c8927e1a2c78d302726c41cd6da6cd">mprValidateBlock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validate a memory block and issue asserts if the memory block or any children blocks do not validate.  <a href="#d5c8927e1a2c78d302726c41cd6da6cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#bd8e3ce747235f08bf1fca492a653f9b">mprVasprintf</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int maxSize, cchar *fmt, va_list arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a buffer of sufficient length to hold the formatted string.  <a href="#bd8e3ce747235f08bf1fca492a653f9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#5bba3c0b15d48ec6cc90966f14ae663a">mprVsprintf</a> (char *buf, int maxSize, cchar *fmt, va_list args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a string into a statically allocated buffer.  <a href="#5bba3c0b15d48ec6cc90966f14ae663a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#g86f4815eb5e4cdd4695ecfd17f8eb360">mprWaitForCmd</a> (MprCmd *cmd, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the command to complete.  <a href="group___mpr_cmd.html#g86f4815eb5e4cdd4695ecfd17f8eb360"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5">mprWaitForCond</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a condition lock variable.  <a href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g4ce11896445416406d85d4d7a18bac7e">mprWaitForCondWithService</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a condition lock variable and pump events while waiting.  <a href="group___mpr_synch.html#g4ce11896445416406d85d4d7a18bac7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#aabd29f554c4fa6b528f5c9587a7adb4">mprWaitForIO</a> (MprWaitService *ws, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for I/O.  <a href="#aabd29f554c4fa6b528f5c9587a7adb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#f1b9807f41341d92c190f8ae71390e78">mprWaitForSingleIO</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int fd, int mask, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for I/O on a file descriptor.  <a href="#f1b9807f41341d92c190f8ae71390e78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpr_8h.html#ffed14ffe657703bf2577f91e424d6f6">mprWakeDispatcherService</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wakeup the dispatcher.  <a href="#ffed14ffe657703bf2577f91e424d6f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g1ccf3d98a34232049c0e97384fca88c3">mprWrite</a> (MprFile *file, cvoid *buf, uint count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a file.  <a href="group___mpr_file.html#g1ccf3d98a34232049c0e97384fca88c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_cmd.html#gc69adc9b03e41150d6d79512c0895c12">mprWriteCmdPipe</a> (MprCmd *cmd, int channel, char *buf, int bufsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to an I/O channel.  <a href="group___mpr_cmd.html#gc69adc9b03e41150d6d79512c0895c12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g7acf925a7a7f34a50f45e72e34ccc2c7">mprWriteFormat</a> (MprFile *file, cchar *fmt,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write formatted data to a file.  <a href="group___mpr_file.html#g7acf925a7a7f34a50f45e72e34ccc2c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#gbd2ae7ff08fb05f45d78f728a3af93a1">mprWriteSocket</a> (MprSocket *sp, void *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a socket.  <a href="group___mpr_socket.html#gbd2ae7ff08fb05f45d78f728a3af93a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#gbf3c8418ff828a0301005b26ae06df92">mprWriteSocketString</a> (MprSocket *sp, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a string to a socket.  <a href="group___mpr_socket.html#gbf3c8418ff828a0301005b26ae06df92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_socket.html#g50a28b5aac234b66ad03d0e3a8e38038">mprWriteSocketVector</a> (MprSocket *sp, MprIOVec *iovec, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a vector to a socket.  <a href="group___mpr_socket.html#g50a28b5aac234b66ad03d0e3a8e38038"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_file.html#g3874c994f9f5b1c4c4fd57100a656148">mprWriteString</a> (MprFile *file, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a string to a file.  <a href="group___mpr_file.html#g3874c994f9f5b1c4c4fd57100a656148"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Multithreaded Portable Runtime (MPR) is a portable runtime core for embedded applications. 
<p>
The MPR provides management for logging, error handling, events, files, http, memory, ssl, sockets, strings, xml parsing, and date/time functions. It also provides a foundation of safe routines for secure programming, that help to prevent buffer overflows and other security threats. It is correctly handles null arguments without crashing. The MPR is a library and a C API that can be used in both C and C++ programs. <br>
<br>
 The MPR uses by convention a set extended typedefs for common types. These include: bool, cchar, cvoid, uchar, short, ushort, int, uint, long, ulong, int64, uint64, float, and double. The cchar type is a const char, cvoid is const void, and several types have "u" prefixes to denote unsigned qualifiers. <br>
<br>
 The MPR includes a memory manager to minimize memory leaks and maximize allocation efficiency. It utilizes a heap and slab allocators with tree links. All memory allocated is connected to a parent memory block thus forming a tree. When any block is freed, all child blocks are also freed. Most MPR APIs take a memory parent context as the first parameter. <br>
<br>
 Many of these APIs are not thread-safe. If utilizing multithreaded programming on a supporting operating system, be careful if you modify or delete the underlying data while accessing the resource from another thread. <hr><h2>Define Documentation</h2>
<a class="anchor" name="9f0e4f45ab378cf38c97d1f82ae97977"></a><!-- doxytag: member="mpr.h::MPR_ERR_OK" ref="9f0e4f45ab378cf38c97d1f82ae97977" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPR_ERR_OK&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard MPR return and error codes. 
<p>
Success 
</div>
</div><p>
<a class="anchor" name="b58f968604e9f630b90bd20b66f9fc6b"></a><!-- doxytag: member="mpr.h::MPR_ERROR" ref="b58f968604e9f630b90bd20b66f9fc6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPR_ERROR&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard logging trace levels are 0 to 9 with 0 being the most verbose. 
<p>
These are ored with the error source and type flags. The MPR_LOG_MASK is used to extract the trace level from a flags word. We expect most apps to run with level 2 trace enabled. 
</div>
</div><p>
<a class="anchor" name="4b31c87cc1ce41278fae6a17c23e3199"></a><!-- doxytag: member="mpr.h::MPR_MAX_URL" ref="4b31c87cc1ce41278fae6a17c23e3199" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPR_MAX_URL&nbsp;&nbsp;&nbsp;512          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Max URL size. 
<p>
Also request URL size. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="1d9d70fd98eb69a8c870f2202bee22eb"></a><!-- doxytag: member="mpr.h::MprModuleProc" ref="1d9d70fd98eb69a8c870f2202bee22eb" args=")(struct MprModule *mp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb">MprModuleProc</a>)(struct MprModule *mp)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Module start/stop point function signature. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mp</em>&nbsp;</td><td>Module object reference returned from <a class="el" href="group___mpr_module.html#g63bd240ada3d4cb53ead7b4404fd5014" title="Create a module.">mprCreateModule</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>zero if successful, otherwise return a negative MPR error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86674106f5fcb47ba730f66375407e0a"></a><!-- doxytag: member="mpr.h::MprSocketProc" ref="86674106f5fcb47ba730f66375407e0a" args=")(void *data, int mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="mpr_8h.html#86674106f5fcb47ba730f66375407e0a">MprSocketProc</a>)(void *data, int mask)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket I/O callback procedure. 
<p>
Proc returns non-zero if the socket has been deleted. 
</div>
</div><p>
<a class="anchor" name="1c2789aea11b60b13644c3b4e7c54f99"></a><!-- doxytag: member="mpr.h::MprWorkerProc" ref="1c2789aea11b60b13644c3b4e7c54f99" args=")(void *data, struct MprWorker *worker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99">MprWorkerProc</a>)(void *data, struct MprWorker *worker)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Worker thread callback signature. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>worker callback data. Set via mprStartWorker or mprActivateWorker </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Reference to the worker thread object </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8e5dff8e25775b63954faa81e54c7f82"></a><!-- doxytag: member="mpr.h::mprAcceptSocket" ref="8e5dff8e25775b63954faa81e54c7f82" args="(MprSocket *listen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprSocket* mprAcceptSocket           </td>
          <td>(</td>
          <td class="paramtype">MprSocket *&nbsp;</td>
          <td class="paramname"> <em>listen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept an incoming connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listen</em>&nbsp;</td><td>Listening server socket </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new socket connection </dd></dl>

</div>
</div><p>
<a class="anchor" name="47b6a089018e38316476e97b49bb8d82"></a><!-- doxytag: member="mpr.h::mprAsprintf" ref="47b6a089018e38316476e97b49bb8d82" args="(MprCtx ctx, int maxSize, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprAsprintf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a string into an allocated buffer. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call will dynamically allocate a buffer up to the specified maximum size and will format the supplied arguments into the buffer. A trailing null will always be appended. The call returns the size of the allocated string excluding the null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>Maximum size to allocate for the buffer including the trailing null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2b1ebf1965beac947ab9b77970f49c5"></a><!-- doxytag: member="mpr.h::mprAtoi" ref="b2b1ebf1965beac947ab9b77970f49c5" args="(cchar *str, int radix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 mprAtoi           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a string to an integer. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call converts the supplied string to an integer using the specified radix (base). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to the string to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radix</em>&nbsp;</td><td>Base to use when parsing the string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the integer equivalent value of the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="087ffc47d75b5f88dbfcabb8c3cd2d21"></a><!-- doxytag: member="mpr.h::mprCompareTime" ref="087ffc47d75b5f88dbfcabb8c3cd2d21" args="(MprTime t1, MprTime t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprCompareTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two times. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>compare two times and return a code indicating which is greater, less or equal </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>First time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Second time </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if equal, -1 if t1 is less than t2 otherwise one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f3e1db5d7e207edaa4dde272a63c5fa"></a><!-- doxytag: member="mpr.h::mprConfigureSsl" ref="5f3e1db5d7e207edaa4dde272a63c5fa" args="(struct MprSsl *ssl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprConfigureSsl           </td>
          <td>(</td>
          <td class="paramtype">struct MprSsl *&nbsp;</td>
          <td class="paramname"> <em>ssl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure SSL based on the parsed MprSsl configuration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ssl</em>&nbsp;</td><td>MprSsl configuration </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="39e6373ded494a2d3154004e58a53caa"></a><!-- doxytag: member="mpr.h::mprCreateDispatcher" ref="39e6373ded494a2d3154004e58a53caa" args="(MprCtx ctx, cchar *name, int enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprDispatcher* mprCreateDispatcher           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new event dispatcher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Useful name for debugging </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>If true, enable the dispatcher </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a Dispatcher object that can manage events and be used with mprCreateEvent </dd></dl>

</div>
</div><p>
<a class="anchor" name="6161ae2c822d03b9bda53ef7663f14f9"></a><!-- doxytag: member="mpr.h::mprDecode64" ref="6161ae2c822d03b9bda53ef7663f14f9" args="(char *buffer, int bufsize, cchar *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprDecode64           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deocde buffer using base-46 encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Reference to a buffer containing that data to decode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>size of the buffer in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to decode </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if successful, otherwise returns MPR_ERR_WONT_FIT if the buffer is too small. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7fe4c3fb94490eb462405d86f71514d7"></a><!-- doxytag: member="mpr.h::mprDedicateWorker" ref="7fe4c3fb94490eb462405d86f71514d7" args="(MprWorker *worker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprDedicateWorker           </td>
          <td>(</td>
          <td class="paramtype">MprWorker *&nbsp;</td>
          <td class="paramname"> <em>worker</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dedicate a worker thread to a current real thread. 
<p>
This implements thread affinity and is required on some platforms where some APIs (waitpid on uClibc) cannot be called on a different thread. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker thread reference </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f738be140726725efc160324b0d209e8"></a><!-- doxytag: member="mpr.h::mprDedicateWorkerToHandler" ref="f738be140726725efc160324b0d209e8" args="(MprWaitHandler *wp, struct MprWorker *worker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprDedicateWorkerToHandler           </td>
          <td>(</td>
          <td class="paramtype">MprWaitHandler *&nbsp;</td>
          <td class="paramname"> <em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct MprWorker *&nbsp;</td>
          <td class="paramname"> <em>worker</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dedicate a worker thread to a wait handler. 
<p>
This implements thread affinity and is required on some platforms where some APIs (waitpid on uClibc) cannot be called on a different thread. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wp</em>&nbsp;</td><td>Wait handler created via <a class="el" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd" title="Create a wait handler.">mprCreateWaitHandler</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker thread reference </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40585bcce880703910e75ff4599529da"></a><!-- doxytag: member="mpr.h::mprDisableSocketEvents" ref="40585bcce880703910e75ff4599529da" args="(MprSocket *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprDisableSocketEvents           </td>
          <td>(</td>
          <td class="paramtype">MprSocket *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable socket events for a socket callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>Socket object returned from <a class="el" href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9" title="Create a socket.">mprCreateSocket</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5f9301dbcddf9d1a62b40c69bc67fe40"></a><!-- doxytag: member="mpr.h::mprDisconnectSocket" ref="5f9301dbcddf9d1a62b40c69bc67fe40" args="(MprSocket *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprDisconnectSocket           </td>
          <td>(</td>
          <td class="paramtype">MprSocket *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disconnect a socket by closing its underlying file descriptor. 
<p>
This is used to prevent further I/O wait events while still preserving the socket object. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>Socket object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="176d0ea8501110003ec63c0e3ecf24f8"></a><!-- doxytag: member="mpr.h::mprDtoa" ref="176d0ea8501110003ec63c0e3ecf24f8" args="(MprCtx ctx, double value, int ndigits, int mode, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprDtoa           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a double to ascii. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to convert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndigits</em>&nbsp;</td><td>Number of digits to render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Modes are: 0 Shortest string, 1 Like 0, but with Steele &amp; White stopping rule, 2 Return ndigits of result, 3 Number of digits applies after the decimal point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Format flags </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b9239642f6f3418d97c779c410a9aa91"></a><!-- doxytag: member="mpr.h::mprEnableDispatcher" ref="b9239642f6f3418d97c779c410a9aa91" args="(MprDispatcher *dispatcher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprEnableDispatcher           </td>
          <td>(</td>
          <td class="paramtype">MprDispatcher *&nbsp;</td>
          <td class="paramname"> <em>dispatcher</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable a dispatcher to service events. 
<p>
The mprCreateDispatcher routiner creates dispatchers in the disabled state. Use mprEnableDispatcher to enable them to begin servicing events. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dispatcher</em>&nbsp;</td><td>Dispatcher to enable </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a2b9f1eb8ccbe19f2ca1c277e9e714e2"></a><!-- doxytag: member="mpr.h::mprEnableSocketEvents" ref="a2b9f1eb8ccbe19f2ca1c277e9e714e2" args="(MprSocket *sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprEnableSocketEvents           </td>
          <td>(</td>
          <td class="paramtype">MprSocket *&nbsp;</td>
          <td class="paramname"> <em>sp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable socket events for a socket callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>Socket object returned from <a class="el" href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9" title="Create a socket.">mprCreateSocket</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e57602feb972619422110f9fbd0d8341"></a><!-- doxytag: member="mpr.h::mprEncode64" ref="e57602feb972619422110f9fbd0d8341" args="(char *buffer, int bufsize, cchar *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprEncode64           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode buffer using base-46 encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Reference to a buffer that will contain the encoded data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>size of the buffer in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to encode </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if successful, otherwise returns MPR_ERR_WONT_FIT if the buffer is too small. </dd></dl>

</div>
</div><p>
<a class="anchor" name="43b32087d8a020c9fc1ed976a8e4371d"></a><!-- doxytag: member="mpr.h::mprEscapeCmd" ref="43b32087d8a020c9fc1ed976a8e4371d" args="(MprCtx ctx, cchar *cmd, int escChar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprEscapeCmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>escChar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode a string escaping typical command (shell) characters. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Encode a string escaping all dangerous characters that have meaning for the unix or MS-DOS command shells. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>Command string to encode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>escChar</em>&nbsp;</td><td>Escape character to use when encoding the command. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated string containing the escaped command. Caller must free using <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f15488d5680bfabf4f243c863d98314"></a><!-- doxytag: member="mpr.h::mprEscapeHtml" ref="4f15488d5680bfabf4f243c863d98314" args="(MprCtx ctx, cchar *html)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprEscapeHtml           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>html</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode a string by escaping typical HTML characters. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Encode a string escaping all dangerous characters that have meaning in HTML documents </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>html</em>&nbsp;</td><td>HTML content to encode </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated string containing the escaped HTML. Caller must free using <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07783ffc93b6fd136de7b927ccceed19"></a><!-- doxytag: member="mpr.h::mprFprintf" ref="07783ffc93b6fd136de7b927ccceed19" args="(struct MprFile *file, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprFprintf           </td>
          <td>(</td>
          <td class="paramtype">struct MprFile *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a formatted message to a file descriptor. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This is a replacement for fprintf as part of the safe string MPR library. It minimizes memory use and uses a file descriptor instead of a File pointer. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>MprFile object returned via mprOpen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes written </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d03816923ffb4392c095869ac37d0c0"></a><!-- doxytag: member="mpr.h::mprFreeChildren" ref="1d03816923ffb4392c095869ac37d0c0" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprFreeChildren           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free all the children blocks allocated of a block. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c1c737cca87de821e71f45c89b965365"></a><!-- doxytag: member="mpr.h::mprGetAllocStats" ref="c1c737cca87de821e71f45c89b965365" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprAlloc* mprGetAllocStats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current allocation memory statistics block. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to the allocation memory statistics. Do not modify its contents. </dd></dl>

</div>
</div><p>
<a class="anchor" name="de408e459ab57104df4b4c1376d3ff22"></a><!-- doxytag: member="mpr.h::mprGetAppDir" ref="de408e459ab57104df4b4c1376d3ff22" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprGetAppDir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the application directory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Get the directory containing the application executable. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing the application directory. Caller must free. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee21b01fdc7627c3511f24c98252a706"></a><!-- doxytag: member="mpr.h::mprGetAppName" ref="ee21b01fdc7627c3511f24c98252a706" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cchar* mprGetAppName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the application name defined via mprSetAppName. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the one-word lower case application name defined via mprSetAppName </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4545c6b9e0fc0e129525b3a7c3f41f5"></a><!-- doxytag: member="mpr.h::mprGetAppPath" ref="b4545c6b9e0fc0e129525b3a7c3f41f5" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprGetAppPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the application executable path. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing the application executable path. Caller must free </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b5d0f5ed666f1ec48caaf65a9304acb"></a><!-- doxytag: member="mpr.h::mprGetCurrentPath" ref="8b5d0f5ed666f1ec48caaf65a9304acb" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprGetCurrentPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current working directory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns an allocated string with the current working directory as an absolute path. </dd></dl>

</div>
</div><p>
<a class="anchor" name="09693a2d0138d474b5825bdc4d742fcc"></a><!-- doxytag: member="mpr.h::mprGetCurrentThreadName" ref="09693a2d0138d474b5825bdc4d742fcc" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cchar* mprGetCurrentThreadName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the name of the current thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a static thread name. Caller must not free </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3492a2cff32689b04b0989a834d7bca"></a><!-- doxytag: member="mpr.h::mprGetDispatcher" ref="a3492a2cff32689b04b0989a834d7bca" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprDispatcher* mprGetDispatcher           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the MPR primary dispatcher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the MPR dispatcher object </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebad4782acd4f2cd541ce68737f98471"></a><!-- doxytag: member="mpr.h::mprGetElapsedTime" ref="ebad4782acd4f2cd541ce68737f98471" args="(MprCtx ctx, MprTime mark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a> mprGetElapsedTime           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">MprTime</a>&nbsp;</td>
          <td class="paramname"> <em>mark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the elapsed time since a time mark. 
<p>
Create the time mark with <a class="el" href="group___mpr_date.html#gedc887ffd106e62ff9f4e69044910c92" title="Get the system time.">mprGetTime()</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mark</em>&nbsp;</td><td>Starting time stamp </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time elapsed since the mark was taken. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a047d643f4c0b4f2dc2760aeea3e61c"></a><!-- doxytag: member="mpr.h::mprGetLogLevel" ref="5a047d643f4c0b4f2dc2760aeea3e61c" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprGetLogLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current logging level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current log level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5fff86cf2f5455dba2476c579ca3efb"></a><!-- doxytag: member="mpr.h::mprGetMD5Hash" ref="a5fff86cf2f5455dba2476c579ca3efb" args="(MprCtx ctx, cchar *buf, int len, cchar *prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprGetMD5Hash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an MD5 checksum. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Buffer to checksum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>String prefix to insert at the start of the result </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An MD5 checksum string. Caller must free. </dd></dl>

</div>
</div><p>
<a class="anchor" name="144c637773024a22bbc1be9a257555ef"></a><!-- doxytag: member="mpr.h::mprGetPageSize" ref="144c637773024a22bbc1be9a257555ef" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprGetPageSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current O/S virtual page size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the page size in bytes </dd></dl>

</div>
</div><p>
<a class="anchor" name="7084bfea78dcf720c82e7163b9dbc4da"></a><!-- doxytag: member="mpr.h::mprGetStderr" ref="7084bfea78dcf720c82e7163b9dbc4da" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprFile* mprGetStderr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a file object for the Stderr I/O channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A file object </dd></dl>

</div>
</div><p>
<a class="anchor" name="f260b8f2c8c000a6f4ec1ac7569e8416"></a><!-- doxytag: member="mpr.h::mprGetStdin" ref="f260b8f2c8c000a6f4ec1ac7569e8416" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprFile* mprGetStdin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a file object for the Stdin I/O channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A file object </dd></dl>

</div>
</div><p>
<a class="anchor" name="29ffea058d6f735313ee8a81fd3334dd"></a><!-- doxytag: member="mpr.h::mprGetStdout" ref="29ffea058d6f735313ee8a81fd3334dd" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprFile* mprGetStdout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a file object for the Stdout I/O channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A file object </dd></dl>

</div>
</div><p>
<a class="anchor" name="a071656602927b54f839595f162336a9"></a><!-- doxytag: member="mpr.h::mprGetUsedMemory" ref="a071656602927b54f839595f162336a9" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 mprGetUsedMemory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the amount of memory currently used by the application. 
<p>
This only reports heap memory. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the amount of heap memory used by the application in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="38c5795e4d552281fbf168b679d89704"></a><!-- doxytag: member="mpr.h::mprGetWordTok" ref="38c5795e4d552281fbf168b679d89704" args="(char *buf, int bufsize, cchar *str, cchar *delim, cchar **tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprGetWordTok           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar **&nbsp;</td>
          <td class="paramname"> <em>tok</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the next word token. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Split a string into word tokens using the supplied separator. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Buffer to use to hold the word token </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>Size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Input string to tokenize. Note this cannot be a const string. It will be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>String of separator characters to use when tokenizing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tok</em>&nbsp;</td><td>Pointer to a word to hold a pointer to the next token in the original string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes in the allocated block. </dd></dl>

</div>
</div><p>
<a class="anchor" name="634f21ee23b89c3612785f8a59d27103"></a><!-- doxytag: member="mpr.h::mprHasSecureSockets" ref="634f21ee23b89c3612785f8a59d27103" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mprHasSecureSockets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if SSL is available. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if SSL is available </dd></dl>

</div>
</div><p>
<a class="anchor" name="b136a423c6fa64f6b9c3b05576ed07ba"></a><!-- doxytag: member="mpr.h::mprInitBlock" ref="b136a423c6fa64f6b9c3b05576ed07ba" args="(void *ptr, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprInitBlock           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call initializes a static block of memory so it can be used as a memory context for subseqent allocations. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to the memory block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory block </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="eb1d9013dbfca5d9080b881e0fde2cde"></a><!-- doxytag: member="mpr.h::mprIsValid" ref="eb1d9013dbfca5d9080b881e0fde2cde" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprIsValid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test is a pointer is a valid memory context. 
<p>
This is used to test if a block has been dynamically allocated. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c44ccf179c55dbbcf7aa04ba86090463"></a><!-- doxytag: member="mpr.h::mprItoa" ref="c44ccf179c55dbbcf7aa04ba86090463" args="(char *buf, int size, int64 value, int radix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprItoa           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert an integer to a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call converts the supplied integer into a string formatted into the supplied buffer. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the buffer that will hold the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Integer value to convert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radix</em>&nbsp;</td><td>The base radix to use when encoding the number </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f73646ba41280e4da88fd7ff89bd383"></a><!-- doxytag: member="mpr.h::mprLoadSsl" ref="7f73646ba41280e4da88fd7ff89bd383" args="(MprCtx ctx, bool lazy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprModule* mprLoadSsl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lazy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load the SSL module. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lazy</em>&nbsp;</td><td>Set to true to delay initialization until SSL is actually used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92480f400bf2488c4901993123df7de6"></a><!-- doxytag: member="mpr.h::mprLookupMimeType" ref="92480f400bf2488c4901993123df7de6" args="(MprCtx ctx, cchar *ext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cchar* mprLookupMimeType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>ext</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mime type for an extension. 
<p>
This call will return the mime type from a limited internal set of mime types for the given path or extension. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext</em>&nbsp;</td><td>Path or extension to examine </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Mime type. This is a static string. Caller must not free. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d8444f927dac1b01ccb48450c2cb0d1"></a><!-- doxytag: member="mpr.h::mprMapAlloc" ref="6d8444f927dac1b01ccb48450c2cb0d1" args="(uint size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprMapAlloc           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory virtual memory into the applications address space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>of virtual memory to map. This size will be rounded up to the nearest page boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Mask set to MPR_MAP_READ | MPR_MAP_WRITE </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c5d14b85515f1d8155856285e50611f"></a><!-- doxytag: member="mpr.h::mprMapFree" ref="2c5d14b85515f1d8155856285e50611f" args="(void *ptr, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprMapFree           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free (unpin) a mapped section of virtual memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Virtual address to free. Should be page aligned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of memory to free in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1775b8543a4e3b0559f0e279bb5e37a6"></a><!-- doxytag: member="mpr.h::mprMemcmp" ref="1775b8543a4e3b0559f0e279bb5e37a6" args="(cvoid *b1, int b1Len, cvoid *b2, int b2Len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprMemcmp           </td>
          <td>(</td>
          <td class="paramtype">cvoid *&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>b1Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cvoid *&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>b2Len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two byte strings. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safely compare two byte strings. This is a safe replacement for memcmp. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b1</em>&nbsp;</td><td>Pointer to the first byte string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b1Len</em>&nbsp;</td><td>Length of the first byte string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b2</em>&nbsp;</td><td>Pointer to the second byte string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b2Len</em>&nbsp;</td><td>Length of the second byte string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the byte strings are identical. Otherwise returns -1 if the first string is less than the second. Returns 1 if the first is greater than the first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcb752b124b706ebff6798cfeafc9f99"></a><!-- doxytag: member="mpr.h::mprMemcpy" ref="bcb752b124b706ebff6798cfeafc9f99" args="(void *dest, int destMax, cvoid *src, int nbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprMemcpy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>destMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cvoid *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safe copy for a block of data. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safely copy a block of data into an existing memory block. The call ensures the destination block is not overflowed and returns the size of the block actually copied. This is similar to memcpy, but is a safer alternative. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to the destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destMax</em>&nbsp;</td><td>Maximum size of the destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Block to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Size of the source block </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the allocated block. </dd></dl>

</div>
</div><p>
<a class="anchor" name="978aa9d1ee3d0fe7b50e566f3d471ed3"></a><!-- doxytag: member="mpr.h::mprParseIp" ref="978aa9d1ee3d0fe7b50e566f3d471ed3" args="(MprCtx ctx, cchar *ipSpec, char **ip, int *port, int defaultPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprParseIp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>ipSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>defaultPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an IP address. 
<p>
This parses a string containing an IP:PORT specification and returns the IP address and port components. Handles ipv4 and ipv6 addresses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ipSpec</em>&nbsp;</td><td>An IP:PORT specification. The :PORT is optional. When an IP address contains an ipv6 port it should be written as aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh:iiii or [aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh:iiii]:port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ip</em>&nbsp;</td><td>Pointer to receive a dynamically allocated IP string. Caller should free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Pointer to an integer to receive the port value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>defaultPort</em>&nbsp;</td><td>The default port number to use if the ipSpec does not contain a port </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3413b2b0b86894f0ca40efa0f7156bea"></a><!-- doxytag: member="mpr.h::mprPrintAllocReport" ref="3413b2b0b86894f0ca40efa0f7156bea" args="(MprCtx ctx, cchar *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprPrintAllocReport           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a memory usage report to stdout. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>New memory context for the block. Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Prefix message to the report </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dfbd1fa43e7b737e566661e5d6ab6c36"></a><!-- doxytag: member="mpr.h::mprPrintf" ref="dfbd1fa43e7b737e566661e5d6ab6c36" args="(MprCtx ctx, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprPrintf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Formatted print. 
<p>
This is a secure verion of printf that can handle null args. <dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This is a secure replacement for printf. It can handle null arguments without crashes. minimal footprint. The MPR can be build without using any printf routines. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes written </dd></dl>

</div>
</div><p>
<a class="anchor" name="13f99df19731bdfca83cd7ab64b6dd90"></a><!-- doxytag: member="mpr.h::mprPrintfError" ref="13f99df19731bdfca83cd7ab64b6dd90" args="(MprCtx ctx, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprPrintfError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a formatted message to the standard error channel. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This is a secure replacement for fprintf(stderr. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes written </dd></dl>

</div>
</div><p>
<a class="anchor" name="52f88939c5c03270beff007574b4aeb0"></a><!-- doxytag: member="mpr.h::mprQueueIOEvent" ref="52f88939c5c03270beff007574b4aeb0" args="(MprWaitHandler *wp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprQueueIOEvent           </td>
          <td>(</td>
          <td class="paramtype">MprWaitHandler *&nbsp;</td>
          <td class="paramname"> <em>wp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queue an IO event for dispatch on the wait handler dispatcher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wp</em>&nbsp;</td><td>Wait handler created via <a class="el" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd" title="Create a wait handler.">mprCreateWaitHandler</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2493bcee3c3b7f8351e16c731dd401f6"></a><!-- doxytag: member="mpr.h::mprReallocStrcat" ref="2493bcee3c3b7f8351e16c731dd401f6" args="(MprCtx ctx, int max, char *buf, cchar *src,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprReallocStrcat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append strings to an existing string and reallocate as required. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Append a list of strings to an existing string. The list of strings is terminated by a null argument. The call returns the size of the allocated block. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>Maximum size of the result string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Existing string to reallocate. May be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Variable list of strings to append. The final string argument must be null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated result string. Caller must free. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dae3b874e39e0d5e0155d5179f1d83cc"></a><!-- doxytag: member="mpr.h::mprReleaseWorker" ref="dae3b874e39e0d5e0155d5179f1d83cc" args="(MprWorker *worker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprReleaseWorker           </td>
          <td>(</td>
          <td class="paramtype">MprWorker *&nbsp;</td>
          <td class="paramname"> <em>worker</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a worker thread. 
<p>
This releases a worker thread to be assignable to any real thread. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker thread reference </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e0e96f55e5ae3bd167e1b51f563e580d"></a><!-- doxytag: member="mpr.h::mprReleaseWorkerFromHandler" ref="e0e96f55e5ae3bd167e1b51f563e580d" args="(MprWaitHandler *wp, struct MprWorker *worker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprReleaseWorkerFromHandler           </td>
          <td>(</td>
          <td class="paramtype">MprWaitHandler *&nbsp;</td>
          <td class="paramname"> <em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct MprWorker *&nbsp;</td>
          <td class="paramname"> <em>worker</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a worker thread. 
<p>
This releases a worker thread to be assignable to any other wait handler. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wp</em>&nbsp;</td><td>Wait handler created via <a class="el" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd" title="Create a wait handler.">mprCreateWaitHandler</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worker</em>&nbsp;</td><td>Worker thread reference </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a7e94f04dd2634590ebf35d099bc3c63"></a><!-- doxytag: member="mpr.h::mprRemoveWaitHandler" ref="a7e94f04dd2634590ebf35d099bc3c63" args="(MprWaitHandler *wp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprRemoveWaitHandler           </td>
          <td>(</td>
          <td class="paramtype">MprWaitHandler *&nbsp;</td>
          <td class="paramname"> <em>wp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disconnect a wait handler from its underlying file descriptor. 
<p>
This is used to prevent further I/O wait events while still preserving the wait handler. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wp</em>&nbsp;</td><td>Wait handler object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1f9db7dccdae9651f616f3e0740d6c81"></a><!-- doxytag: member="mpr.h::mprReparent" ref="1f9db7dccdae9651f616f3e0740d6c81" args="(MprCtx ctx, cvoid *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprReparent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cvoid *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reparent a block. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Moves a block from one memory context to another within a single memory heap or arena. This call is fast and is not thread-safe. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>New memory context for the block. Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to memory block. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3db47bdecb58c2c52197d625377cf71b"></a><!-- doxytag: member="mpr.h::mprResetCond" ref="3db47bdecb58c2c52197d625377cf71b" args="(MprCond *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprResetCond           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset a condition variable. 
<p>
This sets the condition variable to the unsignalled condition. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Condition variable object created via <a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1063b22696a3419f15470bfc8f4d68a"></a><!-- doxytag: member="mpr.h::mprSearchForModule" ref="e1063b22696a3419f15470bfc8f4d68a" args="(MprCtx ctx, cchar *module, char **path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprSearchForModule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for a module on the current module path. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>module</em>&nbsp;</td><td>Name of the module to locate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>Pointer to a string that will receive the module path. Caller should free. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the module was found and path set to the location of the module. </dd></dl>

</div>
</div><p>
<a class="anchor" name="468c8ed0890483fb12b7630afcfc72d5"></a><!-- doxytag: member="mpr.h::mprSetAllocCallback" ref="468c8ed0890483fb12b7630afcfc72d5" args="(MprCtx ctx, MprAllocFailure cback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetAllocCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a>&nbsp;</td>
          <td class="paramname"> <em>cback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a notifier callback. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>A notifier callback will be invoked for memory allocation errors for the given memory context. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cback</em>&nbsp;</td><td>Notifier callback function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5afb03370eb13fda6f023dc6d928b477"></a><!-- doxytag: member="mpr.h::mprSetAllocError" ref="5afb03370eb13fda6f023dc6d928b477" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetAllocError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an memory allocation error condition on a memory context. 
<p>
This will set an allocation error condition on the given context and all its parents. This way, you can test the ultimate parent and detect if any memory allocation errors have occurred. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7e77eb84ba0cafd84b73bcc10a95376e"></a><!-- doxytag: member="mpr.h::mprSetAppName" ref="7e77eb84ba0cafd84b73bcc10a95376e" args="(MprCtx ctx, cchar *name, cchar *title, cchar *version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprSetAppName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the application name, title and version. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>One word, lower case name for the app. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td>Pascal case multi-word descriptive name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>Version of the app. Major-Minor-Patch. E.g. 1.2.3. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if successful. Otherwise a negative MPR error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0451f6be62ac9d8c4c9d57df6a4acfb"></a><!-- doxytag: member="mpr.h::mprSetDebugMode" ref="a0451f6be62ac9d8c4c9d57df6a4acfb" args="(MprCtx ctx, bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetDebugMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>on</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turn on debug mode. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Debug mode disables timeouts and timers. This makes debugging much easier. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on</em>&nbsp;</td><td>Set to true to enable debugging mode. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Evolving. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6a350c9fbbcd569b8c265b9c65845cd"></a><!-- doxytag: member="mpr.h::mprSetMaxSocketClients" ref="c6a350c9fbbcd569b8c265b9c65845cd" args="(MprCtx ctx, int max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprSetMaxSocketClients           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum number of client sockets that are permissable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>New maximum number of client sockets. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="27866b4c10d6e45ffd96604b221cf314"></a><!-- doxytag: member="mpr.h::mprSetSocketEof" ref="27866b4c10d6e45ffd96604b221cf314" args="(MprSocket *sp, bool eof)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetSocketEof           </td>
          <td>(</td>
          <td class="paramtype">MprSocket *&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>eof</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an EOF condition on the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>Socket object returned from <a class="el" href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9" title="Create a socket.">mprCreateSocket</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eof</em>&nbsp;</td><td>Set to true to set an EOF condition. Set to false to clear it. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="33ba4772eb9d6ea4725f2c3bec6947f8"></a><!-- doxytag: member="mpr.h::mprSetWorkerStackSize" ref="33ba4772eb9d6ea4725f2c3bec6947f8" args="(MprCtx ctx, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetWorkerStackSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default worker stack size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Stack size in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6cedd059c2f7ea313fbf7bc136ab2909"></a><!-- doxytag: member="mpr.h::mprSprintf" ref="6cedd059c2f7ea313fbf7bc136ab2909" args="(char *buf, int maxSize, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprSprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a string into a statically allocated buffer. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call format a string using printf style formatting arguments. A trailing null will always be appended. The call returns the size of the allocated string excluding the null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>Size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efdcc565b19075801a65604d388715d0"></a><!-- doxytag: member="mpr.h::mprStackCheck" ref="efdcc565b19075801a65604d388715d0" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mprStackCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Monitory stack usage and check if the stack has grown since last monitoring. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the stack has grown </dd></dl>

</div>
</div><p>
<a class="anchor" name="721856d6348713ef443f924013c42349"></a><!-- doxytag: member="mpr.h::mprStart" ref="721856d6348713ef443f924013c42349" args="(Mpr *mpr, int startEventsThread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStart           </td>
          <td>(</td>
          <td class="paramtype">Mpr *&nbsp;</td>
          <td class="paramname"> <em>mpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startEventsThread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the Mpr services. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mpr</em>&nbsp;</td><td>Mpr object created via mprCreateMpr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startEventsThread</em>&nbsp;</td><td>Set to true to start an events thread. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da0a427a03ab3475fb0faab39d3f5459"></a><!-- doxytag: member="mpr.h::mprStartWorker" ref="da0a427a03ab3475fb0faab39d3f5459" args="(MprCtx ctx, MprWorkerProc proc, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStartWorker           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99">MprWorkerProc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start a worker thread. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Start a worker thread executing the given worker procedure callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Worker procedure callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data parameter to the callback </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if successful, otherwise a negative MPR error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d6edb96beee6c995edc3197556536f5"></a><!-- doxytag: member="mpr.h::mprStaticPrintf" ref="4d6edb96beee6c995edc3197556536f5" args="(MprCtx ctx, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStaticPrintf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a message to the applications standard output without allocating memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This is a secure replacement for printf that will not allocate memory. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. This is used to locate the standard output channel and not to allocate memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes written </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The maximum output is MPR_MAX_STRING - 1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba7d5ea137f728040a397b62bb308455"></a><!-- doxytag: member="mpr.h::mprStaticPrintfError" ref="ba7d5ea137f728040a397b62bb308455" args="(MprCtx ctx, cchar *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStaticPrintfError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a message to the standard error channel without allocating memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This is a secure replacement for fprintf(stderr that will not allocate memory. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. This is used to locate the standard output channel and not to allocate memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of bytes written </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The maximum output is MPR_MAX_STRING - 1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0174635f1fe63aac33da9554b476c3f2"></a><!-- doxytag: member="mpr.h::mprStealBlock" ref="0174635f1fe63aac33da9554b476c3f2" args="(MprCtx ctx, cvoid *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStealBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cvoid *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reassign a block from its current parent context to a new context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. This will be the new owning context of the ptr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Pointer to a block to reassign. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f3f765dac52a91c673b6ff9f5d24da68"></a><!-- doxytag: member="mpr.h::mprStop" ref="f3f765dac52a91c673b6ff9f5d24da68" args="(Mpr *mpr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprStop           </td>
          <td>(</td>
          <td class="paramtype">Mpr *&nbsp;</td>
          <td class="paramname"> <em>mpr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop the MPR and shutdown all services. 
<p>
After this call, the MPR cannot be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mpr</em>&nbsp;</td><td>Mpr object created via mprCreateMpr </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3156f9075164b2fee835a66f62eb4aa"></a><!-- doxytag: member="mpr.h::mprStrcat" ref="d3156f9075164b2fee835a66f62eb4aa" args="(MprCtx ctx, int max, cchar *src,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrcat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Catenate strings. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safe replacement for strcat. Catenates a string onto an existing string. This call accepts a variable list of strings to append. The list of strings is terminated by a null argument. The call returns the length of the resulting string. This call is similar to strcat, but it will enforce a maximum size for the resulting string and will ensure it is terminated with a null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>Maximum size of the new block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Variable list of strings to append. The final string argument must be null. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns an allocated string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="937b35fb3e4a7cdac84e1c6985db6cc8"></a><!-- doxytag: member="mpr.h::mprStrcmp" ref="937b35fb3e4a7cdac84e1c6985db6cc8" args="(cchar *str1, cchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrcmp           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare strings. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Compare two strings. This is a safe replacement for strcmp. It can handle null args. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>First string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>Second string to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the strings are identical. Return -1 if the first string is less than the second. Return 1 if the first string is greater than the second. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e15c6b644b07a706125e13656d3be03b"></a><!-- doxytag: member="mpr.h::mprStrcmpAnyCase" ref="e15c6b644b07a706125e13656d3be03b" args="(cchar *str1, cchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrcmpAnyCase           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare strings ignoring case. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Compare two strings ignoring case differences. This call operates similarly to strcmp. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>First string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>Second string to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the strings are equivalent, &lt; 0 if s1 sorts lower than s2 in the collating sequence or &gt; 0 if it sorts higher. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12ece4a3c6060f5c09051b17212f14f8"></a><!-- doxytag: member="mpr.h::mprStrcmpAnyCaseCount" ref="12ece4a3c6060f5c09051b17212f14f8" args="(cchar *str1, cchar *str2, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrcmpAnyCaseCount           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare strings ignoring case. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Compare two strings ignoring case differences for a given string length. This call operates similarly to strncmp. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>First string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>Second string to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of characters to compare. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the strings are equivalent, &lt; 0 if s1 sorts lower than s2 in the collating sequence or &gt; 0 if it sorts higher. </dd></dl>

</div>
</div><p>
<a class="anchor" name="239b2debb47dd4553372d0ad89294521"></a><!-- doxytag: member="mpr.h::mprStrcpy" ref="239b2debb47dd4553372d0ad89294521" args="(char *dest, int destMax, cchar *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrcpy           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>destMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safe replacement for strcpy. Copy a string and ensure the target string is not overflowed. The call returns the length of the resultant string or an error code if it will not fit into the target string. This is similar to strcpy, but it will enforce a maximum size for the copied string and will ensure it is terminated with a null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to a pointer that will hold the address of the allocated block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destMax</em>&nbsp;</td><td>Maximum size of the target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String to copy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the target string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af8ce98847bb93316ca5f0c0ca9fcb67"></a><!-- doxytag: member="mpr.h::mprStrcpyCount" ref="af8ce98847bb93316ca5f0c0ca9fcb67" args="(char *dest, int destMax, cchar *src, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrcpyCount           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>destMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy characters from a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safe replacement for strncpy. Copy bytes from a string and ensure the target string is not overflowed. The call returns the length of the resultant string or an error code if it will not fit into the target string. This is similar to strcpy, but it will enforce a maximum size for the copied string and will ensure it is terminated with a null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to a pointer that will hold the address of the allocated block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destMax</em>&nbsp;</td><td>Maximum size of the target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Maximum count of characters to copy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the target string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d672f4f5cd20ea78325864b263460133"></a><!-- doxytag: member="mpr.h::mprStrlen" ref="d672f4f5cd20ea78325864b263460133" args="(cchar *src, int max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprStrlen           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the length of a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Safe replacement for strlen. This call returns the length of a string and tests if the length is less than a given maximum. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>String to measure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>Maximum length for the string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the length of the string or MPR_ERR_WONT_FIT if the length is greater than <em>max</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9c7e8c93945fa0bc4aa3608ea2b9802"></a><!-- doxytag: member="mpr.h::mprStrLower" ref="b9c7e8c93945fa0bc4aa3608ea2b9802" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrLower           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a string to lower case. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Convert a string to its lower case equivalent. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to convert. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the converted string. Will always equal str. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3707c7892d469df5810a249fa1a51a69"></a><!-- doxytag: member="mpr.h::mprStrnstr" ref="3707c7892d469df5810a249fa1a51a69" args="(cchar *str, cchar *pattern, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrnstr           </td>
          <td>(</td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a substring. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Locate the first occurrence of pattern in a string, but do not search more than the given length. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to the string to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>String pattern to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Count of characters in the pattern to actually search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the target string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="607579dc34bc84ebea2b67d7f9d55641"></a><!-- doxytag: member="mpr.h::mprStrTok" ref="607579dc34bc84ebea2b67d7f9d55641" args="(char *str, cchar *delim, char **last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrTok           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tokenize a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Split a string into tokens. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to tokenize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>String of characters to use as token separators. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Last token pointer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the next token. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cab0129f8454deb9debf1513ddf15738"></a><!-- doxytag: member="mpr.h::mprStrTrim" ref="cab0129f8454deb9debf1513ddf15738" args="(char *str, cchar *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrTrim           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trim a string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Trim leading and trailing characters off a string. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to trim. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>String of characters to remove. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the trimmed string. May not equal <em>str</em>. If <em>str</em> was dynamically allocated, do not call mprFree on the returned trimmed pointer. You must use <em>str</em> when calling mprFree. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f746a3a94464da0f6991d88d3d76ae75"></a><!-- doxytag: member="mpr.h::mprStrUpper" ref="f746a3a94464da0f6991d88d3d76ae75" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrUpper           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a string to upper case. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Convert a string to its upper case equivalent. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to convert. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the converted string. Will always equal str. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64b669a1f52e62b8010fe14094db885b"></a><!-- doxytag: member="mpr.h::mprUpdateWaitHandler" ref="64b669a1f52e62b8010fe14094db885b" args="(MprWaitHandler *wp, bool wakeup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprUpdateWaitHandler           </td>
          <td>(</td>
          <td class="paramtype">MprWaitHandler *&nbsp;</td>
          <td class="paramname"> <em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply wait handler updates. 
<p>
While a wait handler is in use, wait event updates are buffered. This routine applies such buffered updates. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wp</em>&nbsp;</td><td>Wait handler created via <a class="el" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd" title="Create a wait handler.">mprCreateWaitHandler</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Wake up the service events thread. Typically it is safest to wake up the service events thread if the wait handler event masks have been modified. However, there are some cases where it can be useful to suppress this behavior. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="42505a60e5679606bc22d8c1aa1dc4ba"></a><!-- doxytag: member="mpr.h::mprUriDecode" ref="42505a60e5679606bc22d8c1aa1dc4ba" args="(MprCtx ctx, cchar *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprUriDecode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode a URI string by de-scaping URI characters. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Decode a string with www-encoded characters that have meaning for URIs. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>URI to decode </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the buf argument. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff8a0ff793cc8e580ace3501d6949173"></a><!-- doxytag: member="mpr.h::mprUriEncode" ref="ff8a0ff793cc8e580ace3501d6949173" args="(MprCtx ctx, cchar *uri, int map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprUriEncode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>map</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode a string by escaping URI characters. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Encode a string escaping all characters that have meaning for URIs. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>URI to encode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>Map to encode characters. Select from MPR_ENCODE_URI or MPR_ENCODE_URI_COMPONENT. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated string containing the encoded URI. Caller must free using <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d5c8927e1a2c78d302726c41cd6da6cd"></a><!-- doxytag: member="mpr.h::mprValidateBlock" ref="d5c8927e1a2c78d302726c41cd6da6cd" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprValidateBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validate a memory block and issue asserts if the memory block or any children blocks do not validate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>New memory context for the block. Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bd8e3ce747235f08bf1fca492a653f9b"></a><!-- doxytag: member="mpr.h::mprVasprintf" ref="bd8e3ce747235f08bf1fca492a653f9b" args="(MprCtx ctx, int maxSize, cchar *fmt, va_list arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprVasprintf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a buffer of sufficient length to hold the formatted string. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call will dynamically allocate a buffer up to the specified maximum size and will format the supplied arguments into the buffer. A trailing null will always be appended. The call returns the size of the allocated string excluding the null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>Maximum size to allocate for the buffer including the trailing null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Varargs argument obtained from va_start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the number of characters in the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bba3c0b15d48ec6cc90966f14ae663a"></a><!-- doxytag: member="mpr.h::mprVsprintf" ref="5bba3c0b15d48ec6cc90966f14ae663a" args="(char *buf, int maxSize, cchar *fmt, va_list args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprVsprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a string into a statically allocated buffer. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call format a string using printf style formatting arguments. A trailing null will always be appended. The call returns the size of the allocated string excluding the null. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>Size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>Varargs argument obtained from va_start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the buffer; </dd></dl>

</div>
</div><p>
<a class="anchor" name="aabd29f554c4fa6b528f5c9587a7adb4"></a><!-- doxytag: member="mpr.h::mprWaitForIO" ref="aabd29f554c4fa6b528f5c9587a7adb4" args="(MprWaitService *ws, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprWaitForIO           </td>
          <td>(</td>
          <td class="paramtype">MprWaitService *&nbsp;</td>
          <td class="paramname"> <em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for I/O. 
<p>
This call waits for any I/O events on wait handlers until the given timeout expires. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ws</em>&nbsp;</td><td>Wait service object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Timeout in milliseconds to wait for an event. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A count of events received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1b9807f41341d92c190f8ae71390e78"></a><!-- doxytag: member="mpr.h::mprWaitForSingleIO" ref="f1b9807f41341d92c190f8ae71390e78" args="(MprCtx ctx, int fd, int mask, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprWaitForSingleIO           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for I/O on a file descriptor. 
<p>
No processing of the I/O event is done. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory allocation context created by MprAlloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File descriptor to examine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask of events of interest (MPR_READABLE | MPR_WRITABLE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Timeout in milliseconds to wait for an event. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A count of events received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffed14ffe657703bf2577f91e424d6f6"></a><!-- doxytag: member="mpr.h::mprWakeDispatcherService" ref="ffed14ffe657703bf2577f91e424d6f6" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprWakeDispatcherService           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wakeup the dispatcher. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jan 19 11:56:18 2010 for mpr by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
