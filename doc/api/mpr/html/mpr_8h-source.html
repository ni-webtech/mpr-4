<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mpr: mpr.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="dir_3fd9df3bcf4b859f17f835baaaf16dcf.html">all</a>
  </div>
<div class="contents">
<h1>mpr.h</h1><a href="mpr_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">/******************************************************************************/</span>
<a name="l00003"></a>00003 <span class="comment">/* </span>
<a name="l00004"></a>00004 <span class="comment"> *  This file is an amalgamation of all the individual source code files for</span>
<a name="l00005"></a>00005 <span class="comment"> *  Multithreaded Portable Runtime 3.0.1.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> *  Catenating all the source into a single file makes embedding simpler and</span>
<a name="l00008"></a>00008 <span class="comment"> *  the resulting application faster, as many compilers can do whole file</span>
<a name="l00009"></a>00009 <span class="comment"> *  optimization.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *  If you want to modify mpr, you can still get the whole source</span>
<a name="l00012"></a>00012 <span class="comment"> *  as individual files if you need.</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">/************************************************************************/</span>
<a name="l00017"></a>00017 <span class="comment">/*</span>
<a name="l00018"></a>00018 <span class="comment"> *  Start of file "../src/include/mprOs.h"</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 <span class="comment">/************************************************************************/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">/*</span>
<a name="l00023"></a>00023 <span class="comment"> *  mprOs.h -- Include O/S headers and smooth out per-O/S differences</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> *  Copyright (c) All Rights Reserved. See details at the end of the file.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">/*</span>
<a name="l00030"></a>00030 <span class="comment"> *  This header is part of the Multithreaded Portable Runtime and aims to include</span>
<a name="l00031"></a>00031 <span class="comment"> *  all necessary O/S headers and to unify the constants and declarations </span>
<a name="l00032"></a>00032 <span class="comment"> *  required by Embedthis products. It can be included by C or C++ programs.</span>
<a name="l00033"></a>00033 <span class="comment"> */</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef _h_MPR_OS_HDRS</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define _h_MPR_OS_HDRS 1</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#include    "buildConfig.h"</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">/*</span>
<a name="l00042"></a>00042 <span class="comment"> *  Porters, add your CPU families here and update configure code. </span>
<a name="l00043"></a>00043 <span class="comment"> */</span>
<a name="l00044"></a>00044 <span class="preprocessor">#define MPR_CPU_UNKNOWN     0</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_IX86        1</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_PPC         2</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_SPARC       3</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_XSCALE      4</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_ARM         5</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_MIPS        6</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_68K         7</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CPU_SIMNT       8           </span><span class="comment">/* VxWorks NT simulator */</span>
<a name="l00053"></a>00053 <span class="preprocessor">#define MPR_CPU_SIMSPARC    9           </span><span class="comment">/* VxWorks sparc simulator */</span>
<a name="l00054"></a>00054 <span class="preprocessor">#define MPR_CPU_IX64        10          </span><span class="comment">/* AMD64 or EMT64 */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#define MPR_CPU_UNIVERSAL   11          </span><span class="comment">/* MAC OS X universal binaries */</span>
<a name="l00056"></a>00056 <span class="preprocessor">#define MPR_CPU_SH4         12</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#if BLD_UNIX_LIKE &amp;&amp; !VXWORKS &amp;&amp; !MACOSX</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">    #include    &lt;arpa/inet.h&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">    #include    &lt;dirent.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">    #include    &lt;dlfcn.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">    #include    &lt;fcntl.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">    #include    &lt;grp.h&gt;</span> 
<a name="l00068"></a>00068 <span class="preprocessor">    #include    &lt;errno.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">    #include    &lt;libgen.h&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">    #include    &lt;limits.h&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">    #include    &lt;netdb.h&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">    #include    &lt;net/if.h&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">    #include    &lt;netinet/in.h&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">    #include    &lt;netinet/tcp.h&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">    #include    &lt;netinet/ip.h&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">    #include    &lt;pthread.h&gt;</span> 
<a name="l00077"></a>00077 <span class="preprocessor">    #include    &lt;pwd.h&gt;</span> 
<a name="l00078"></a>00078 <span class="preprocessor">    #include    &lt;sys/poll.h&gt;</span>
<a name="l00079"></a>00079 <span class="preprocessor">    #include    &lt;setjmp.h&gt;</span>
<a name="l00080"></a>00080 <span class="preprocessor">    #include    &lt;signal.h&gt;</span>
<a name="l00081"></a>00081 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00082"></a>00082 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00083"></a>00083 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00084"></a>00084 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00085"></a>00085 <span class="preprocessor">    #include    &lt;syslog.h&gt;</span>
<a name="l00086"></a>00086 <span class="preprocessor">    #include    &lt;sys/epoll.h&gt;</span>
<a name="l00087"></a>00087 <span class="preprocessor">    #include    &lt;sys/ioctl.h&gt;</span>
<a name="l00088"></a>00088 <span class="preprocessor">    #include    &lt;sys/mman.h&gt;</span>
<a name="l00089"></a>00089 <span class="preprocessor">    #include    &lt;sys/stat.h&gt;</span>
<a name="l00090"></a>00090 <span class="preprocessor">    #include    &lt;sys/param.h&gt;</span>
<a name="l00091"></a>00091 <span class="preprocessor">    #if !CYGWIN</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">        #include    &lt;sys/prctl.h&gt;</span>
<a name="l00093"></a>00093 <span class="preprocessor">    #endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;sys/resource.h&gt;</span>
<a name="l00095"></a>00095 <span class="preprocessor">    #include    &lt;sys/sem.h&gt;</span>
<a name="l00096"></a>00096 <span class="preprocessor">    #include    &lt;sys/shm.h&gt;</span>
<a name="l00097"></a>00097 <span class="preprocessor">    #include    &lt;sys/socket.h&gt;</span>
<a name="l00098"></a>00098 <span class="preprocessor">    #include    &lt;sys/select.h&gt;</span>
<a name="l00099"></a>00099 <span class="preprocessor">    #include    &lt;sys/time.h&gt;</span>
<a name="l00100"></a>00100 <span class="preprocessor">    #include    &lt;sys/times.h&gt;</span>
<a name="l00101"></a>00101 <span class="preprocessor">    #include    &lt;sys/utsname.h&gt;</span>
<a name="l00102"></a>00102 <span class="preprocessor">    #include    &lt;sys/uio.h&gt;</span>
<a name="l00103"></a>00103 <span class="preprocessor">    #include    &lt;sys/wait.h&gt;</span>
<a name="l00104"></a>00104 <span class="preprocessor">    #include    &lt;unistd.h&gt;</span>
<a name="l00105"></a>00105 <span class="preprocessor">#if LINUX &amp;&amp; !__UCLIBC__</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;sys/sendfile.h&gt;</span>
<a name="l00107"></a>00107 <span class="preprocessor">#endif</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#if CYGWIN || LINUX</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;stdint.h&gt;</span>
<a name="l00110"></a>00110 <span class="preprocessor">#else</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;netinet/in_systm.h&gt;</span>
<a name="l00112"></a>00112 <span class="preprocessor">#endif</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">    #define __USE_ISOC99 1</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;math.h&gt;</span>
<a name="l00116"></a>00116 <span class="preprocessor">#if !CYGWIN</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;resolv.h&gt;</span>
<a name="l00118"></a>00118 <span class="preprocessor">    #include    &lt;values.h&gt;</span>
<a name="l00119"></a>00119 <span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* BLD_UNIX_LIKE */</span>
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="preprocessor">#if VXWORKS</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;vxWorks.h&gt;</span>
<a name="l00126"></a>00126 <span class="preprocessor">    #include    &lt;envLib.h&gt;</span>
<a name="l00127"></a>00127 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00128"></a>00128 <span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00129"></a>00129 <span class="preprocessor">    #include    &lt;arpa/inet.h&gt;</span>
<a name="l00130"></a>00130 <span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00131"></a>00131 <span class="preprocessor">    #include    &lt;dirent.h&gt;</span>
<a name="l00132"></a>00132 <span class="preprocessor">    #include    &lt;fcntl.h&gt;</span>
<a name="l00133"></a>00133 <span class="preprocessor">    #include    &lt;errno.h&gt;</span>
<a name="l00134"></a>00134 <span class="preprocessor">    #include    &lt;iosLib.h&gt;</span>
<a name="l00135"></a>00135 <span class="preprocessor">    #include    &lt;limits.h&gt;</span>
<a name="l00136"></a>00136 <span class="preprocessor">    #include    &lt;loadLib.h&gt;</span>
<a name="l00137"></a>00137 <span class="preprocessor">    #include    &lt;netdb.h&gt;</span>
<a name="l00138"></a>00138 <span class="preprocessor">    #include    &lt;net/if.h&gt;</span>
<a name="l00139"></a>00139 <span class="preprocessor">    #include    &lt;netinet/tcp.h&gt;</span>
<a name="l00140"></a>00140 <span class="preprocessor">    #include    &lt;netinet/in.h&gt;</span>
<a name="l00141"></a>00141 <span class="preprocessor">    #include    &lt;netinet/ip.h&gt;</span>
<a name="l00142"></a>00142 <span class="preprocessor">    #include    &lt;selectLib.h&gt;</span>
<a name="l00143"></a>00143 <span class="preprocessor">    #include    &lt;setjmp.h&gt;</span>
<a name="l00144"></a>00144 <span class="preprocessor">    #include    &lt;signal.h&gt;</span>
<a name="l00145"></a>00145 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00146"></a>00146 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00147"></a>00147 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00148"></a>00148 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00149"></a>00149 <span class="preprocessor">    #include    &lt;symSyncLib.h&gt;</span>
<a name="l00150"></a>00150 <span class="preprocessor">    #include    &lt;sysSymTbl.h&gt;</span>
<a name="l00151"></a>00151 <span class="preprocessor">    #include    &lt;sys/fcntlcom.h&gt;</span>
<a name="l00152"></a>00152 <span class="preprocessor">    #include    &lt;sys/ioctl.h&gt;</span>
<a name="l00153"></a>00153 <span class="preprocessor">    #include    &lt;sys/stat.h&gt;</span>
<a name="l00154"></a>00154 <span class="preprocessor">    #include    &lt;sys/socket.h&gt;</span>
<a name="l00155"></a>00155 <span class="preprocessor">    #include    &lt;sys/times.h&gt;</span>
<a name="l00156"></a>00156 <span class="preprocessor">    #include    &lt;unistd.h&gt;</span>
<a name="l00157"></a>00157 <span class="preprocessor">    #include    &lt;unldLib.h&gt;</span>
<a name="l00158"></a>00158 <span class="preprocessor">    #if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;float.h&gt;</span>
<a name="l00160"></a>00160 <span class="preprocessor">    #define __USE_ISOC99 1</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;math.h&gt;</span>
<a name="l00162"></a>00162 <span class="preprocessor">    #endif</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;sockLib.h&gt;</span>
<a name="l00164"></a>00164 <span class="preprocessor">    #include    &lt;inetLib.h&gt;</span>
<a name="l00165"></a>00165 <span class="preprocessor">    #include    &lt;ioLib.h&gt;</span>
<a name="l00166"></a>00166 <span class="preprocessor">    #include    &lt;pipeDrv.h&gt;</span>
<a name="l00167"></a>00167 <span class="preprocessor">    #include    &lt;hostLib.h&gt;</span>
<a name="l00168"></a>00168 <span class="preprocessor">    #include    &lt;netdb.h&gt;</span>
<a name="l00169"></a>00169 <span class="preprocessor">    #include    &lt;tickLib.h&gt;</span>
<a name="l00170"></a>00170 <span class="preprocessor">    #include    &lt;taskHookLib.h&gt;</span>
<a name="l00171"></a>00171 <span class="preprocessor">#if _WRS_VXWORKS_MAJOR &gt;= 6</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;wait.h&gt;</span>
<a name="l00173"></a>00173 <span class="preprocessor">#endif</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* VXWORKS */</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="preprocessor">#if MACOSX</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00179"></a>00179 <span class="preprocessor">    #include    &lt;arpa/inet.h&gt;</span>
<a name="l00180"></a>00180 <span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00181"></a>00181 <span class="preprocessor">    #include    &lt;dirent.h&gt;</span>
<a name="l00182"></a>00182 <span class="preprocessor">    #include    &lt;dlfcn.h&gt;</span>
<a name="l00183"></a>00183 <span class="preprocessor">    #include    &lt;fcntl.h&gt;</span>
<a name="l00184"></a>00184 <span class="preprocessor">    #include    &lt;grp.h&gt;</span> 
<a name="l00185"></a>00185 <span class="preprocessor">    #include    &lt;errno.h&gt;</span>
<a name="l00186"></a>00186 <span class="preprocessor">    #include    &lt;libgen.h&gt;</span>
<a name="l00187"></a>00187 <span class="preprocessor">    #include    &lt;limits.h&gt;</span>
<a name="l00188"></a>00188 <span class="preprocessor">    #include    &lt;mach-o/dyld.h&gt;</span>
<a name="l00189"></a>00189 <span class="preprocessor">    #include    &lt;netdb.h&gt;</span>
<a name="l00190"></a>00190 <span class="preprocessor">    #include    &lt;net/if.h&gt;</span>
<a name="l00191"></a>00191 <span class="preprocessor">    #include    &lt;netinet/in.h&gt;</span>
<a name="l00192"></a>00192 <span class="preprocessor">    #include    &lt;netinet/tcp.h&gt;</span>
<a name="l00193"></a>00193 <span class="preprocessor">    #include    &lt;sys/poll.h&gt;</span>
<a name="l00194"></a>00194 <span class="preprocessor">    #include    &lt;pthread.h&gt;</span> 
<a name="l00195"></a>00195 <span class="preprocessor">    #include    &lt;pwd.h&gt;</span> 
<a name="l00196"></a>00196 <span class="preprocessor">    #include    &lt;resolv.h&gt;</span>
<a name="l00197"></a>00197 <span class="preprocessor">    #include    &lt;setjmp.h&gt;</span>
<a name="l00198"></a>00198 <span class="preprocessor">    #include    &lt;signal.h&gt;</span>
<a name="l00199"></a>00199 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00200"></a>00200 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00201"></a>00201 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00202"></a>00202 <span class="preprocessor">    #include    &lt;stdint.h&gt;</span>
<a name="l00203"></a>00203 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00204"></a>00204 <span class="preprocessor">    #include    &lt;syslog.h&gt;</span>
<a name="l00205"></a>00205 <span class="preprocessor">    #include    &lt;sys/ioctl.h&gt;</span>
<a name="l00206"></a>00206 <span class="preprocessor">    #include    &lt;sys/mman.h&gt;</span>
<a name="l00207"></a>00207 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00208"></a>00208 <span class="preprocessor">    #include    &lt;sys/stat.h&gt;</span>
<a name="l00209"></a>00209 <span class="preprocessor">    #include    &lt;sys/param.h&gt;</span>
<a name="l00210"></a>00210 <span class="preprocessor">    #include    &lt;sys/resource.h&gt;</span>
<a name="l00211"></a>00211 <span class="preprocessor">    #include    &lt;sys/sem.h&gt;</span>
<a name="l00212"></a>00212 <span class="preprocessor">    #include    &lt;sys/shm.h&gt;</span>
<a name="l00213"></a>00213 <span class="preprocessor">    #include    &lt;sys/socket.h&gt;</span>
<a name="l00214"></a>00214 <span class="preprocessor">    #include    &lt;sys/select.h&gt;</span>
<a name="l00215"></a>00215 <span class="preprocessor">    #include    &lt;sys/sysctl.h&gt;</span>
<a name="l00216"></a>00216 <span class="preprocessor">    #include    &lt;sys/time.h&gt;</span>
<a name="l00217"></a>00217 <span class="preprocessor">    #include    &lt;sys/times.h&gt;</span>
<a name="l00218"></a>00218 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00219"></a>00219 <span class="preprocessor">    #include    &lt;sys/uio.h&gt;</span>
<a name="l00220"></a>00220 <span class="preprocessor">    #include    &lt;sys/utsname.h&gt;</span>
<a name="l00221"></a>00221 <span class="preprocessor">    #include    &lt;sys/wait.h&gt;</span>
<a name="l00222"></a>00222 <span class="preprocessor">    #include    &lt;unistd.h&gt;</span>
<a name="l00223"></a>00223 <span class="preprocessor">    #include    &lt;libkern/OSAtomic.h&gt;</span>
<a name="l00224"></a>00224 <span class="preprocessor">    #if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;float.h&gt;</span>
<a name="l00226"></a>00226 <span class="preprocessor">    #define __USE_ISOC99 1</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;math.h&gt;</span>
<a name="l00228"></a>00228 <span class="preprocessor">    #endif</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* MACOSX */</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="preprocessor">#if FREEBSD</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00234"></a>00234 <span class="preprocessor">    #include    &lt;arpa/inet.h&gt;</span>
<a name="l00235"></a>00235 <span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00236"></a>00236 <span class="preprocessor">    #include    &lt;dirent.h&gt;</span>
<a name="l00237"></a>00237 <span class="preprocessor">    #include    &lt;dlfcn.h&gt;</span>
<a name="l00238"></a>00238 <span class="preprocessor">    #include    &lt;fcntl.h&gt;</span>
<a name="l00239"></a>00239 <span class="preprocessor">    #include    &lt;grp.h&gt;</span> 
<a name="l00240"></a>00240 <span class="preprocessor">    #include    &lt;errno.h&gt;</span>
<a name="l00241"></a>00241 <span class="preprocessor">    #include    &lt;libgen.h&gt;</span>
<a name="l00242"></a>00242 <span class="preprocessor">    #include    &lt;limits.h&gt;</span>
<a name="l00243"></a>00243 <span class="preprocessor">    #include    &lt;netdb.h&gt;</span>
<a name="l00244"></a>00244 <span class="preprocessor">    #include    &lt;sys/socket.h&gt;</span>
<a name="l00245"></a>00245 <span class="preprocessor">    #include    &lt;net/if.h&gt;</span>
<a name="l00246"></a>00246 <span class="preprocessor">    #include    &lt;netinet/in_systm.h&gt;</span>
<a name="l00247"></a>00247 <span class="preprocessor">    #include    &lt;netinet/in.h&gt;</span>
<a name="l00248"></a>00248 <span class="preprocessor">    #include    &lt;netinet/tcp.h&gt;</span>
<a name="l00249"></a>00249 <span class="preprocessor">    #include    &lt;netinet/ip.h&gt;</span>
<a name="l00250"></a>00250 <span class="preprocessor">    #include    &lt;pthread.h&gt;</span> 
<a name="l00251"></a>00251 <span class="preprocessor">    #include    &lt;pwd.h&gt;</span> 
<a name="l00252"></a>00252 <span class="preprocessor">    #include    &lt;resolv.h&gt;</span>
<a name="l00253"></a>00253 <span class="preprocessor">    #include    &lt;signal.h&gt;</span>
<a name="l00254"></a>00254 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00255"></a>00255 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00256"></a>00256 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00257"></a>00257 <span class="preprocessor">    #include    &lt;stdint.h&gt;</span>
<a name="l00258"></a>00258 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00259"></a>00259 <span class="preprocessor">    #include    &lt;syslog.h&gt;</span>
<a name="l00260"></a>00260 <span class="preprocessor">    #include    &lt;sys/ioctl.h&gt;</span>
<a name="l00261"></a>00261 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00262"></a>00262 <span class="preprocessor">    #include    &lt;sys/stat.h&gt;</span>
<a name="l00263"></a>00263 <span class="preprocessor">    #include    &lt;sys/param.h&gt;</span>
<a name="l00264"></a>00264 <span class="preprocessor">    #include    &lt;sys/resource.h&gt;</span>
<a name="l00265"></a>00265 <span class="preprocessor">    #include    &lt;sys/sem.h&gt;</span>
<a name="l00266"></a>00266 <span class="preprocessor">    #include    &lt;sys/shm.h&gt;</span>
<a name="l00267"></a>00267 <span class="preprocessor">    #include    &lt;sys/select.h&gt;</span>
<a name="l00268"></a>00268 <span class="preprocessor">    #include    &lt;sys/time.h&gt;</span>
<a name="l00269"></a>00269 <span class="preprocessor">    #include    &lt;sys/times.h&gt;</span>
<a name="l00270"></a>00270 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00271"></a>00271 <span class="preprocessor">    #include    &lt;sys/utsname.h&gt;</span>
<a name="l00272"></a>00272 <span class="preprocessor">    #include    &lt;sys/wait.h&gt;</span>
<a name="l00273"></a>00273 <span class="preprocessor">    #include    &lt;unistd.h&gt;</span>
<a name="l00274"></a>00274 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;float.h&gt;</span>
<a name="l00276"></a>00276 <span class="preprocessor">    #define __USE_ISOC99 1</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;math.h&gt;</span>
<a name="l00278"></a>00278 <span class="preprocessor">#endif</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* FREEBSD */</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="preprocessor">#if WIN</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00283"></a>00283 <span class="comment">     *  We replace insecure functions with Embedthis replacements</span>
<a name="l00284"></a>00284 <span class="comment">     */</span>
<a name="l00285"></a>00285 <span class="preprocessor">    #define     _CRT_SECURE_NO_DEPRECATE 1</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287     <span class="comment">/*</span>
<a name="l00288"></a>00288 <span class="comment">     *  Need this to get the the latest winsock APIs</span>
<a name="l00289"></a>00289 <span class="comment">     */</span>
<a name="l00290"></a>00290 <span class="preprocessor">    #ifndef     _WIN32_WINNT</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="preprocessor">    #define     _WIN32_WINNT 0x501</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span>
<a name="l00294"></a>00294 <span class="preprocessor">    #include    &lt;winsock2.h&gt;</span>
<a name="l00295"></a>00295 <span class="preprocessor">    #include    &lt;ws2tcpip.h&gt;</span>
<a name="l00296"></a>00296 <span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00297"></a>00297 <span class="preprocessor">    #include    &lt;conio.h&gt;</span>
<a name="l00298"></a>00298 <span class="preprocessor">    #include    &lt;direct.h&gt;</span>
<a name="l00299"></a>00299 <span class="preprocessor">    #include    &lt;errno.h&gt;</span>
<a name="l00300"></a>00300 <span class="preprocessor">    #include    &lt;fcntl.h&gt;</span>
<a name="l00301"></a>00301 <span class="preprocessor">    #include    &lt;io.h&gt;</span>
<a name="l00302"></a>00302 <span class="preprocessor">    #include    &lt;limits.h&gt;</span>
<a name="l00303"></a>00303 <span class="preprocessor">    #include    &lt;malloc.h&gt;</span>
<a name="l00304"></a>00304 <span class="preprocessor">    #include    &lt;process.h&gt;</span>
<a name="l00305"></a>00305 <span class="preprocessor">    #include    &lt;sys/stat.h&gt;</span>
<a name="l00306"></a>00306 <span class="preprocessor">    #include    &lt;sys/types.h&gt;</span>
<a name="l00307"></a>00307 <span class="preprocessor">    #include    &lt;setjmp.h&gt;</span>
<a name="l00308"></a>00308 <span class="preprocessor">    #include    &lt;stddef.h&gt;</span>
<a name="l00309"></a>00309 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00310"></a>00310 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00311"></a>00311 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00312"></a>00312 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00313"></a>00313 <span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00314"></a>00314 <span class="preprocessor">    #include    &lt;windows.h&gt;</span>
<a name="l00315"></a>00315 <span class="preprocessor">    #if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;math.h&gt;</span>
<a name="l00317"></a>00317 <span class="preprocessor">    #include    &lt;float.h&gt;</span>
<a name="l00318"></a>00318 <span class="preprocessor">    #endif</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;shlobj.h&gt;</span>
<a name="l00320"></a>00320 <span class="preprocessor">    #include    &lt;shellapi.h&gt;</span>
<a name="l00321"></a>00321 <span class="preprocessor">    #include    &lt;wincrypt.h&gt;</span>
<a name="l00322"></a>00322 <span class="preprocessor">    #if BLD_DEBUG</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;crtdbg.h&gt;</span>
<a name="l00324"></a>00324 <span class="preprocessor">    #endif</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="preprocessor">    #undef     _WIN32_WINNT</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* WIN */</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="preprocessor">#if WINCE</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;ctype.h&gt;</span>
<a name="l00331"></a>00331 <span class="preprocessor">    #include    &lt;malloc.h&gt;</span>
<a name="l00332"></a>00332 <span class="preprocessor">    #include    &lt;stddef.h&gt;</span>
<a name="l00333"></a>00333 <span class="preprocessor">    #include    &lt;stdio.h&gt;</span>
<a name="l00334"></a>00334 <span class="preprocessor">    #include    &lt;stdlib.h&gt;</span>
<a name="l00335"></a>00335 <span class="preprocessor">    #include    &lt;string.h&gt;</span>
<a name="l00336"></a>00336 <span class="preprocessor">    #include    &lt;stdarg.h&gt;</span>
<a name="l00337"></a>00337 <span class="preprocessor">    #include    &lt;time.h&gt;</span>
<a name="l00338"></a>00338 <span class="preprocessor">    #include    &lt;winsock2.h&gt;</span>
<a name="l00339"></a>00339 <span class="preprocessor">    #include    &lt;windows.h&gt;</span>
<a name="l00340"></a>00340 <span class="preprocessor">    #include    &lt;winbase.h&gt;</span>
<a name="l00341"></a>00341 <span class="preprocessor">    #include    &lt;winuser.h&gt;</span>
<a name="l00342"></a>00342 <span class="preprocessor">    #if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;float.h&gt;</span>
<a name="l00344"></a>00344 <span class="preprocessor">    #endif</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span><span class="preprocessor">    #include    &lt;shlobj.h&gt;</span>
<a name="l00346"></a>00346 <span class="preprocessor">    #include    &lt;shellapi.h&gt;</span>
<a name="l00347"></a>00347 <span class="preprocessor">    #include    &lt;wincrypt.h&gt;</span>
<a name="l00348"></a>00348 <span class="preprocessor">#endif </span><span class="comment">/* WINCE */</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">/*</span>
<a name="l00351"></a>00351 <span class="comment"> *  Word size and conversions between integer and pointer.</span>
<a name="l00352"></a>00352 <span class="comment"> */</span>
<a name="l00353"></a>00353 <span class="preprocessor">#if __WORDSIZE == 64 || __amd64 || __x86_64 || __x86_64__</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_64_BIT 1</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span><span class="preprocessor">    #define ITOP(i)         ((void*) ((int64) i))</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span><span class="preprocessor">    #define PTOI(i)         ((int) ((int64) i))</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span><span class="preprocessor">    #define LTOP(i)         ((void*) ((int64) i))</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span><span class="preprocessor">    #define PTOL(i)         ((int64) i)</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_64_BIT 0</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span><span class="preprocessor">    #define ITOP(i)         ((void*) ((int) i))</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span><span class="preprocessor">    #define PTOI(i)         ((int) i)</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span><span class="preprocessor">    #define LTOP(i)         ((void*) ((int) i))</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span><span class="preprocessor">    #define PTOL(i)         ((int64) (int) i)</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>
<a name="l00367"></a>00367 <span class="comment">/*</span>
<a name="l00368"></a>00368 <span class="comment"> *  Standard const types used by the MPR</span>
<a name="l00369"></a>00369 <span class="comment"> */</span>
<a name="l00370"></a>00370 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uchar;
<a name="l00371"></a>00371 <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span> schar;
<a name="l00372"></a>00372 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span> cchar;
<a name="l00373"></a>00373 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cuchar;
<a name="l00374"></a>00374 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> cushort;
<a name="l00375"></a>00375 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">void</span> cvoid;
<a name="l00376"></a>00376 <span class="keyword">typedef</span> <span class="keywordtype">short</span> uni;
<a name="l00377"></a>00377 <span class="keyword">typedef</span> <span class="keyword">const</span> uni cuni;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00381"></a>00381 <span class="preprocessor">#else</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span><span class="preprocessor">    #if !MACOSX</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">int</span> bool;
<a name="l00384"></a>00384 <span class="preprocessor">    #endif</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="preprocessor">#if BLD_UNIX_LIKE</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span>    <span class="keyword">typedef</span> pthread_t   MprOsThread;
<a name="l00389"></a>00389 <span class="preprocessor">#elif BLD_CPU_ARCH == MPR_CPU_IX64</span>
<a name="l00390"></a>00390 <span class="preprocessor"></span>    <span class="keyword">typedef</span> int64       MprOsThread;
<a name="l00391"></a>00391 <span class="preprocessor">#else</span>
<a name="l00392"></a>00392 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">int</span>         MprOsThread;
<a name="l00393"></a>00393 <span class="preprocessor">#endif</span>
<a name="l00394"></a>00394 <span class="preprocessor"></span>
<a name="l00395"></a>00395 <span class="preprocessor">#ifndef BITSPERBYTE</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span><span class="preprocessor">#define BITSPERBYTE     (8 * sizeof(char))</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span>
<a name="l00399"></a>00399 <span class="preprocessor">#define BITS(type)      (BITSPERBYTE * (int) sizeof(type))</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>
<a name="l00401"></a>00401 <span class="preprocessor">#ifndef MAXINT</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span><span class="preprocessor">#if INT_MAX</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span><span class="preprocessor">    #define MAXINT      INT_MAX</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span><span class="preprocessor">    #define MAXINT      0x7fffffff</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="preprocessor">#ifndef MAXINT64</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span><span class="preprocessor">    #define MAXINT64    INT64(0x7fffffffffffffff)</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>
<a name="l00412"></a>00412 <span class="comment">/*</span>
<a name="l00413"></a>00413 <span class="comment"> *  Byte orderings</span>
<a name="l00414"></a>00414 <span class="comment"> */</span>
<a name="l00415"></a>00415 <span class="preprocessor">#define MPR_LITTLE_ENDIAN   1</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span><span class="preprocessor">#define MPR_BIG_ENDIAN      2</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00418"></a>00418 <span class="comment"> *  Current endian ordering</span>
<a name="l00419"></a>00419 <span class="comment"> */</span>
<a name="l00420"></a>00420 <span class="preprocessor">#define MPR_ENDIAN          BLD_ENDIAN</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="preprocessor">#ifndef max</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span><span class="preprocessor">    #define max(a,b)  (((a) &gt; (b)) ? (a) : (b))</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span><span class="preprocessor">#ifndef min</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span><span class="preprocessor">    #define min(a,b)  (((a) &lt; (b)) ? (a) : (b))</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a>00429 <span class="preprocessor">#ifndef PRINTF_ATTRIBUTE</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span><span class="preprocessor">    #if (__GNUC__ &gt;= 3) &amp;&amp; !DOXYGEN &amp;&amp; BLD_DEBUG</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span><span class="comment">        /** </span>
<a name="l00432"></a>00432 <span class="comment">         *  Use gcc attribute to check printf fns.  a1 is the 1-based index of the parameter containing the format, </span>
<a name="l00433"></a>00433 <span class="comment">         *  and a2 the index of the first argument. Note that some gcc 2.x versions don't handle this properly </span>
<a name="l00434"></a>00434 <span class="comment">         */</span>     
<a name="l00435"></a>00435 <span class="preprocessor">        #define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span><span class="preprocessor">        #define PRINTF_ATTRIBUTE(a1, a2)</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>
<a name="l00441"></a>00441 <span class="preprocessor">#define MPR_INLINE inline</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>
<a name="l00443"></a>00443 <span class="comment">/*</span>
<a name="l00444"></a>00444 <span class="comment"> *  Optimize expression evaluation code depending if the value is likely or not</span>
<a name="l00445"></a>00445 <span class="comment"> */</span>
<a name="l00446"></a>00446 <span class="preprocessor">#undef likely</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span><span class="preprocessor">#undef unlikely</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span><span class="preprocessor">#if (__GNUC__ &gt;= 3)</span>
<a name="l00449"></a>00449 <span class="preprocessor"></span><span class="preprocessor">    #define likely(x)   __builtin_expect(!!(x), 1)</span>
<a name="l00450"></a>00450 <span class="preprocessor"></span><span class="preprocessor">    #define unlikely(x) __builtin_expect(!!(x), 0)</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span><span class="preprocessor">    #define likely(x)   (x)</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span><span class="preprocessor">    #define unlikely(x) (x)</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 <span class="preprocessor">#if !__UCLIBC__ &amp;&amp; __USE_XOPEN2K</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">#define BLD_HAS_SPINLOCK    1</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>
<a name="l00460"></a>00460 <span class="preprocessor">#if VXWORKS &amp;&amp; (_WRS_VXWORKS_MAJOR &lt;= 5 || _DIAB_TOOL)</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span><span class="preprocessor">#define BLD_HAS_UNNAMED_UNIONS 0</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span><span class="preprocessor">#define BLD_HAS_UNNAMED_UNIONS 1</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="preprocessor">#if CYGWIN || LINUX</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span>    __extension__ <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
<a name="l00469"></a>00469     __extension__ <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> uint64;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="preprocessor">#if CYGWIN</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulong;
<a name="l00473"></a>00473 <span class="preprocessor">#endif</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>
<a name="l00475"></a>00475     <span class="keyword">typedef</span> off_t MprOffset;
<a name="l00476"></a>00476     <span class="keyword">typedef</span> intptr_t pint;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="preprocessor">    #define INT64(x) (x##LL)</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span><span class="preprocessor">    #define UINT64(x) (x##ULL)</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>
<a name="l00481"></a>00481 <span class="preprocessor">    #define closesocket(x)  close(x)</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BINARY      ""</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        ""</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span><span class="preprocessor">    #define SOCKET_ERROR    -1</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span><span class="preprocessor">    #define SET_SOCKOPT_CAST void*</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span>
<a name="l00487"></a>00487 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       MAXFLOAT</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="preprocessor">    #define isNan(f) (f == FP_NAN)</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span>
<a name="l00492"></a>00492 <span class="preprocessor">#if CYGWIN</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PTHREAD_MUTEX_RECURSIVE_NP</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="preprocessor">        #define PTHREAD_MUTEX_RECURSIVE_NP PTHREAD_MUTEX_RECURSIVE</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span><span class="preprocessor">    #define __WALL          0</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span>
<a name="l00501"></a>00501     <span class="comment">/*</span>
<a name="l00502"></a>00502 <span class="comment">     *  For some reason it is removed from fedora 6 pthreads.h and only comes in for UNIX96</span>
<a name="l00503"></a>00503 <span class="comment">     */</span>
<a name="l00504"></a>00504     <span class="keyword">extern</span> <span class="keywordtype">int</span> pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
<a name="l00505"></a>00505         __attr, <span class="keywordtype">int</span> *__restrict __kind) __THROW;
<a name="l00506"></a>00506     <span class="comment">/* </span>
<a name="l00507"></a>00507 <span class="comment">     *  Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,</span>
<a name="l00508"></a>00508 <span class="comment">     *  PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or PTHREAD_MUTEX_DEFAULT).  </span>
<a name="l00509"></a>00509 <span class="comment">     */</span>
<a name="l00510"></a>00510     <span class="keyword">extern</span> <span class="keywordtype">int</span> pthread_mutexattr_settype (pthread_mutexattr_t *__attr, <span class="keywordtype">int</span> __kind) __THROW;
<a name="l00511"></a>00511     <span class="keyword">extern</span> <span class="keywordtype">char</span> **environ;
<a name="l00512"></a>00512 <span class="preprocessor">#endif</span>
<a name="l00513"></a>00513 <span class="preprocessor"></span>
<a name="l00514"></a>00514 <span class="preprocessor">    #define LD_LIBRARY_PATH "LD_LIBRARY_PATH"</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span>
<a name="l00516"></a>00516 <span class="preprocessor">#endif  </span><span class="comment">/* CYGWIN || LINUX  */</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="preprocessor">#if VXWORKS</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>    <span class="keyword">typedef</span> off_t MprOffset;
<a name="l00521"></a>00521     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uint;
<a name="l00522"></a>00522     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulong;
<a name="l00523"></a>00523     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
<a name="l00524"></a>00524     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> uint64;
<a name="l00525"></a>00525     <span class="keyword">typedef</span> <span class="keywordtype">int</span> pint;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="preprocessor">    #define HAVE_SOCKLEN_T</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span><span class="preprocessor">    #define INT64(x) (x##LL)</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span><span class="preprocessor">    #define UINT64(x) (x##ULL)</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span>
<a name="l00531"></a>00531 <span class="preprocessor">    #define MPR_BINARY      ""</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        ""</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span><span class="preprocessor">    #define SOCKET_ERROR    -1</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span><span class="preprocessor">    #define MSG_NOSIGNAL    0</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span><span class="preprocessor">    #define __WALL          0</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span>
<a name="l00539"></a>00539     <span class="comment">/*  TODO - refactor - rename */</span>
<a name="l00540"></a>00540 <span class="preprocessor">    #define SET_SOCKOPT_CAST char*</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span><span class="preprocessor">    #define closesocket(x) close(x)</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>
<a name="l00543"></a>00543 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       FLT_MAX</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>
<a name="l00547"></a>00547 <span class="preprocessor">    #undef R_OK</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span><span class="preprocessor">    #define R_OK    4</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span><span class="preprocessor">    #undef W_OK</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span><span class="preprocessor">    #define W_OK    2</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span><span class="preprocessor">    #undef X_OK</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span><span class="preprocessor">    #define X_OK    1</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span><span class="preprocessor">    #undef F_OK</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span><span class="preprocessor">    #define F_OK    0</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>
<a name="l00556"></a>00556     <span class="keyword">extern</span> <span class="keywordtype">int</span> sysClkRateGet();
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 <span class="preprocessor">    #ifndef SHUT_RDWR</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span><span class="preprocessor">        #define SHUT_RDWR 2</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>
<a name="l00562"></a>00562 <span class="preprocessor">    #define getpid mprGetpid</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>    <span class="keyword">extern</span> uint mprGetpid();
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="preprocessor">#if _WRS_VXWORKS_MAJOR &lt; 6</span>
<a name="l00566"></a>00566 <span class="preprocessor"></span><span class="preprocessor">    #define NI_MAXHOST      128</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>    <span class="keyword">extern</span> STATUS access(cchar *path, <span class="keywordtype">int</span> mode);
<a name="l00568"></a>00568     <span class="keyword">typedef</span> <span class="keywordtype">int</span>     socklen_t;
<a name="l00569"></a>00569     <span class="keyword">struct </span>sockaddr_storage {
<a name="l00570"></a>00570         <span class="keywordtype">char</span>        pad[1024];
<a name="l00571"></a>00571     };
<a name="l00572"></a>00572 <span class="preprocessor">#else</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00574"></a>00574 <span class="comment">     *  This may or may not be necessary - let us know dev@embedthis.com if your system needs this (and why).</span>
<a name="l00575"></a>00575 <span class="comment">     */</span>
<a name="l00576"></a>00576 <span class="preprocessor">    #if _DIAB_TOOL</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span><span class="preprocessor">        #if BLD_HOST_CPU_ARCH == MPR_CPU_PPC</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span><span class="preprocessor">            #define __va_copy(dest, src) *(dest) = *(src)</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span><span class="preprocessor">    #define HAVE_SOCKLEN_T</span>
<a name="l00582"></a>00582 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span><span class="preprocessor">    #if _DIAB_TOOL</span>
<a name="l00584"></a>00584 <span class="preprocessor"></span><span class="preprocessor">    #define inline __inline__</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00586"></a>00586 <span class="preprocessor"></span>
<a name="l00587"></a>00587 <span class="preprocessor">#endif  </span><span class="comment">/* VXWORKS */</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="preprocessor">#if MACOSX</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span>    <span class="keyword">typedef</span> off_t MprOffset;
<a name="l00592"></a>00592     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulong;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     __extension__ <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
<a name="l00595"></a>00595     __extension__ <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> uint64;
<a name="l00596"></a>00596     <span class="keyword">typedef</span> intptr_t pint;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="preprocessor">    #define INT64(x) (x##LL)</span>
<a name="l00599"></a>00599 <span class="preprocessor"></span><span class="preprocessor">    #define UINT64(x) (x##ULL)</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>
<a name="l00601"></a>00601 <span class="preprocessor">    #define closesocket(x)  close(x)</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BINARY      ""</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        ""</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span><span class="preprocessor">    #define SOCKET_ERROR    -1</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span><span class="preprocessor">    #define MSG_NOSIGNAL    0</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span><span class="preprocessor">    #define __WALL          0           </span><span class="comment">/* 0x40000000 */</span>
<a name="l00609"></a>00609 <span class="preprocessor">    #define SET_SOCKOPT_CAST void*</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span><span class="preprocessor">    #define PTHREAD_MUTEX_RECURSIVE_NP  PTHREAD_MUTEX_RECURSIVE</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>
<a name="l00612"></a>00612 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       MAXFLOAT</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>    
<a name="l00616"></a>00616     <span class="comment">/*</span>
<a name="l00617"></a>00617 <span class="comment">     *  Fix for MAC OS X - getenv</span>
<a name="l00618"></a>00618 <span class="comment">     */</span>
<a name="l00619"></a>00619 <span class="preprocessor">    #if !HAVE_DECL_ENVIRON</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span><span class="preprocessor">    #ifdef __APPLE__</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span><span class="preprocessor">        #include &lt;crt_externs.h&gt;</span>
<a name="l00622"></a>00622 <span class="preprocessor">        #define environ (*_NSGetEnviron())</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
<a name="l00624"></a>00624 <span class="preprocessor"></span>        <span class="keyword">extern</span> <span class="keywordtype">char</span> **environ;
<a name="l00625"></a>00625 <span class="preprocessor">    #endif</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00627"></a>00627 <span class="preprocessor"></span><span class="preprocessor">    #define LD_LIBRARY_PATH "DYLD_LIBRARY_PATH"</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* MACOSX */</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="preprocessor">#if FREEBSD</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span>    <span class="keyword">typedef</span> off_t MprOffset;
<a name="l00632"></a>00632     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulong;
<a name="l00633"></a>00633     <span class="keyword">typedef</span> intptr_t pint;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635     __extension__ <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
<a name="l00636"></a>00636     __extension__ <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> uint64;
<a name="l00637"></a>00637 <span class="preprocessor">    #define INT64(x) (x##LL)</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span>
<a name="l00639"></a>00639 <span class="preprocessor">    #define closesocket(x)  close(x)</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BINARY      ""</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        ""</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span><span class="preprocessor">    #define SOCKET_ERROR    -1</span>
<a name="l00645"></a>00645 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DLL_EXT     ".dylib"</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span><span class="preprocessor">    #define __WALL          0x40000000</span>
<a name="l00647"></a>00647 <span class="preprocessor"></span><span class="preprocessor">    #define PTHREAD_MUTEX_RECURSIVE_NP  PTHREAD_MUTEX_RECURSIVE</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span>
<a name="l00649"></a>00649 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00650"></a>00650 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       MAXFLOAT</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>
<a name="l00653"></a>00653 <span class="preprocessor">    #define CLD_EXITED 1</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span><span class="preprocessor">    #define CLD_KILLED 2</span>
<a name="l00655"></a>00655 <span class="preprocessor"></span><span class="preprocessor">    #define LD_LIBRARY_PATH "LD_LIBRARY_PATH"</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>
<a name="l00657"></a>00657 <span class="preprocessor">#endif </span><span class="comment">/* FREEBSD */</span>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="comment">/*</span>
<a name="l00660"></a>00660 <span class="comment"> *  All windows like systems. Includes WINCE.</span>
<a name="l00661"></a>00661 <span class="comment"> */</span>
<a name="l00662"></a>00662 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uint;
<a name="l00664"></a>00664     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulong;
<a name="l00665"></a>00665     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ushort;
<a name="l00666"></a>00666     <span class="keyword">typedef</span> __int64 int64;
<a name="l00667"></a>00667     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> __int64 uint64;
<a name="l00668"></a>00668     <span class="keyword">typedef</span> int64   MprOffset;
<a name="l00669"></a>00669     <span class="keyword">typedef</span> <span class="keywordtype">int</span>     uid_t;
<a name="l00670"></a>00670     <span class="keyword">typedef</span> <span class="keywordtype">void</span>    *handle;
<a name="l00671"></a>00671     <span class="keyword">typedef</span> <span class="keywordtype">char</span>    *caddr_t;
<a name="l00672"></a>00672     <span class="keyword">typedef</span> <span class="keywordtype">long</span>    pid_t;
<a name="l00673"></a>00673     <span class="keyword">typedef</span> <span class="keywordtype">int</span>     gid_t;
<a name="l00674"></a>00674     <span class="keyword">typedef</span> ushort  mode_t;
<a name="l00675"></a>00675     <span class="keyword">typedef</span> <span class="keywordtype">void</span>    *siginfo_t;
<a name="l00676"></a>00676     <span class="keyword">typedef</span> <span class="keywordtype">int</span>     socklen_t;
<a name="l00677"></a>00677 <span class="preprocessor">    #if WINCE</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">int</span> pint;
<a name="l00679"></a>00679 <span class="preprocessor">    #else</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>        <span class="keyword">typedef</span> intptr_t pint;
<a name="l00681"></a>00681 <span class="preprocessor">    #endif</span>
<a name="l00682"></a>00682 <span class="preprocessor"></span>
<a name="l00683"></a>00683     <span class="keyword">struct </span>timezone {
<a name="l00684"></a>00684       <span class="keywordtype">int</span>  tz_minuteswest;      <span class="comment">/* minutes W of Greenwich */</span>
<a name="l00685"></a>00685       <span class="keywordtype">int</span>  tz_dsttime;          <span class="comment">/* type of dst correction */</span>
<a name="l00686"></a>00686     };
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 <span class="preprocessor">    #define HAVE_SOCKLEN_T</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span><span class="preprocessor">    #define INT64(x) (x##i64)</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span><span class="preprocessor">    #define UINT64(x) (x##Ui64)</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span><span class="preprocessor">    #define MSG_NOSIGNAL    0</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BINARY      "b"</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        "t"</span>
<a name="l00694"></a>00694 <span class="preprocessor"></span>
<a name="l00695"></a>00695 <span class="preprocessor">    #if !WINCE</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span><span class="preprocessor">    #define access      _access</span>
<a name="l00697"></a>00697 <span class="preprocessor"></span><span class="preprocessor">    #define chdir       _chdir</span>
<a name="l00698"></a>00698 <span class="preprocessor"></span><span class="preprocessor">    #define close       _close</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span><span class="preprocessor">    #define fileno      _fileno</span>
<a name="l00700"></a>00700 <span class="preprocessor"></span><span class="preprocessor">    #define fstat       _fstat</span>
<a name="l00701"></a>00701 <span class="preprocessor"></span><span class="preprocessor">    #define getcwd      _getcwd</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span><span class="preprocessor">    #define getpid      _getpid</span>
<a name="l00703"></a>00703 <span class="preprocessor"></span><span class="preprocessor">    #define gettimezone _gettimezone</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span><span class="preprocessor">    #define lseek       _lseek</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span><span class="preprocessor">    #define mkdir(a,b)  _mkdir(a)</span>
<a name="l00706"></a>00706 <span class="preprocessor"></span><span class="preprocessor">    #define open        _open</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span><span class="preprocessor">    #define putenv      _putenv</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span><span class="preprocessor">    #define read        _read</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span><span class="preprocessor">    #define rmdir(a)    _rmdir(a)</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span><span class="preprocessor">    #define stat        _stat</span>
<a name="l00711"></a>00711 <span class="preprocessor"></span><span class="preprocessor">    #define strdup      _strdup</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span><span class="preprocessor">    #define umask       _umask</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span><span class="preprocessor">    #define unlink      _unlink</span>
<a name="l00714"></a>00714 <span class="preprocessor"></span><span class="preprocessor">    #define write       _write</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00716"></a>00716 <span class="preprocessor"></span>    
<a name="l00717"></a>00717 <span class="preprocessor">    #define MPR_TEXT    "t"</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span>
<a name="l00719"></a>00719 <span class="preprocessor">    #ifndef R_OK</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span><span class="preprocessor">    #define R_OK    4</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span><span class="preprocessor">    #ifndef W_OK</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span><span class="preprocessor">    #define W_OK    2</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span><span class="preprocessor">    #ifndef X_OK</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span><span class="preprocessor">    #define X_OK    4</span>
<a name="l00727"></a>00727 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span><span class="preprocessor">    #ifndef F_OK</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span><span class="preprocessor">    #define F_OK    0</span>
<a name="l00730"></a>00730 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732 <span class="preprocessor">    #define EPERM           1</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span><span class="preprocessor">    #define ENOENT          2</span>
<a name="l00734"></a>00734 <span class="preprocessor"></span><span class="preprocessor">    #define ESRCH           3</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span><span class="preprocessor">    #define EINTR           4</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span><span class="preprocessor">    #define EIO             5</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span><span class="preprocessor">    #define ENXIO           6</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span><span class="preprocessor">    #define E2BIG           7</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span><span class="preprocessor">    #define ENOEXEC         8</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span><span class="preprocessor">    #define EBADF           9</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span><span class="preprocessor">    #define ECHILD          10</span>
<a name="l00742"></a>00742 <span class="preprocessor"></span><span class="preprocessor">    #define EAGAIN          11</span>
<a name="l00743"></a>00743 <span class="preprocessor"></span>
<a name="l00744"></a>00744     <span class="comment">/*</span>
<a name="l00745"></a>00745 <span class="comment">     *  VS 2011 defines these</span>
<a name="l00746"></a>00746 <span class="comment">     */</span>
<a name="l00747"></a>00747 <span class="preprocessor">    #ifndef EWOULDBLOCK</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span><span class="preprocessor">    #define EWOULDBLOCK     EAGAIN</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span><span class="preprocessor">    #define EINPROGRESS     36</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span><span class="preprocessor">    #define EALREADY        37</span>
<a name="l00751"></a>00751 <span class="preprocessor"></span><span class="preprocessor">    #define ENETDOWN        43</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span><span class="preprocessor">    #define ECONNRESET      44</span>
<a name="l00753"></a>00753 <span class="preprocessor"></span><span class="preprocessor">    #define ECONNREFUSED    45</span>
<a name="l00754"></a>00754 <span class="preprocessor"></span><span class="preprocessor">    #define EADDRNOTAVAIL   49</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span><span class="preprocessor">    #define EISCONN         56</span>
<a name="l00756"></a>00756 <span class="preprocessor"></span><span class="preprocessor">    #define EADDRINUSE      46</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span><span class="preprocessor">    #define ENETUNREACH     51</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span><span class="preprocessor">    #define ECONNABORTED    53</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span>
<a name="l00761"></a>00761 <span class="preprocessor">    #define ENOMEM          12</span>
<a name="l00762"></a>00762 <span class="preprocessor"></span><span class="preprocessor">    #define EACCES          13</span>
<a name="l00763"></a>00763 <span class="preprocessor"></span><span class="preprocessor">    #define EFAULT          14</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span><span class="preprocessor">    #define EOSERR          15</span>
<a name="l00765"></a>00765 <span class="preprocessor"></span><span class="preprocessor">    #define EBUSY           16</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span><span class="preprocessor">    #define EEXIST          17</span>
<a name="l00767"></a>00767 <span class="preprocessor"></span><span class="preprocessor">    #define EXDEV           18</span>
<a name="l00768"></a>00768 <span class="preprocessor"></span><span class="preprocessor">    #define ENODEV          19</span>
<a name="l00769"></a>00769 <span class="preprocessor"></span><span class="preprocessor">    #define ENOTDIR         20</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span><span class="preprocessor">    #define EISDIR          21</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span><span class="preprocessor">    #define EINVAL          22</span>
<a name="l00772"></a>00772 <span class="preprocessor"></span><span class="preprocessor">    #define ENFILE          23</span>
<a name="l00773"></a>00773 <span class="preprocessor"></span><span class="preprocessor">    #define EMFILE          24</span>
<a name="l00774"></a>00774 <span class="preprocessor"></span><span class="preprocessor">    #define ENOTTY          25</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span><span class="preprocessor">    #define EFBIG           27</span>
<a name="l00776"></a>00776 <span class="preprocessor"></span><span class="preprocessor">    #define ENOSPC          28</span>
<a name="l00777"></a>00777 <span class="preprocessor"></span><span class="preprocessor">    #define ESPIPE          29</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span><span class="preprocessor">    #define EROFS           30</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span><span class="preprocessor">    #define EMLINK          31</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span><span class="preprocessor">    #define EPIPE           32</span>
<a name="l00781"></a>00781 <span class="preprocessor"></span><span class="preprocessor">    #define EDOM            33</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span><span class="preprocessor">    #define ERANGE          34</span>
<a name="l00783"></a>00783 <span class="preprocessor"></span>
<a name="l00784"></a>00784 <span class="preprocessor">    #undef SHUT_RDWR</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span><span class="preprocessor">    #define SHUT_RDWR           2</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span>    
<a name="l00787"></a>00787 <span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       DBL_MAX</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span><span class="preprocessor">#ifndef FILE_FLAG_FIRST_PIPE_INSTANCE</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span><span class="preprocessor">    #define FILE_FLAG_FIRST_PIPE_INSTANCE   0x00080000</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00793"></a>00793 <span class="preprocessor"></span>
<a name="l00794"></a>00794 <span class="preprocessor">    #define SET_SOCKOPT_CAST cchar*</span>
<a name="l00795"></a>00795 <span class="preprocessor"></span><span class="preprocessor">    #define inline __inline</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span><span class="preprocessor">    #define chmod _chmod</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span><span class="preprocessor">    #define isNan(f) (_isnan(f))</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>
<a name="l00799"></a>00799     <span class="comment">/*</span>
<a name="l00800"></a>00800 <span class="comment">     *  PHP can't handle these</span>
<a name="l00801"></a>00801 <span class="comment">     */</span>
<a name="l00802"></a>00802 <span class="preprocessor">    #if !BUILDING_PHP</span>
<a name="l00803"></a>00803 <span class="preprocessor"></span><span class="preprocessor">        #define popen _popen</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span><span class="preprocessor">        #define pclose _pclose</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span>
<a name="l00807"></a>00807     <span class="comment">/*</span>
<a name="l00808"></a>00808 <span class="comment">     *  When time began</span>
<a name="l00809"></a>00809 <span class="comment">     */</span>
<a name="l00810"></a>00810 <span class="preprocessor">    #define TIME_GENESIS UINT64(11644473600000000)</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>
<a name="l00812"></a>00812     <span class="keyword">extern</span> <span class="keywordtype">void</span>     srand48(<span class="keywordtype">long</span>);
<a name="l00813"></a>00813     <span class="keyword">extern</span> <span class="keywordtype">long</span>     lrand48(<span class="keywordtype">void</span>);
<a name="l00814"></a>00814     <span class="keyword">extern</span> <span class="keywordtype">long</span>     ulimit(<span class="keywordtype">int</span>, ...);
<a name="l00815"></a>00815     <span class="keyword">extern</span> <span class="keywordtype">long</span>     nap(<span class="keywordtype">long</span>);
<a name="l00816"></a>00816     <span class="keyword">extern</span> <span class="keywordtype">int</span>      getuid(<span class="keywordtype">void</span>);
<a name="l00817"></a>00817     <span class="keyword">extern</span> <span class="keywordtype">int</span>      geteuid(<span class="keywordtype">void</span>);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="preprocessor">#endif </span><span class="comment">/* WIN_LIKE */</span>
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="preprocessor">#if WINCE</span>
<a name="l00823"></a>00823 <span class="preprocessor"></span>
<a name="l00824"></a>00824     <span class="keyword">typedef</span> <span class="keywordtype">void</span> FILE;
<a name="l00825"></a>00825     <span class="keyword">typedef</span> <span class="keywordtype">int</span> off_t;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     <span class="keyword">struct </span>stat {
<a name="l00828"></a>00828         <span class="keywordtype">int</span>     st_dev;
<a name="l00829"></a>00829         <span class="keywordtype">int</span>     st_ino;
<a name="l00830"></a>00830         ushort  st_mode;
<a name="l00831"></a>00831         <span class="keywordtype">short</span>   st_nlink;
<a name="l00832"></a>00832         <span class="keywordtype">short</span>   st_uid;
<a name="l00833"></a>00833         <span class="keywordtype">short</span>   st_gid;
<a name="l00834"></a>00834         <span class="keywordtype">int</span>     st_rdev;
<a name="l00835"></a>00835         <span class="keywordtype">long</span>    st_size;
<a name="l00836"></a>00836         time_t  st_atime;
<a name="l00837"></a>00837         time_t  st_mtime;
<a name="l00838"></a>00838         time_t  st_ctime;
<a name="l00839"></a>00839     };
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="preprocessor">    #ifndef EOF</span>
<a name="l00842"></a>00842 <span class="preprocessor"></span><span class="preprocessor">        #define EOF         -1</span>
<a name="l00843"></a>00843 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>
<a name="l00845"></a>00845 <span class="preprocessor">    #define O_RDONLY        0</span>
<a name="l00846"></a>00846 <span class="preprocessor"></span><span class="preprocessor">    #define O_WRONLY        1</span>
<a name="l00847"></a>00847 <span class="preprocessor"></span><span class="preprocessor">    #define O_RDWR          2</span>
<a name="l00848"></a>00848 <span class="preprocessor"></span><span class="preprocessor">    #define O_NDELAY        0x4</span>
<a name="l00849"></a>00849 <span class="preprocessor"></span><span class="preprocessor">    #define O_NONBLOCK      0x4</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span><span class="preprocessor">    #define O_APPEND        0x8</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span><span class="preprocessor">    #define O_CREAT         0x100</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span><span class="preprocessor">    #define O_TRUNC         0x200</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0x400</span>
<a name="l00854"></a>00854 <span class="preprocessor"></span><span class="preprocessor">    #define O_EXCL          0x800</span>
<a name="l00855"></a>00855 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0x1000</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>
<a name="l00857"></a>00857     <span class="comment">/*</span>
<a name="l00858"></a>00858 <span class="comment">     *  stat flags</span>
<a name="l00859"></a>00859 <span class="comment">     */</span>
<a name="l00860"></a>00860 <span class="preprocessor">    #define S_IFMT          0170000 </span>
<a name="l00861"></a>00861 <span class="preprocessor"></span><span class="preprocessor">    #define S_IFDIR         0040000</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span><span class="preprocessor">    #define S_IFCHR         0020000         </span><span class="comment">/* character special */</span>
<a name="l00863"></a>00863 <span class="preprocessor">    #define S_IFIFO         0010000</span>
<a name="l00864"></a>00864 <span class="preprocessor"></span><span class="preprocessor">    #define S_IFREG         0100000</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span><span class="preprocessor">    #define S_IREAD         0000400</span>
<a name="l00866"></a>00866 <span class="preprocessor"></span><span class="preprocessor">    #define S_IWRITE        0000200</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span><span class="preprocessor">    #define S_IEXEC         0000100</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span>
<a name="l00869"></a>00869 <span class="preprocessor">    #ifndef S_ISDIR</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span><span class="preprocessor">        #define S_ISDIR(X) (((X) &amp; S_IFMT) == S_IFDIR)</span>
<a name="l00871"></a>00871 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00872"></a>00872 <span class="preprocessor"></span><span class="preprocessor">    #ifndef S_ISREG</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span><span class="preprocessor">        #define S_ISREG(X) (((X) &amp; S_IFMT) == S_IFREG)</span>
<a name="l00874"></a>00874 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>
<a name="l00876"></a>00876 <span class="preprocessor">    #define STARTF_USESHOWWINDOW 0</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span><span class="preprocessor">    #define STARTF_USESTDHANDLES 0</span>
<a name="l00878"></a>00878 <span class="preprocessor"></span>
<a name="l00879"></a>00879     <span class="comment">/*</span>
<a name="l00880"></a>00880 <span class="comment">     *  Tunable parameters</span>
<a name="l00881"></a>00881 <span class="comment">     */</span>
<a name="l00882"></a>00882 <span class="preprocessor">    #define     BUFSIZ      MPR_BUFSIZE</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span><span class="preprocessor">    #define     PATHSIZE    MPR_MAX_PATH</span>
<a name="l00884"></a>00884 <span class="preprocessor"></span><span class="preprocessor">    #define gethostbyname2(a,b) gethostbyname(a)</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>
<a name="l00886"></a>00886     <span class="keyword">extern</span> <span class="keywordtype">int</span> access(cchar *filename, <span class="keywordtype">int</span> flags);
<a name="l00887"></a>00887     <span class="keyword">extern</span> <span class="keywordtype">int</span> chdir(cchar * dirname);
<a name="l00888"></a>00888     <span class="keyword">extern</span> <span class="keywordtype">int</span> chmod(cchar *path, <span class="keywordtype">int</span> mode);
<a name="l00889"></a>00889     <span class="keyword">extern</span> <span class="keywordtype">int</span> close(<span class="keywordtype">int</span> handle);
<a name="l00890"></a>00890     <span class="keyword">extern</span> <span class="keywordtype">void</span> exit(<span class="keywordtype">int</span> status);
<a name="l00891"></a>00891     <span class="keyword">extern</span> <span class="keywordtype">long</span> _get_osfhandle(<span class="keywordtype">int</span> handle);
<a name="l00892"></a>00892     <span class="keyword">extern</span> <span class="keywordtype">char</span> *getcwd(<span class="keywordtype">char</span>* buffer, <span class="keywordtype">int</span> maxlen);
<a name="l00893"></a>00893     <span class="keyword">extern</span> <span class="keywordtype">char</span> *getenv(cchar *charstuff);
<a name="l00894"></a>00894     <span class="keyword">extern</span> uint getpid();
<a name="l00895"></a>00895     <span class="keyword">extern</span> <span class="keywordtype">long</span> lseek(<span class="keywordtype">int</span> handle, <span class="keywordtype">long</span> offset, <span class="keywordtype">int</span> origin);
<a name="l00896"></a>00896     <span class="keyword">extern</span> <span class="keywordtype">int</span> mkdir(cchar *dir, <span class="keywordtype">int</span> mode);
<a name="l00897"></a>00897     <span class="keyword">extern</span> time_t mktime(<span class="keyword">struct</span> tm *pt);
<a name="l00898"></a>00898     <span class="keyword">extern</span> <span class="keywordtype">int</span> _open_osfhandle(<span class="keywordtype">int</span> *handle, <span class="keywordtype">int</span> flags);
<a name="l00899"></a>00899     <span class="keyword">extern</span> uint open(cchar *file, <span class="keywordtype">int</span> mode,...);
<a name="l00900"></a>00900     <span class="keyword">extern</span> <span class="keywordtype">int</span> read(<span class="keywordtype">int</span> handle, <span class="keywordtype">void</span> *buffer, uint count);
<a name="l00901"></a>00901     <span class="keyword">extern</span> <span class="keywordtype">int</span> rename(cchar *from, cchar *to);
<a name="l00902"></a>00902     <span class="keyword">extern</span> <span class="keywordtype">int</span> rmdir(cchar * dir);
<a name="l00903"></a>00903     <span class="keyword">extern</span> uint sleep(uint secs);
<a name="l00904"></a>00904     <span class="keyword">extern</span> <span class="keywordtype">int</span> stat(cchar *path, <span class="keyword">struct</span> stat *stat);
<a name="l00905"></a>00905     <span class="keyword">extern</span> <span class="keywordtype">char</span> *strdup(<span class="keywordtype">char</span> *s);
<a name="l00906"></a>00906     <span class="keyword">extern</span> <span class="keywordtype">int</span> write(<span class="keywordtype">int</span> handle, cvoid *buffer, uint count);
<a name="l00907"></a>00907     <span class="keyword">extern</span> <span class="keywordtype">int</span> umask(<span class="keywordtype">int</span> mode);
<a name="l00908"></a>00908     <span class="keyword">extern</span> <span class="keywordtype">int</span> unlink(cchar *path);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="keyword">extern</span> <span class="keywordtype">int</span> errno;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 <span class="preprocessor">    #undef CreateFile</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span><span class="preprocessor">    #define CreateFile CreateFileA</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>    WINBASEAPI HANDLE WINAPI CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
<a name="l00915"></a>00915         LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
<a name="l00916"></a>00916         HANDLE hTemplateFile);
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="preprocessor">    #undef CreateProcess</span>
<a name="l00919"></a>00919 <span class="preprocessor"></span><span class="preprocessor">    #define CreateProcess CreateProcessA</span>
<a name="l00920"></a>00920 <span class="preprocessor"></span>
<a name="l00921"></a>00921 <span class="preprocessor">    #undef FindFirstFile</span>
<a name="l00922"></a>00922 <span class="preprocessor"></span><span class="preprocessor">    #define FindFirstFile FindFirstFileA</span>
<a name="l00923"></a>00923 <span class="preprocessor"></span>    WINBASEAPI HANDLE WINAPI FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="preprocessor">    #undef FindNextFile</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span><span class="preprocessor">    #define FindNextFile FindNextFileA</span>
<a name="l00927"></a>00927 <span class="preprocessor"></span>    WINBASEAPI BOOL WINAPI FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="preprocessor">    #undef GetModuleFileName</span>
<a name="l00930"></a>00930 <span class="preprocessor"></span><span class="preprocessor">    #define GetModuleFileName GetModuleFileNameA</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span>    WINBASEAPI DWORD WINAPI GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933 <span class="preprocessor">    #undef GetModuleHandle</span>
<a name="l00934"></a>00934 <span class="preprocessor"></span><span class="preprocessor">    #define GetModuleHandle GetModuleHandleA</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span>    WINBASEAPI HMODULE WINAPI GetModuleHandleA(LPCSTR lpModuleName);
<a name="l00936"></a>00936 
<a name="l00937"></a>00937 <span class="preprocessor">    #undef GetProcAddress</span>
<a name="l00938"></a>00938 <span class="preprocessor"></span><span class="preprocessor">    #define GetProcAddress GetProcAddressA</span>
<a name="l00939"></a>00939 <span class="preprocessor"></span>    <span class="comment">// extern FARPROC GetProcAddressA(HMODULE module, LPCSTR name);</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="preprocessor">    #undef GetFileAttributes</span>
<a name="l00942"></a>00942 <span class="preprocessor"></span><span class="preprocessor">    #define GetFileAttributes GetFileAttributesA</span>
<a name="l00943"></a>00943 <span class="preprocessor"></span>    <span class="keyword">extern</span> DWORD GetFileAttributesA(cchar *path);
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <span class="keyword">extern</span> <span class="keywordtype">void</span> GetSystemTimeAsFileTime(FILETIME *ft);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="preprocessor">    #undef LoadLibrary</span>
<a name="l00948"></a>00948 <span class="preprocessor"></span><span class="preprocessor">    #define LoadLibrary LoadLibraryA</span>
<a name="l00949"></a>00949 <span class="preprocessor"></span>    HINSTANCE WINAPI LoadLibraryA(LPCSTR lpLibFileName);
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="preprocessor">    #define WSAGetLastError GetLastError</span>
<a name="l00952"></a>00952 <span class="preprocessor"></span>
<a name="l00953"></a>00953 <span class="preprocessor">    #define _get_timezone getTimezone</span>
<a name="l00954"></a>00954 <span class="preprocessor"></span>    <span class="keyword">extern</span> <span class="keywordtype">int</span> getTimezone(<span class="keywordtype">int</span> *secs);
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <span class="keyword">extern</span> <span class="keyword">struct </span>tm *localtime_r(<span class="keyword">const</span> time_t *when, <span class="keyword">struct</span> tm *tp);
<a name="l00957"></a>00957     <span class="keyword">extern</span> <span class="keyword">struct </span>tm *gmtime_r(<span class="keyword">const</span> time_t *t, <span class="keyword">struct</span> tm *tp);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="preprocessor">#endif </span><span class="comment">/* WINCE */</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="preprocessor">#if SOLARIS</span>
<a name="l00963"></a>00963 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00964"></a>00964 <span class="comment">     *  TODO -- This is old and needs updating to work</span>
<a name="l00965"></a>00965 <span class="comment">     */</span>
<a name="l00966"></a>00966     <span class="keyword">typedef</span> off_t MprOffset;
<a name="l00967"></a>00967     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
<a name="l00968"></a>00968     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> uint64;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970 <span class="preprocessor">    #define INT64(x) (x##LL)</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span><span class="preprocessor">    #define UINT64(x) (x##ULL)</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>
<a name="l00973"></a>00973 <span class="preprocessor">    #define closesocket(x)  close(x)</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BINARY      ""</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TEXT        ""</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span><span class="preprocessor">    #define O_BINARY        0</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span><span class="preprocessor">    #define O_TEXT          0</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span><span class="preprocessor">    #define SOCKET_ERROR    -1</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span><span class="preprocessor">    #define MSG_NOSIGNAL    0</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span><span class="preprocessor">    #define INADDR_NONE     ((in_addr_t) 0xffffffff)</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span><span class="preprocessor">    #define __WALL  0</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span><span class="preprocessor">    #define PTHREAD_MUTEX_RECURSIVE_NP  PTHREAD_MUTEX_RECURSIVE</span>
<a name="l00983"></a>00983 <span class="preprocessor"></span><span class="preprocessor">    #define LD_LIBRARY_PATH "LD_LIBRARY_PATH"</span>
<a name="l00984"></a>00984 <span class="preprocessor"></span><span class="preprocessor">#if BLD_FEATURE_FLOATING_POINT</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span><span class="preprocessor">    #define MAX_FLOAT       MAXFLOAT</span>
<a name="l00986"></a>00986 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00987"></a>00987 <span class="preprocessor"></span>
<a name="l00988"></a>00988 <span class="preprocessor">#endif </span><span class="comment">/* SOLARIS */</span>
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00991"></a>00991 <span class="preprocessor"></span>}
<a name="l00992"></a>00992 <span class="preprocessor">#endif</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span>
<a name="l00994"></a>00994 <span class="preprocessor">#endif </span><span class="comment">/* _h_MPR_OS_HDRS */</span>
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="comment">/*</span>
<a name="l00997"></a>00997 <span class="comment"> *  @copy   default</span>
<a name="l00998"></a>00998 <span class="comment"> *  </span>
<a name="l00999"></a>00999 <span class="comment"> *  Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.</span>
<a name="l01000"></a>01000 <span class="comment"> *  Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.</span>
<a name="l01001"></a>01001 <span class="comment"> *  </span>
<a name="l01002"></a>01002 <span class="comment"> *  This software is distributed under commercial and open source licenses.</span>
<a name="l01003"></a>01003 <span class="comment"> *  You may use the GPL open source license described below or you may acquire </span>
<a name="l01004"></a>01004 <span class="comment"> *  a commercial license from Embedthis Software. You agree to be fully bound </span>
<a name="l01005"></a>01005 <span class="comment"> *  by the terms of either license. Consult the LICENSE.TXT distributed with </span>
<a name="l01006"></a>01006 <span class="comment"> *  this software for full details.</span>
<a name="l01007"></a>01007 <span class="comment"> *  </span>
<a name="l01008"></a>01008 <span class="comment"> *  This software is open source; you can redistribute it and/or modify it </span>
<a name="l01009"></a>01009 <span class="comment"> *  under the terms of the GNU General Public License as published by the </span>
<a name="l01010"></a>01010 <span class="comment"> *  Free Software Foundation; either version 2 of the License, or (at your </span>
<a name="l01011"></a>01011 <span class="comment"> *  option) any later version. See the GNU General Public License for more </span>
<a name="l01012"></a>01012 <span class="comment"> *  details at: http://www.embedthis.com/downloads/gplLicense.html</span>
<a name="l01013"></a>01013 <span class="comment"> *  </span>
<a name="l01014"></a>01014 <span class="comment"> *  This program is distributed WITHOUT ANY WARRANTY; without even the </span>
<a name="l01015"></a>01015 <span class="comment"> *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </span>
<a name="l01016"></a>01016 <span class="comment"> *  </span>
<a name="l01017"></a>01017 <span class="comment"> *  This GPL license does NOT permit incorporating this software into </span>
<a name="l01018"></a>01018 <span class="comment"> *  proprietary programs. If you are unable to comply with the GPL, you must</span>
<a name="l01019"></a>01019 <span class="comment"> *  acquire a commercial license to use this software. Commercial licenses </span>
<a name="l01020"></a>01020 <span class="comment"> *  for this software and support services are available from Embedthis </span>
<a name="l01021"></a>01021 <span class="comment"> *  Software at http://www.embedthis.com </span>
<a name="l01022"></a>01022 <span class="comment"> *  </span>
<a name="l01023"></a>01023 <span class="comment"> *  Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=8 ts=8 expandtab

    @end</span>
<a name="l01024"></a>01024 <span class="comment"> */</span>
<a name="l01025"></a>01025 <span class="comment">/************************************************************************/</span>
<a name="l01026"></a>01026 <span class="comment">/*</span>
<a name="l01027"></a>01027 <span class="comment"> *  End of file "../src/include/mprOs.h"</span>
<a name="l01028"></a>01028 <span class="comment"> */</span>
<a name="l01029"></a>01029 <span class="comment">/************************************************************************/</span>
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="comment">/************************************************************************/</span>
<a name="l01034"></a>01034 <span class="comment">/*</span>
<a name="l01035"></a>01035 <span class="comment"> *  Start of file "../src/include/mprTune.h"</span>
<a name="l01036"></a>01036 <span class="comment"> */</span>
<a name="l01037"></a>01037 <span class="comment">/************************************************************************/</span>
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="comment">/*</span>
<a name="l01040"></a>01040 <span class="comment"> *  mprTune.h - Header for the Multithreaded Portable Runtime (MPR) Base.</span>
<a name="l01041"></a>01041 <span class="comment"> *</span>
<a name="l01042"></a>01042 <span class="comment"> *  Copyright (c) All Rights Reserved. See details at the end of the file.</span>
<a name="l01043"></a>01043 <span class="comment"> */</span>
<a name="l01044"></a>01044 
<a name="l01045"></a>01045 <span class="comment">/*</span>
<a name="l01046"></a>01046 <span class="comment"> *  See mpr.dox for additional documentation.</span>
<a name="l01047"></a>01047 <span class="comment"> */</span>
<a name="l01048"></a>01048 
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="preprocessor">#ifndef _h_MPR_TUNE</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span><span class="preprocessor">#define _h_MPR_TUNE 1</span>
<a name="l01052"></a>01052 <span class="preprocessor"></span>
<a name="l01053"></a>01053 
<a name="l01054"></a>01054 <span class="preprocessor">#include    "buildConfig.h"</span>
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l01057"></a>01057 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l01058"></a>01058 <span class="preprocessor">#endif</span>
<a name="l01059"></a>01059 <span class="preprocessor"></span>
<a name="l01060"></a>01060 <span class="comment">/*</span>
<a name="l01061"></a>01061 <span class="comment"> *  Build tuning</span>
<a name="l01062"></a>01062 <span class="comment"> */</span>
<a name="l01063"></a>01063 <span class="preprocessor">#define MPR_TUNE_SIZE       1       </span><span class="comment">/* Tune for size */</span>
<a name="l01064"></a>01064 <span class="preprocessor">#define MPR_TUNE_BALANCED   2       </span><span class="comment">/* Tune balancing speed and size */</span>
<a name="l01065"></a>01065 <span class="preprocessor">#define MPR_TUNE_SPEED      3       </span><span class="comment">/* Tune for speed */</span>
<a name="l01066"></a>01066 
<a name="l01067"></a>01067 <span class="preprocessor">#ifndef BLD_TUNE</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span><span class="preprocessor">#define BLD_TUNE MPR_TUNE_BALANCED</span>
<a name="l01069"></a>01069 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>
<a name="l01071"></a>01071 <span class="comment">/*</span>
<a name="l01072"></a>01072 <span class="comment"> *  Event notification mechanism</span>
<a name="l01073"></a>01073 <span class="comment"> */</span>
<a name="l01074"></a>01074 <span class="preprocessor">#if LINUX</span>
<a name="l01075"></a>01075 <span class="preprocessor"></span><span class="preprocessor">#define MPR_EVENT_EPOLL    1</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span><span class="preprocessor">#elif MACOSX || SOLARIS</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span><span class="preprocessor">#define MPR_EVENT_KQUEUE    1</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span><span class="preprocessor">#elif VXWORKS || WINCE</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span><span class="preprocessor">#define MPR_EVENT_SELECT    1</span>
<a name="l01080"></a>01080 <span class="preprocessor"></span><span class="preprocessor">#elif WIN</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span><span class="preprocessor">#define MPR_EVENT_ASYNC     1</span>
<a name="l01082"></a>01082 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01083"></a>01083 <span class="preprocessor"></span><span class="preprocessor">#define MPR_EVENT_POLL      1</span>
<a name="l01084"></a>01084 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>
<a name="l01086"></a>01086 <span class="preprocessor">#if BLD_TUNE == MPR_TUNE_SIZE || DOXYGEN</span>
<a name="l01087"></a>01087 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l01088"></a>01088 <span class="comment">     *  Squeeze mode optimizes to reduce memory usage</span>
<a name="l01089"></a>01089 <span class="comment">     */</span>
<a name="l01090"></a><a class="code" href="mpr_8h.html#6301f3ae68d98c76debdfea9b2ece4bc">01090</a> <span class="preprocessor">    #define MPR_MAX_FNAME           256         </span><span class="comment">/**&lt; Reasonable filename size */</span>
<a name="l01091"></a><a class="code" href="mpr_8h.html#06e26ea0168fbb293255ffdc62b288e0">01091</a> <span class="preprocessor">    #define MPR_MAX_PATH            512         </span><span class="comment">/**&lt; Reasonable path name size */</span>
<a name="l01092"></a><a class="code" href="mpr_8h.html#4b31c87cc1ce41278fae6a17c23e3199">01092</a> <span class="preprocessor">    #define MPR_MAX_URL             512         </span><span class="comment">/**&lt; Max URL size. Also request URL size. */</span>
<a name="l01093"></a><a class="code" href="mpr_8h.html#b682c50e795b73ee99bea8e24fc5c943">01093</a> <span class="preprocessor">    #define MPR_DEFAULT_STACK       (64 * 1024) </span><span class="comment">/**&lt; Default thread stack size (64K) */</span>
<a name="l01094"></a><a class="code" href="mpr_8h.html#ab279a1400259da3572a2fd2a8681623">01094</a> <span class="preprocessor">    #define MPR_MAX_STRING          1024        </span><span class="comment">/**&lt; Maximum (stack) string size */</span>
<a name="l01095"></a><a class="code" href="mpr_8h.html#7b06f41accf7c6527c8e29f0ce93bce4">01095</a> <span class="preprocessor">    #define MPR_DEFAULT_ALLOC       64          </span><span class="comment">/**&lt; Default small alloc size */</span>
<a name="l01096"></a><a class="code" href="mpr_8h.html#c984410ca2b9c805e56da89d0bfc6c6d">01096</a> <span class="preprocessor">    #define MPR_DEFAULT_HASH_SIZE   23          </span><span class="comment">/**&lt; Default size of hash table */</span> 
<a name="l01097"></a><a class="code" href="mpr_8h.html#d9fbd54076ade37688f1e5ca2784e271">01097</a> <span class="preprocessor">    #define MPR_MAX_ARGC            128         </span><span class="comment">/**&lt; Reasonable max of args */</span>
<a name="l01098"></a><a class="code" href="mpr_8h.html#9f0705ef414c63b94c34a8a4e0bb239a">01098</a> <span class="preprocessor">    #define MPR_MAX_LOG_STRING      512         </span><span class="comment">/**&lt; Maximum log message */</span>
<a name="l01099"></a><a class="code" href="mpr_8h.html#d11f870f279dc0ae25037aa94cfb7159">01099</a> <span class="preprocessor">    #define MPR_BUFSIZE             4096        </span><span class="comment">/**&lt; Reasonable size for buffers */</span>
<a name="l01100"></a><a class="code" href="mpr_8h.html#a2548e612d40219745d36809427d5fd0">01100</a> <span class="preprocessor">    #define MPR_BUF_INCR            4096        </span><span class="comment">/**&lt; Default buffer growth inc */</span>
<a name="l01101"></a><a class="code" href="mpr_8h.html#7c35c619d08e3fc977e60b9b3d0dee15">01101</a> <span class="preprocessor">    #define MPR_EPOLL_SIZE          32          </span><span class="comment">/**&lt; Epoll backlog */</span>
<a name="l01102"></a><a class="code" href="mpr_8h.html#bd8f55c7f348c463079b9e3da32f9a9d">01102</a> <span class="preprocessor">    #define MPR_MAX_BUF             4194304     </span><span class="comment">/**&lt; Max buffer size */</span>
<a name="l01103"></a><a class="code" href="mpr_8h.html#5ea34ea35e2d8b1a0be44e799fa4d2fb">01103</a> <span class="preprocessor">    #define MPR_XML_BUFSIZE         4096        </span><span class="comment">/**&lt; XML read buffer size */</span>
<a name="l01104"></a><a class="code" href="mpr_8h.html#e2d5fc1b9d658c93d2833e75ed45eb99">01104</a> <span class="preprocessor">    #define MPR_SSL_BUFSIZE         4096        </span><span class="comment">/**&lt; SSL has 16K max*/</span>
<a name="l01105"></a><a class="code" href="mpr_8h.html#4c5e08a31ad4866aee0214fe9177d5f4">01105</a> <span class="preprocessor">    #define MPR_LIST_INCR           8           </span><span class="comment">/**&lt; Default list growth inc */</span>
<a name="l01106"></a>01106 <span class="preprocessor">    #define MPR_FILES_HASH_SIZE     29          </span><span class="comment">/** Hash size for rom file system */</span>
<a name="l01107"></a>01107 <span class="preprocessor">    #define MPR_TIME_HASH_SIZE      67          </span><span class="comment">/** Hash size for time token lookup */</span>
<a name="l01108"></a>01108     
<a name="l01109"></a>01109 <span class="preprocessor">#elif BLD_TUNE == MPR_TUNE_BALANCED</span>
<a name="l01110"></a>01110 <span class="preprocessor"></span>    
<a name="l01111"></a>01111     <span class="comment">/*</span>
<a name="l01112"></a>01112 <span class="comment">     *  Tune balancing speed and size</span>
<a name="l01113"></a>01113 <span class="comment">     */</span>
<a name="l01114"></a>01114 <span class="preprocessor">    #define MPR_MAX_FNAME           256</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_PATH            1024</span>
<a name="l01116"></a>01116 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_URL             2048</span>
<a name="l01117"></a>01117 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_STACK       (128 * 1024)</span>
<a name="l01118"></a>01118 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_STRING          2048</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_ALLOC       256</span>
<a name="l01120"></a>01120 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_HASH_SIZE   43</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_ARGC            256</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_LOG_STRING      8192</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BUFSIZE             4096</span>
<a name="l01124"></a>01124 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BUF_INCR            4096</span>
<a name="l01125"></a>01125 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_BUF             -1</span>
<a name="l01126"></a>01126 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_EPOLL_SIZE          64</span>
<a name="l01127"></a>01127 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_XML_BUFSIZE         4096</span>
<a name="l01128"></a>01128 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SSL_BUFSIZE         4096</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_LIST_INCR           16</span>
<a name="l01130"></a>01130 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_FILES_HASH_SIZE     61</span>
<a name="l01131"></a>01131 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TIME_HASH_SIZE      89</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>    
<a name="l01133"></a>01133 <span class="preprocessor">#else</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l01135"></a>01135 <span class="comment">     *  Tune for speed</span>
<a name="l01136"></a>01136 <span class="comment">     */</span>
<a name="l01137"></a>01137 <span class="preprocessor">    #define MPR_MAX_FNAME           1024</span>
<a name="l01138"></a>01138 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_PATH            2048</span>
<a name="l01139"></a>01139 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_URL             4096</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_STACK       (256 * 1024)</span>
<a name="l01141"></a>01141 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_STRING          4096</span>
<a name="l01142"></a>01142 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_ALLOC       512</span>
<a name="l01143"></a>01143 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_DEFAULT_HASH_SIZE   97</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_ARGC            512</span>
<a name="l01145"></a>01145 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_LOG_STRING      8192</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BUFSIZE             8192</span>
<a name="l01147"></a>01147 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAX_BUF             -1</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_EPOLL_SIZE          128</span>
<a name="l01149"></a>01149 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_XML_BUFSIZE         4096</span>
<a name="l01150"></a>01150 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SSL_BUFSIZE         8192</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_LIST_INCR           16</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_BUF_INCR            1024</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_FILES_HASH_SIZE     61</span>
<a name="l01154"></a>01154 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_TIME_HASH_SIZE      97</span>
<a name="l01155"></a>01155 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>
<a name="l01157"></a>01157 <span class="comment">/*</span>
<a name="l01158"></a>01158 <span class="comment"> *  Select wakeup port. Port can be any free port number. If this is not free, the MPR will use the next free port.</span>
<a name="l01159"></a>01159 <span class="comment"> */</span>
<a name="l01160"></a>01160 <span class="preprocessor">#define MPR_DEFAULT_BREAK_PORT  9473</span>
<a name="l01161"></a>01161 <span class="preprocessor"></span><span class="preprocessor">#define MPR_FD_MIN              32</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>
<a name="l01163"></a>01163 <span class="preprocessor">#if BLD_FEATURE_IPV6</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span><span class="preprocessor">#define MPR_MAX_IP_NAME         NI_MAXHOST      </span><span class="comment">/**&lt; Maximum size of a host name string */</span>
<a name="l01165"></a>01165 <span class="preprocessor">#define MPR_MAX_IP_ADDR         128             </span><span class="comment">/**&lt; Maximum size of an IP address */</span>
<a name="l01166"></a>01166 <span class="preprocessor">#define MPR_MAX_IP_PORT         6               </span><span class="comment">/**&lt; MMaximum size of a port number */</span>
<a name="l01167"></a>01167 <span class="preprocessor">#define MPR_MAX_IP_ADDR_PORT    (MPR_MAX_IP_ADDR + NI_MAXSERV)  </span><span class="comment">/**&lt; Maximum size of an IP address with port number */</span>
<a name="l01168"></a>01168 <span class="preprocessor">#else</span>
<a name="l01169"></a>01169 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01170"></a>01170 <span class="comment"> *  IPv4 support only</span>
<a name="l01171"></a>01171 <span class="comment"> */</span>
<a name="l01172"></a>01172 <span class="preprocessor">#define MPR_MAX_IP_NAME         128</span>
<a name="l01173"></a>01173 <span class="preprocessor"></span><span class="preprocessor">#define MPR_MAX_IP_ADDR         16</span>
<a name="l01174"></a>01174 <span class="preprocessor"></span><span class="preprocessor">#define MPR_MAX_IP_PORT         6</span>
<a name="l01175"></a>01175 <span class="preprocessor"></span><span class="preprocessor">#define MPR_MAX_IP_ADDR_PORT    32</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01177"></a>01177 <span class="preprocessor"></span>
<a name="l01178"></a>01178 <span class="comment">/*</span>
<a name="l01179"></a>01179 <span class="comment"> *  Signal sent on Unix to break out of a select call.</span>
<a name="l01180"></a>01180 <span class="comment"> */</span>
<a name="l01181"></a>01181 <span class="preprocessor">#define MPR_WAIT_SIGNAL         (SIGUSR2)</span>
<a name="l01182"></a>01182 <span class="preprocessor"></span>
<a name="l01183"></a>01183 <span class="comment">/*</span>
<a name="l01184"></a>01184 <span class="comment"> *  Socket event message</span>
<a name="l01185"></a>01185 <span class="comment"> */</span>
<a name="l01186"></a>01186 <span class="preprocessor">#define MPR_SOCKET_MESSAGE      (WM_USER + 32)</span>
<a name="l01187"></a>01187 <span class="preprocessor"></span>
<a name="l01188"></a>01188 <span class="comment">/*</span>
<a name="l01189"></a>01189 <span class="comment"> *  Priorities</span>
<a name="l01190"></a>01190 <span class="comment"> */</span>
<a name="l01191"></a><a class="code" href="mpr_8h.html#5e2e7058ae62846bc72aa87a94998e35">01191</a> <span class="preprocessor">#define MPR_BACKGROUND_PRIORITY 15          </span><span class="comment">/**&lt; May only get CPU if idle */</span>
<a name="l01192"></a>01192 <span class="preprocessor">#define MPR_LOW_PRIORITY        25</span>
<a name="l01193"></a><a class="code" href="mpr_8h.html#00253cececc72225524d098e29d552a9">01193</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_NORMAL_PRIORITY     50          </span><span class="comment">/**&lt; Normal (default) priority */</span>
<a name="l01194"></a>01194 <span class="preprocessor">#define MPR_HIGH_PRIORITY       75</span>
<a name="l01195"></a><a class="code" href="mpr_8h.html#e06415ae3af35c8ac27f34b10d3001e3">01195</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_CRITICAL_PRIORITY   99          </span><span class="comment">/**&lt; May not yield */</span>
<a name="l01196"></a>01196 
<a name="l01197"></a><a class="code" href="mpr_8h.html#2a99bacd6ebae3f038383bf28e9c9b80">01197</a> <span class="preprocessor">#define MPR_EVENT_PRIORITY      50          </span><span class="comment">/**&lt; Normal priority */</span> 
<a name="l01198"></a><a class="code" href="mpr_8h.html#1a46345d16dbc9d60b67e7418a2c2a09">01198</a> <span class="preprocessor">#define MPR_WORKER_PRIORITY     50          </span><span class="comment">/**&lt; Normal priority */</span>
<a name="l01199"></a><a class="code" href="mpr_8h.html#6072e168871ce4b65725049d214965a1">01199</a> <span class="preprocessor">#define MPR_REQUEST_PRIORITY    50          </span><span class="comment">/**&lt; Normal priority */</span>
<a name="l01200"></a>01200 
<a name="l01201"></a><a class="code" href="mpr_8h.html#3d29febaeaca5d39a1ad539c1a3b6225">01201</a> <span class="preprocessor">#define MPR_TICKS_PER_SEC       1000        </span><span class="comment">/**&lt; Time ticks per second */</span>
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 <span class="comment">/* </span>
<a name="l01204"></a>01204 <span class="comment"> *  Timeouts</span>
<a name="l01205"></a>01205 <span class="comment"> */</span>
<a name="l01206"></a><a class="code" href="mpr_8h.html#9900ec15eb1619e4a9bc5a675f0a4cdd">01206</a> <span class="preprocessor">#define MPR_TIMEOUT_CMD         60000       </span><span class="comment">/**&lt; Command Request timeout (60 sec) */</span>
<a name="l01207"></a><a class="code" href="mpr_8h.html#0cefcf294650f2254b1fcb335af931da">01207</a> <span class="preprocessor">#define MPR_TIMEOUT_SOCKETS     10000       </span><span class="comment">/**&lt; General sockets timeout */</span>
<a name="l01208"></a><a class="code" href="mpr_8h.html#7aac261496b3ad0f1adea76a959e34fd">01208</a> <span class="preprocessor">#define MPR_TIMEOUT_LOG_STAMP   3600000     </span><span class="comment">/**&lt; Time between log time stamps (1 hr) */</span>
<a name="l01209"></a><a class="code" href="mpr_8h.html#a2eb3f4af9584897ff6ec601fcca4c3c">01209</a> <span class="preprocessor">#define MPR_TIMEOUT_PRUNER      600000      </span><span class="comment">/**&lt; Time between pruner runs (10 min) */</span>
<a name="l01210"></a><a class="code" href="mpr_8h.html#edd536c5e56ec128b69e540bc2926dd3">01210</a> <span class="preprocessor">#define MPR_TIMEOUT_START_TASK  2000        </span><span class="comment">/**&lt; Time to start tasks running */</span>
<a name="l01211"></a><a class="code" href="mpr_8h.html#3607582e032513bfb634178e569f6340">01211</a> <span class="preprocessor">#define MPR_TIMEOUT_STOP_TASK   10000       </span><span class="comment">/**&lt; Time to stop or reap tasks */</span>
<a name="l01212"></a><a class="code" href="mpr_8h.html#c71168dee2c19a44b17981748e1127c3">01212</a> <span class="preprocessor">#define MPR_TIMEOUT_STOP_THREAD 10000       </span><span class="comment">/**&lt; Time to stop running threads */</span>
<a name="l01213"></a><a class="code" href="mpr_8h.html#1b16c71cdee0d3ca77efef483c13ee84">01213</a> <span class="preprocessor">#define MPR_TIMEOUT_STOP        5000        </span><span class="comment">/**&lt; Wait when stopping resources */</span>
<a name="l01214"></a><a class="code" href="mpr_8h.html#3a9a50e1c8d7de296f8d822c1ecc24d3">01214</a> <span class="preprocessor">#define MPR_TIMEOUT_LINGER      2000        </span><span class="comment">/**&lt; Close socket linger timeout */</span>
<a name="l01215"></a><a class="code" href="mpr_8h.html#cd2002df57aac80b02daa2f187cd4b4c">01215</a> <span class="preprocessor">#define MPR_TIMEOUT_HANDLER     10000        </span><span class="comment">/**&lt; Wait period when removing a wait handler */</span>
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment">/*</span>
<a name="l01219"></a>01219 <span class="comment"> *  Default thread counts</span>
<a name="l01220"></a>01220 <span class="comment"> */</span>
<a name="l01221"></a>01221 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD || DOXYGEN</span>
<a name="l01222"></a><a class="code" href="mpr_8h.html#73941169dddea56ea21e373e25d6f630">01222</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_DEFAULT_MIN_THREADS 0           </span><span class="comment">/**&lt; Default min threads */</span>
<a name="l01223"></a><a class="code" href="mpr_8h.html#efea53f554fcb794283095d3b96c34bd">01223</a> <span class="preprocessor">#define MPR_DEFAULT_MAX_THREADS 20          </span><span class="comment">/**&lt; Default max threads */</span>
<a name="l01224"></a>01224 <span class="preprocessor">#else</span>
<a name="l01225"></a>01225 <span class="preprocessor"></span><span class="preprocessor">#define MPR_DEFAULT_MIN_THREADS 0</span>
<a name="l01226"></a>01226 <span class="preprocessor"></span><span class="preprocessor">#define MPR_DEFAULT_MAX_THREADS 0</span>
<a name="l01227"></a>01227 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01228"></a>01228 <span class="preprocessor"></span>
<a name="l01229"></a>01229 <span class="comment">/*</span>
<a name="l01230"></a>01230 <span class="comment"> *  Debug control</span>
<a name="l01231"></a>01231 <span class="comment"> */</span>
<a name="l01232"></a>01232 <span class="preprocessor">#define MPR_MAX_BLOCKED_LOCKS   100         </span><span class="comment">/* Max threads blocked on lock */</span>
<a name="l01233"></a>01233 <span class="preprocessor">#define MPR_MAX_RECURSION       15          </span><span class="comment">/* Max recursion with one thread */</span>
<a name="l01234"></a>01234 <span class="preprocessor">#define MPR_MAX_LOCKS           512         </span><span class="comment">/* Total lock count max */</span>
<a name="l01235"></a>01235 <span class="preprocessor">#define MPR_MAX_LOCK_TIME       (60 * 1000) </span><span class="comment">/* Time in msec to hold a lock */</span>
<a name="l01236"></a>01236 
<a name="l01237"></a>01237 <span class="preprocessor">#define MPR_TIMER_TOLERANCE     2           </span><span class="comment">/* Used in timer calculations */</span>
<a name="l01238"></a>01238 <span class="preprocessor">#define MPR_CMD_TIMER_PERIOD    5000        </span><span class="comment">/* Check for expired commands */</span>
<a name="l01239"></a>01239 
<a name="l01240"></a>01240 <span class="comment">/*</span>
<a name="l01241"></a>01241 <span class="comment"> *  Events</span>
<a name="l01242"></a>01242 <span class="comment"> */</span>
<a name="l01243"></a>01243 <span class="preprocessor">#define MPR_EVENT_TIME_SLICE    20          </span><span class="comment">/* 20 msec */</span>
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 <span class="comment">/*</span>
<a name="l01246"></a>01246 <span class="comment"> *  Maximum number of files</span>
<a name="l01247"></a>01247 <span class="comment"> */</span>
<a name="l01248"></a>01248 <span class="preprocessor">#define MPR_MAX_FILE            256</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span>
<a name="l01250"></a>01250 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span>}
<a name="l01252"></a>01252 <span class="preprocessor">#endif</span>
<a name="l01253"></a>01253 <span class="preprocessor"></span>
<a name="l01254"></a>01254 <span class="preprocessor">#endif </span><span class="comment">/* _h_MPR_TUNE */</span>
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="comment">/*</span>
<a name="l01258"></a>01258 <span class="comment"> *  @copy   default</span>
<a name="l01259"></a>01259 <span class="comment"> *  </span>
<a name="l01260"></a>01260 <span class="comment"> *  Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.</span>
<a name="l01261"></a>01261 <span class="comment"> *  Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.</span>
<a name="l01262"></a>01262 <span class="comment"> *  </span>
<a name="l01263"></a>01263 <span class="comment"> *  This software is distributed under commercial and open source licenses.</span>
<a name="l01264"></a>01264 <span class="comment"> *  You may use the GPL open source license described below or you may acquire </span>
<a name="l01265"></a>01265 <span class="comment"> *  a commercial license from Embedthis Software. You agree to be fully bound </span>
<a name="l01266"></a>01266 <span class="comment"> *  by the terms of either license. Consult the LICENSE.TXT distributed with </span>
<a name="l01267"></a>01267 <span class="comment"> *  this software for full details.</span>
<a name="l01268"></a>01268 <span class="comment"> *  </span>
<a name="l01269"></a>01269 <span class="comment"> *  This software is open source; you can redistribute it and/or modify it </span>
<a name="l01270"></a>01270 <span class="comment"> *  under the terms of the GNU General Public License as published by the </span>
<a name="l01271"></a>01271 <span class="comment"> *  Free Software Foundation; either version 2 of the License, or (at your </span>
<a name="l01272"></a>01272 <span class="comment"> *  option) any later version. See the GNU General Public License for more </span>
<a name="l01273"></a>01273 <span class="comment"> *  details at: http://www.embedthis.com/downloads/gplLicense.html</span>
<a name="l01274"></a>01274 <span class="comment"> *  </span>
<a name="l01275"></a>01275 <span class="comment"> *  This program is distributed WITHOUT ANY WARRANTY; without even the </span>
<a name="l01276"></a>01276 <span class="comment"> *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </span>
<a name="l01277"></a>01277 <span class="comment"> *  </span>
<a name="l01278"></a>01278 <span class="comment"> *  This GPL license does NOT permit incorporating this software into </span>
<a name="l01279"></a>01279 <span class="comment"> *  proprietary programs. If you are unable to comply with the GPL, you must</span>
<a name="l01280"></a>01280 <span class="comment"> *  acquire a commercial license to use this software. Commercial licenses </span>
<a name="l01281"></a>01281 <span class="comment"> *  for this software and support services are available from Embedthis </span>
<a name="l01282"></a>01282 <span class="comment"> *  Software at http://www.embedthis.com </span>
<a name="l01283"></a>01283 <span class="comment"> *  </span>
<a name="l01284"></a>01284 <span class="comment"> *  Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=8 ts=8 expandtab

    @end</span>
<a name="l01285"></a>01285 <span class="comment"> */</span>
<a name="l01286"></a>01286 <span class="comment">/************************************************************************/</span>
<a name="l01287"></a>01287 <span class="comment">/*</span>
<a name="l01288"></a>01288 <span class="comment"> *  End of file "../src/include/mprTune.h"</span>
<a name="l01289"></a>01289 <span class="comment"> */</span>
<a name="l01290"></a>01290 <span class="comment">/************************************************************************/</span>
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 
<a name="l01294"></a>01294 <span class="comment">/************************************************************************/</span>
<a name="l01295"></a>01295 <span class="comment">/*</span>
<a name="l01296"></a>01296 <span class="comment"> *  Start of file "../src/include/mpr.h"</span>
<a name="l01297"></a>01297 <span class="comment"> */</span>
<a name="l01298"></a>01298 <span class="comment">/************************************************************************/</span>
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="comment">/*</span>
<a name="l01301"></a>01301 <span class="comment"> *  mpr.h -- Header for the Multithreaded Portable Runtime (MPR).</span>
<a name="l01302"></a>01302 <span class="comment"> *</span>
<a name="l01303"></a>01303 <span class="comment"> *  Copyright (c) All Rights Reserved. See details at the end of the file.</span>
<a name="l01304"></a>01304 <span class="comment"> */</span>
<a name="l01305"></a>01305 <span class="comment"></span>
<a name="l01306"></a>01306 <span class="comment">/**</span>
<a name="l01307"></a>01307 <span class="comment"> *  @file mpr.h</span>
<a name="l01308"></a>01308 <span class="comment"> *  Multithreaded Portable Runtime (MPR) is a portable runtime core for embedded applications.</span>
<a name="l01309"></a>01309 <span class="comment"> *  The MPR provides management for logging, error handling, events, files, http, memory, ssl, sockets, strings, </span>
<a name="l01310"></a>01310 <span class="comment"> *  xml parsing, and date/time functions. It also provides a foundation of safe routines for secure programming, </span>
<a name="l01311"></a>01311 <span class="comment"> *  that help to prevent buffer overflows and other security threats. It is correctly handles null arguments without</span>
<a name="l01312"></a>01312 <span class="comment"> *  crashing. The MPR is a library and a C API that can be used in both C and C++ programs.</span>
<a name="l01313"></a>01313 <span class="comment"> *  \n\n</span>
<a name="l01314"></a>01314 <span class="comment"> *  The MPR uses by convention a set extended typedefs for common types. These include: bool, cchar, cvoid, uchar, </span>
<a name="l01315"></a>01315 <span class="comment"> *  short, ushort, int, uint, long, ulong, int64, uint64, float, and double. The cchar type is a const char, </span>
<a name="l01316"></a>01316 <span class="comment"> *  cvoid is const void, and several types have "u" prefixes to denote unsigned qualifiers.</span>
<a name="l01317"></a>01317 <span class="comment"> *  \n\n</span>
<a name="l01318"></a>01318 <span class="comment"> *  The MPR includes a memory manager to minimize memory leaks and maximize allocation efficiency. It utilizes </span>
<a name="l01319"></a>01319 <span class="comment"> *  a heap and slab allocators with tree links. All memory allocated is connected to a parent memory block thus forming a</span>
<a name="l01320"></a>01320 <span class="comment"> *  tree. When any block is freed, all child blocks are also freed. Most MPR APIs take a memory parent context </span>
<a name="l01321"></a>01321 <span class="comment"> *  as the first parameter.</span>
<a name="l01322"></a>01322 <span class="comment"> *  \n\n</span>
<a name="l01323"></a>01323 <span class="comment"> *  Many of these APIs are not thread-safe. If utilizing multithreaded programming on a supporting </span>
<a name="l01324"></a>01324 <span class="comment"> *      operating system, be careful if you modify or delete the underlying data while accessing the resource </span>
<a name="l01325"></a>01325 <span class="comment"> *      from another thread.</span>
<a name="l01326"></a>01326 <span class="comment"> */</span>
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 <span class="preprocessor">#ifndef _h_MPR</span>
<a name="l01329"></a>01329 <span class="preprocessor"></span><span class="preprocessor">#define _h_MPR 1</span>
<a name="l01330"></a>01330 <span class="preprocessor"></span>
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l01335"></a>01335 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l01336"></a>01336 <span class="preprocessor">#endif</span>
<a name="l01337"></a>01337 <span class="preprocessor"></span>
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 <span class="keyword">struct  </span>Mpr;
<a name="l01340"></a>01340 <span class="keyword">struct  </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>;
<a name="l01341"></a>01341 <span class="keyword">struct  </span>MprBuf;
<a name="l01342"></a>01342 <span class="keyword">struct  </span><a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>;
<a name="l01343"></a>01343 <span class="keyword">struct  </span>MprDispatcher;
<a name="l01344"></a>01344 <span class="keyword">struct  </span>MprDispatcherService;
<a name="l01345"></a>01345 <span class="keyword">struct  </span>MprEvent;
<a name="l01346"></a>01346 <span class="keyword">struct  </span>MprFile;
<a name="l01347"></a>01347 <span class="keyword">struct  </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a>;
<a name="l01348"></a>01348 <span class="keyword">struct  </span>MprHeap;
<a name="l01349"></a>01349 <span class="keyword">struct  </span>MprModule;
<a name="l01350"></a>01350 <span class="keyword">struct  </span>MprOsService;
<a name="l01351"></a>01351 <span class="keyword">struct  </span>MprPath;
<a name="l01352"></a>01352 <span class="keyword">struct  </span>MprSocket;
<a name="l01353"></a>01353 <span class="keyword">struct  </span>MprSocketService;
<a name="l01354"></a>01354 <span class="keyword">struct  </span>MprSsl;
<a name="l01355"></a>01355 <span class="keyword">struct  </span>MprWaitService;
<a name="l01356"></a>01356 <span class="keyword">struct  </span>MprWaitHandler;
<a name="l01357"></a>01357 <span class="keyword">struct  </span>MprXml;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l01360"></a>01360 <span class="preprocessor"></span><span class="keyword">struct  </span><a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>;
<a name="l01361"></a>01361 <span class="keyword">struct  </span>MprThread;
<a name="l01362"></a>01362 <span class="keyword">struct  </span>MprThreadService;
<a name="l01363"></a>01363 <span class="keyword">struct  </span>MprWorker;
<a name="l01364"></a>01364 <span class="keyword">struct  </span>MprWorkerService;
<a name="l01365"></a>01365 <span class="preprocessor">#endif</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>
<a name="l01367"></a>01367 <span class="comment">//  TODO - make these consistent: CANT vs NOT or NO</span>
<a name="l01368"></a>01368 <span class="comment"></span>
<a name="l01369"></a>01369 <span class="comment">/**</span>
<a name="l01370"></a>01370 <span class="comment"> *  Standard MPR return and error codes</span>
<a name="l01371"></a>01371 <span class="comment"> */</span>
<a name="l01372"></a><a class="code" href="mpr_8h.html#9f0e4f45ab378cf38c97d1f82ae97977">01372</a> <span class="preprocessor">#define MPR_ERR_OK                      0       </span><span class="comment">/**&lt; Success */</span>
<a name="l01373"></a>01373 <span class="preprocessor">#define MPR_ERR_BASE                    -1      </span><span class="comment">/*   Base error code */</span>
<a name="l01374"></a><a class="code" href="mpr_8h.html#4b27e0a286fd6975d08929c2ef931ab6">01374</a> <span class="preprocessor">#define MPR_ERR                         -1      </span><span class="comment">/**&lt; Default error code */</span>
<a name="l01375"></a><a class="code" href="mpr_8h.html#90f611631651c3bc10a50d12a43a4891">01375</a> <span class="preprocessor">#define MPR_ERR_GENERAL                 -1      </span><span class="comment">/**&lt; General error */</span>
<a name="l01376"></a><a class="code" href="mpr_8h.html#5e8036f0bee810b7d0a3fa6a752c77b2">01376</a> <span class="preprocessor">#define MPR_ERR_ABORTED                 -2      </span><span class="comment">/**&lt; Action aborted */</span>
<a name="l01377"></a><a class="code" href="mpr_8h.html#0a19880d5b8b35cbd243601c3fdebc9a">01377</a> <span class="preprocessor">#define MPR_ERR_ALREADY_EXISTS          -3      </span><span class="comment">/**&lt; Item already exists */</span>
<a name="l01378"></a><a class="code" href="mpr_8h.html#919966956e7462c38d2a1575c32d9948">01378</a> <span class="preprocessor">#define MPR_ERR_BAD_ARGS                -4      </span><span class="comment">/**&lt; Bad arguments or paramaeters */</span>
<a name="l01379"></a><a class="code" href="mpr_8h.html#930ee0c1f493bf582c968c45b1670e3d">01379</a> <span class="preprocessor">#define MPR_ERR_BAD_FORMAT              -5      </span><span class="comment">/**&lt; Bad input format */</span>
<a name="l01380"></a>01380 <span class="preprocessor">#define MPR_ERR_BAD_HANDLE              -6</span>
<a name="l01381"></a><a class="code" href="mpr_8h.html#c23aecc1451d49a5b30ec93eef8a82fa">01381</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_BAD_STATE               -7      </span><span class="comment">/**&lt; Module is in a bad state */</span>
<a name="l01382"></a><a class="code" href="mpr_8h.html#ba09adbb870ee2f433345e2f149e7170">01382</a> <span class="preprocessor">#define MPR_ERR_BAD_SYNTAX              -8      </span><span class="comment">/**&lt; Input has bad syntax */</span>
<a name="l01383"></a>01383 <span class="preprocessor">#define MPR_ERR_BAD_TYPE                -9</span>
<a name="l01384"></a>01384 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_BAD_VALUE               -10</span>
<a name="l01385"></a>01385 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_BUSY                    -11</span>
<a name="l01386"></a><a class="code" href="mpr_8h.html#2223fd269b22204735c86aedfb75498d">01386</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_CANT_ACCESS             -12     </span><span class="comment">/**&lt; Can't access the file or resource */</span>
<a name="l01387"></a>01387 <span class="preprocessor">#define MPR_ERR_CANT_COMPLETE           -13</span>
<a name="l01388"></a><a class="code" href="mpr_8h.html#9d015f30b291c6ddc172ee8401626201">01388</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_CANT_CREATE             -14     </span><span class="comment">/**&lt; Can't create the file or resource */</span>
<a name="l01389"></a>01389 <span class="preprocessor">#define MPR_ERR_CANT_INITIALIZE         -15</span>
<a name="l01390"></a><a class="code" href="mpr_8h.html#293c82c9a0891e2dcfd18caf2f515b87">01390</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_CANT_OPEN               -16     </span><span class="comment">/**&lt; Can't open the file or resource */</span>
<a name="l01391"></a><a class="code" href="mpr_8h.html#4dad0ac2657323d3e0790744560d4404">01391</a> <span class="preprocessor">#define MPR_ERR_CANT_READ               -17     </span><span class="comment">/**&lt; Can't read from the file or resource */</span>
<a name="l01392"></a><a class="code" href="mpr_8h.html#f8d350a5d245956ba8d0e6f461906d51">01392</a> <span class="preprocessor">#define MPR_ERR_CANT_WRITE              -18     </span><span class="comment">/**&lt; Can't write to the file or resource */</span>
<a name="l01393"></a>01393 <span class="preprocessor">#define MPR_ERR_DELETED                 -19</span>
<a name="l01394"></a>01394 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_NETWORK                 -20</span>
<a name="l01395"></a>01395 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_NOT_FOUND               -21</span>
<a name="l01396"></a><a class="code" href="mpr_8h.html#dd3e5f02d6a87f8d974978e7a1bae790">01396</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_NOT_INITIALIZED         -22     </span><span class="comment">/**&lt; Module or resource is not initialized */</span>
<a name="l01397"></a>01397 <span class="preprocessor">#define MPR_ERR_NOT_READY               -23</span>
<a name="l01398"></a><a class="code" href="mpr_8h.html#1d01a181e24b717f7e8cc209ecf9a1fd">01398</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_READ_ONLY               -24     </span><span class="comment">/**&lt; The operation timed out */</span>
<a name="l01399"></a>01399 <span class="preprocessor">#define MPR_ERR_TIMEOUT                 -25</span>
<a name="l01400"></a>01400 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_TOO_MANY                -26</span>
<a name="l01401"></a>01401 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_WONT_FIT                -27</span>
<a name="l01402"></a>01402 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_WOULD_BLOCK             -28</span>
<a name="l01403"></a>01403 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_CANT_ALLOCATE           -29</span>
<a name="l01404"></a><a class="code" href="mpr_8h.html#21c86bc598c8c86c0347dd2e7a5d2948">01404</a> <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_NO_MEMORY               -30     </span><span class="comment">/**&lt; Memory allocation error */</span>
<a name="l01405"></a>01405 <span class="preprocessor">#define MPR_ERR_CANT_DELETE             -31</span>
<a name="l01406"></a>01406 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_CANT_CONNECT            -32</span>
<a name="l01407"></a>01407 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ERR_MAX                     -33</span>
<a name="l01408"></a>01408 <span class="preprocessor"></span><span class="comment"></span>
<a name="l01409"></a>01409 <span class="comment">/**</span>
<a name="l01410"></a>01410 <span class="comment"> *  Standard logging trace levels are 0 to 9 with 0 being the most verbose. These are ored with the error source</span>
<a name="l01411"></a>01411 <span class="comment"> *  and type flags. The MPR_LOG_MASK is used to extract the trace level from a flags word. We expect most apps</span>
<a name="l01412"></a>01412 <span class="comment"> *  to run with level 2 trace enabled.</span>
<a name="l01413"></a>01413 <span class="comment"> */</span>
<a name="l01414"></a><a class="code" href="mpr_8h.html#b58f968604e9f630b90bd20b66f9fc6b">01414</a> <span class="preprocessor">#define MPR_ERROR       1       </span><span class="comment">/* Hard error trace level */</span>
<a name="l01415"></a>01415 <span class="preprocessor">#define MPR_WARN        2       </span><span class="comment">/* Soft warning trace level */</span>
<a name="l01416"></a>01416 <span class="preprocessor">#define MPR_CONFIG      2       </span><span class="comment">/* Configuration settings trace level. */</span>
<a name="l01417"></a>01417 <span class="preprocessor">#define MPR_INFO        3       </span><span class="comment">/* Informational trace only */</span>
<a name="l01418"></a>01418 <span class="preprocessor">#define MPR_DEBUG       4       </span><span class="comment">/* Debug information trace level */</span>
<a name="l01419"></a>01419 <span class="preprocessor">#define MPR_VERBOSE     9       </span><span class="comment">/* Highest level of trace */</span>
<a name="l01420"></a>01420 <span class="preprocessor">#define MPR_LEVEL_MASK  0xf     </span><span class="comment">/* Level mask */</span>
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="comment">/*</span>
<a name="l01423"></a>01423 <span class="comment"> *  Error source flags</span>
<a name="l01424"></a>01424 <span class="comment"> */</span>
<a name="l01425"></a>01425 <span class="preprocessor">#define MPR_ERROR_SRC   0x10    </span><span class="comment">/* Originated from mprError */</span>
<a name="l01426"></a>01426 <span class="preprocessor">#define MPR_LOG_SRC     0x20    </span><span class="comment">/* Originated from mprLog */</span>
<a name="l01427"></a>01427 <span class="preprocessor">#define MPR_ASSERT_SRC  0x40    </span><span class="comment">/* Originated from mprAssert */</span>
<a name="l01428"></a>01428 <span class="preprocessor">#define MPR_FATAL_SRC   0x80    </span><span class="comment">/* Fatal error. Log and exit */</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="comment">/*</span>
<a name="l01431"></a>01431 <span class="comment"> *  Log message type flags. Specify what kind of log / error message it is. Listener handlers examine this flag</span>
<a name="l01432"></a>01432 <span class="comment"> *  to determine if they should process the message.Assert messages are trapped when in DEV mode. Otherwise ignored.</span>
<a name="l01433"></a>01433 <span class="comment"> */</span>
<a name="l01434"></a>01434 <span class="preprocessor">#define MPR_LOG_MSG     0x100   </span><span class="comment">/* Log trace message - not an error */</span>
<a name="l01435"></a>01435 <span class="preprocessor">#define MPR_ERROR_MSG   0x200   </span><span class="comment">/* General error */</span>
<a name="l01436"></a>01436 <span class="preprocessor">#define MPR_ASSERT_MSG  0x400   </span><span class="comment">/* Assert flags -- trap in debugger */</span>
<a name="l01437"></a>01437 <span class="preprocessor">#define MPR_USER_MSG    0x800   </span><span class="comment">/* User message */</span>
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 <span class="comment">/*</span>
<a name="l01440"></a>01440 <span class="comment"> *  Log output modifiers</span>
<a name="l01441"></a>01441 <span class="comment"> */</span>
<a name="l01442"></a>01442 <span class="preprocessor">#define MPR_RAW         0x1000  </span><span class="comment">/* Raw trace output */</span>
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="comment">/*</span>
<a name="l01445"></a>01445 <span class="comment"> *  Error line number information.</span>
<a name="l01446"></a>01446 <span class="comment"> */</span>
<a name="l01447"></a>01447 <span class="preprocessor">#define MPR_LINE(s)     #s</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span><span class="preprocessor">#define MPR_LINE2(s)    MPR_LINE(s)</span>
<a name="l01449"></a>01449 <span class="preprocessor"></span><span class="preprocessor">#define MPR_LINE3       MPR_LINE2(__LINE__)</span>
<a name="l01450"></a>01450 <span class="preprocessor"></span><span class="preprocessor">#define MPR_LOC        __FILE__ ":" MPR_LINE3</span>
<a name="l01451"></a>01451 <span class="preprocessor"></span>
<a name="l01452"></a>01452 <span class="preprocessor">#define MPR_STRINGIFY(s) #s</span>
<a name="l01453"></a>01453 <span class="preprocessor"></span>
<a name="l01454"></a>01454 <span class="preprocessor">#if VXWORKS</span>
<a name="l01455"></a>01455 <span class="preprocessor"></span><span class="preprocessor">    #define MAIN(name, _argc, _argv)  \</span>
<a name="l01456"></a>01456 <span class="preprocessor">        int name(_argc, _argv) { \</span>
<a name="l01457"></a>01457 <span class="preprocessor">            extern int main(); \</span>
<a name="l01458"></a>01458 <span class="preprocessor">            return main(argc, #name); \</span>
<a name="l01459"></a>01459 <span class="preprocessor">        } \</span>
<a name="l01460"></a>01460 <span class="preprocessor">        int main(_argc, _argv)</span>
<a name="l01461"></a>01461 <span class="preprocessor"></span><span class="preprocessor">#elif WINCE</span>
<a name="l01462"></a>01462 <span class="preprocessor"></span><span class="preprocessor">    #define MAIN(name, argc, argv)  \</span>
<a name="l01463"></a>01463 <span class="preprocessor">        APIENTRY WinMain(HINSTANCE inst, HINSTANCE junk, LPWSTR args, int junk2) { \</span>
<a name="l01464"></a>01464 <span class="preprocessor">            extern int main(); \</span>
<a name="l01465"></a>01465 <span class="preprocessor">            main((int) args, #name); \</span>
<a name="l01466"></a>01466 <span class="preprocessor">        } \</span>
<a name="l01467"></a>01467 <span class="preprocessor">        int main(argc, argv)</span>
<a name="l01468"></a>01468 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01469"></a>01469 <span class="preprocessor"></span><span class="preprocessor">    #define MAIN(name, argc, argv) int main(argc, argv)</span>
<a name="l01470"></a>01470 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01471"></a>01471 <span class="preprocessor"></span><span class="comment"></span>
<a name="l01472"></a>01472 <span class="comment">/**</span>
<a name="l01473"></a>01473 <span class="comment"> *  Trigger a breakpoint.</span>
<a name="l01474"></a>01474 <span class="comment"> *  @description Triggers a breakpoint and traps to the debugger. </span>
<a name="l01475"></a>01475 <span class="comment"> *  @ingroup Mpr</span>
<a name="l01476"></a>01476 <span class="comment"> */</span>
<a name="l01477"></a>01477 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr.html#gc5203b2138474e781207b39ac4726c1b" title="Trigger a breakpoint.">mprBreakpoint</a>();
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 <span class="preprocessor">#if BLD_FEATURE_ASSERT</span>
<a name="l01480"></a>01480 <span class="preprocessor"></span><span class="preprocessor">    #define mprAssert(C)    if (C) ; else mprStaticAssert(MPR_LOC, #C)</span>
<a name="l01481"></a>01481 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01482"></a>01482 <span class="preprocessor"></span><span class="preprocessor">    #define mprAssert(C)    if (1) ; else</span>
<a name="l01483"></a>01483 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01484"></a>01484 <span class="preprocessor"></span><span class="comment"></span>
<a name="l01485"></a>01485 <span class="comment">/**</span>
<a name="l01486"></a>01486 <span class="comment"> *  Memory Allocation Service.</span>
<a name="l01487"></a>01487 <span class="comment"> *  @description The MPR provides a memory manager that sits above malloc. This layer provides arena and slab </span>
<a name="l01488"></a>01488 <span class="comment"> *  based allocations with a tree structured allocation mechanism. The goal of the layer is to provide </span>
<a name="l01489"></a>01489 <span class="comment"> *  a fast, secure, scalable memory allocator suited for embedded applications in multithreaded environments. </span>
<a name="l01490"></a>01490 <span class="comment"> *  \n\n</span>
<a name="l01491"></a>01491 <span class="comment"> *  By using a tree structured network of memory contexts, error recovery in applications and memory freeing becomes</span>
<a name="l01492"></a>01492 <span class="comment"> *  much easier and more reliable. When a memory block is allocated a parent memory block must be specified. When</span>
<a name="l01493"></a>01493 <span class="comment"> *  the parent block is freed, all its children are automatically freed. </span>
<a name="l01494"></a>01494 <span class="comment"> *  \n\n</span>
<a name="l01495"></a>01495 <span class="comment"> *  The MPR handles memory allocation errors globally. The application can configure a memory limits and redline</span>
<a name="l01496"></a>01496 <span class="comment"> *  so that memory depletion can be proactively detected and handled. This relieves most cost from detecting and</span>
<a name="l01497"></a>01497 <span class="comment"> *  handling allocation errors. </span>
<a name="l01498"></a>01498 <span class="comment"> *  @stability Evolving</span>
<a name="l01499"></a>01499 <span class="comment"> *  @defgroup MprMem MprMem</span>
<a name="l01500"></a>01500 <span class="comment"> *  @see MprCtx, mprFree, mprRealloc, mprAlloc, mprAllocWithDestructor, mprAllocWithDestructorZeroed, mprAllocZeroed, </span>
<a name="l01501"></a>01501 <span class="comment">        mprGetParent, mprCreate, mprSetAllocLimits, mprAllocObjWithDestructor, mprAllocObjWithDestructorZeroed,</span>
<a name="l01502"></a>01502 <span class="comment"> *      mprHasAllocError mprResetAllocError, mprMemdup, mprStrndup, mprMemcpy, </span>
<a name="l01503"></a>01503 <span class="comment"> */</span>
<a name="l01504"></a>01504 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprMem { <span class="keywordtype">int</span> dummy; } MprMem;
<a name="l01505"></a>01505 <span class="comment"></span>
<a name="l01506"></a>01506 <span class="comment">/**</span>
<a name="l01507"></a>01507 <span class="comment"> *  Memory context type.</span>
<a name="l01508"></a>01508 <span class="comment"> *  @description Blocks of memory are allocated using a memory context as the parent. Any allocated memory block</span>
<a name="l01509"></a>01509 <span class="comment"> *      may serve as the memory context for subsequent memory allocations. Freeing a block via \ref mprFree</span>
<a name="l01510"></a>01510 <span class="comment"> *      will release the allocated block and all child blocks.</span>
<a name="l01511"></a>01511 <span class="comment"> *  @ingroup MprMem</span>
<a name="l01512"></a>01512 <span class="comment"> */</span>
<a name="l01513"></a><a class="code" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">01513</a> <span class="keyword">typedef</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f" title="Memory context type.">MprCtx</a>;
<a name="l01514"></a>01514 <span class="comment"></span>
<a name="l01515"></a>01515 <span class="comment">/**</span>
<a name="l01516"></a>01516 <span class="comment"> *  Safe String Module</span>
<a name="l01517"></a>01517 <span class="comment"> *  @description The MPR provides a suite of safe string manipulation routines to help prevent buffer overflows</span>
<a name="l01518"></a>01518 <span class="comment"> *      and other potential security traps.</span>
<a name="l01519"></a>01519 <span class="comment"> *  @see MprString, mprAsprintf, mprAllocStrcpy, mprAtoi, mprItoa, mprMemcpy,</span>
<a name="l01520"></a>01520 <span class="comment"> *      mprPrintf, mprReallocStrcat, mprSprintf, mprStaticPrintf, mprStrLower, mprStrTok, mprStrTrim, mprStrUpper,</span>
<a name="l01521"></a>01521 <span class="comment"> *      mprStrcmpAnyCase, mprStrcmpAnyCaseCount, mprStrcpy, mprStrlen, mprVsprintf, mprPrintfError,</span>
<a name="l01522"></a>01522 <span class="comment"> *      mprStrcat, mprAllocStrcpy, mprReallocStrcat, mprVasprintf</span>
<a name="l01523"></a>01523 <span class="comment"> */</span>
<a name="l01524"></a><a class="code" href="struct_mpr_string.html">01524</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_string.html" title="Safe String Module.">MprString</a> { <span class="keywordtype">int</span> dummy; } <a class="code" href="struct_mpr_string.html" title="Safe String Module.">MprString</a>;
<a name="l01525"></a>01525 <span class="comment"></span>
<a name="l01526"></a>01526 <span class="comment">/**</span>
<a name="l01527"></a>01527 <span class="comment"> *  Print a formatted message to the standard error channel</span>
<a name="l01528"></a>01528 <span class="comment"> *  @description This is a secure replacement for fprintf(stderr. </span>
<a name="l01529"></a>01529 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l01530"></a>01530 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01531"></a>01531 <span class="comment"> *  @return Returns the number of bytes written</span>
<a name="l01532"></a>01532 <span class="comment"> *  @ingroup MprString</span>
<a name="l01533"></a>01533 <span class="comment"> */</span>
<a name="l01534"></a>01534 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#13f99df19731bdfca83cd7ab64b6dd90" title="Print a formatted message to the standard error channel.">mprPrintfError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="comment">/*</span>
<a name="l01537"></a>01537 <span class="comment">   Mode values for mprDtoa</span>
<a name="l01538"></a>01538 <span class="comment"> */</span>
<a name="l01539"></a>01539 <span class="preprocessor">#define MPR_DTOA_ALL_DIGITS         0       </span><span class="comment">/* Return all digits */</span>
<a name="l01540"></a>01540 <span class="preprocessor">#define MPR_DTOA_N_DIGITS           2       </span><span class="comment">/* Return total N digits */</span>
<a name="l01541"></a>01541 <span class="preprocessor">#define MPR_DTOA_N_FRACTION_DIGITS  3       </span><span class="comment">/* Return total fraction digits */</span>
<a name="l01542"></a>01542 
<a name="l01543"></a>01543 <span class="comment">/*</span>
<a name="l01544"></a>01544 <span class="comment">    Flags for mprDtoa</span>
<a name="l01545"></a>01545 <span class="comment"> */</span>
<a name="l01546"></a>01546 <span class="preprocessor">#define MPR_DTOA_EXPONENT_FORM      0x10    </span><span class="comment">/* Result in exponent form (N.NNNNe+NN) */</span>
<a name="l01547"></a>01547 <span class="preprocessor">#define MPR_DTOA_FIXED_FORM         0x20    </span><span class="comment">/* Emit in fixed form (NNNN.MMMM)*/</span>
<a name="l01548"></a>01548 <span class="comment"></span>
<a name="l01549"></a>01549 <span class="comment">/**</span>
<a name="l01550"></a>01550 <span class="comment">    Convert a double to ascii</span>
<a name="l01551"></a>01551 <span class="comment">    @param ctx Any memory context allocated by the MPR.</span>
<a name="l01552"></a>01552 <span class="comment">    @param value Value to convert</span>
<a name="l01553"></a>01553 <span class="comment">    @param ndigits Number of digits to render</span>
<a name="l01554"></a>01554 <span class="comment">    @param mode Modes are:</span>
<a name="l01555"></a>01555 <span class="comment">         0   Shortest string,</span>
<a name="l01556"></a>01556 <span class="comment">         1   Like 0, but with Steele &amp; White stopping rule,</span>
<a name="l01557"></a>01557 <span class="comment">         2   Return ndigits of result,</span>
<a name="l01558"></a>01558 <span class="comment">         3   Number of digits applies after the decimal point.</span>
<a name="l01559"></a>01559 <span class="comment">    @param flags Format flags</span>
<a name="l01560"></a>01560 <span class="comment"> */</span>
<a name="l01561"></a>01561 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#176d0ea8501110003ec63c0e3ecf24f8" title="Convert a double to ascii.">mprDtoa</a>(MprCtx ctx, <span class="keywordtype">double</span> value, <span class="keywordtype">int</span> ndigits, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> flags);
<a name="l01562"></a>01562 
<a name="l01563"></a>01563 <span class="comment">//MOB</span>
<a name="l01564"></a>01564 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprIsInfinite(<span class="keywordtype">double</span> value);
<a name="l01565"></a>01565 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprIsZero(<span class="keywordtype">double</span> value);
<a name="l01566"></a>01566 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprIsNan(<span class="keywordtype">double</span> value);
<a name="l01567"></a>01567 <span class="comment"></span>
<a name="l01568"></a>01568 <span class="comment">/**</span>
<a name="l01569"></a>01569 <span class="comment"> *  Print a message to the applications standard output without allocating memory.</span>
<a name="l01570"></a>01570 <span class="comment"> *  @description This is a secure replacement for printf that will not allocate memory.</span>
<a name="l01571"></a>01571 <span class="comment"> *  @param ctx Any memory context allocated by the MPR. This is used to locate the standard output channel and not</span>
<a name="l01572"></a>01572 <span class="comment"> *      to allocate memory.</span>
<a name="l01573"></a>01573 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01574"></a>01574 <span class="comment"> *  @return Returns the number of bytes written</span>
<a name="l01575"></a>01575 <span class="comment"> *  @remarks The maximum output is MPR_MAX_STRING - 1.</span>
<a name="l01576"></a>01576 <span class="comment"> *  @ingroup MprString</span>
<a name="l01577"></a>01577 <span class="comment"> */</span>
<a name="l01578"></a>01578 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#4d6edb96beee6c995edc3197556536f5" title="Print a message to the applications standard output without allocating memory.">mprStaticPrintf</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l01579"></a>01579 <span class="comment"></span>
<a name="l01580"></a>01580 <span class="comment">/**</span>
<a name="l01581"></a>01581 <span class="comment"> *  Print a message to the standard error channel without allocating memory.</span>
<a name="l01582"></a>01582 <span class="comment"> *  @description This is a secure replacement for fprintf(stderr that will not allocate memory.</span>
<a name="l01583"></a>01583 <span class="comment"> *  @param ctx Any memory context allocated by the MPR. This is used to locate the standard output channel and not</span>
<a name="l01584"></a>01584 <span class="comment"> *      to allocate memory.</span>
<a name="l01585"></a>01585 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01586"></a>01586 <span class="comment"> *  @return Returns the number of bytes written</span>
<a name="l01587"></a>01587 <span class="comment"> *  @remarks The maximum output is MPR_MAX_STRING - 1.</span>
<a name="l01588"></a>01588 <span class="comment"> *  @ingroup MprString</span>
<a name="l01589"></a>01589 <span class="comment"> */</span>
<a name="l01590"></a>01590 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#ba7d5ea137f728040a397b62bb308455" title="Print a message to the standard error channel without allocating memory.">mprStaticPrintfError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l01591"></a>01591 <span class="comment"></span>
<a name="l01592"></a>01592 <span class="comment">/**</span>
<a name="l01593"></a>01593 <span class="comment"> *  Formatted print. This is a secure verion of printf that can handle null args.</span>
<a name="l01594"></a>01594 <span class="comment"> *  @description This is a secure replacement for printf. It can handle null arguments without crashes.</span>
<a name="l01595"></a>01595 <span class="comment"> *      minimal footprint. The MPR can be build without using any printf routines.</span>
<a name="l01596"></a>01596 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l01597"></a>01597 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01598"></a>01598 <span class="comment"> *  @return Returns the number of bytes written</span>
<a name="l01599"></a>01599 <span class="comment"> *  @ingroup MprString</span>
<a name="l01600"></a>01600 <span class="comment"> */</span>
<a name="l01601"></a>01601 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#dfbd1fa43e7b737e566661e5d6ab6c36" title="Formatted print.">mprPrintf</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l01602"></a>01602 <span class="comment"></span>
<a name="l01603"></a>01603 <span class="comment">/**</span>
<a name="l01604"></a>01604 <span class="comment"> *  Print a formatted message to a file descriptor</span>
<a name="l01605"></a>01605 <span class="comment"> *  @description This is a replacement for fprintf as part of the safe string MPR library. It minimizes </span>
<a name="l01606"></a>01606 <span class="comment"> *      memory use and uses a file descriptor instead of a File pointer.</span>
<a name="l01607"></a>01607 <span class="comment"> *  @param file MprFile object returned via mprOpen.</span>
<a name="l01608"></a>01608 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01609"></a>01609 <span class="comment"> *  @return Returns the number of bytes written</span>
<a name="l01610"></a>01610 <span class="comment"> *  @ingroup MprString</span>
<a name="l01611"></a>01611 <span class="comment"> */</span>
<a name="l01612"></a>01612 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#07783ffc93b6fd136de7b927ccceed19" title="Print a formatted message to a file descriptor.">mprFprintf</a>(<span class="keyword">struct</span> MprFile *file, cchar *fmt, ...);
<a name="l01613"></a>01613 <span class="comment"></span>
<a name="l01614"></a>01614 <span class="comment">/**</span>
<a name="l01615"></a>01615 <span class="comment"> *  Format a string into a statically allocated buffer.</span>
<a name="l01616"></a>01616 <span class="comment"> *  @description This call format a string using printf style formatting arguments. A trailing null will </span>
<a name="l01617"></a>01617 <span class="comment"> *      always be appended. The call returns the size of the allocated string excluding the null.</span>
<a name="l01618"></a>01618 <span class="comment"> *  @param buf Pointer to the buffer.</span>
<a name="l01619"></a>01619 <span class="comment"> *  @param maxSize Size of the buffer.</span>
<a name="l01620"></a>01620 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01621"></a>01621 <span class="comment"> *  @return Returns the buffer.</span>
<a name="l01622"></a>01622 <span class="comment"> *  @ingroup MprString</span>
<a name="l01623"></a>01623 <span class="comment"> */</span>
<a name="l01624"></a>01624 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#6cedd059c2f7ea313fbf7bc136ab2909" title="Format a string into a statically allocated buffer.">mprSprintf</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> maxSize, cchar *fmt, ...);
<a name="l01625"></a>01625 <span class="comment"></span>
<a name="l01626"></a>01626 <span class="comment">/**</span>
<a name="l01627"></a>01627 <span class="comment"> *  Format a string into a statically allocated buffer.</span>
<a name="l01628"></a>01628 <span class="comment"> *  @description This call format a string using printf style formatting arguments. A trailing null will </span>
<a name="l01629"></a>01629 <span class="comment"> *      always be appended. The call returns the size of the allocated string excluding the null.</span>
<a name="l01630"></a>01630 <span class="comment"> *  @param buf Pointer to the buffer.</span>
<a name="l01631"></a>01631 <span class="comment"> *  @param maxSize Size of the buffer.</span>
<a name="l01632"></a>01632 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l01633"></a>01633 <span class="comment"> *  @param args Varargs argument obtained from va_start.</span>
<a name="l01634"></a>01634 <span class="comment"> *  @return Returns the buffer;</span>
<a name="l01635"></a>01635 <span class="comment"> *  @ingroup MprString</span>
<a name="l01636"></a>01636 <span class="comment"> */</span>
<a name="l01637"></a>01637 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#5bba3c0b15d48ec6cc90966f14ae663a" title="Format a string into a statically allocated buffer.">mprVsprintf</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> maxSize, cchar *fmt, va_list args);
<a name="l01638"></a>01638 <span class="comment"></span>
<a name="l01639"></a>01639 <span class="comment">/**</span>
<a name="l01640"></a>01640 <span class="comment"> *  Convert an integer to a string.</span>
<a name="l01641"></a>01641 <span class="comment"> *  @description This call converts the supplied integer into a string formatted into the supplied buffer.</span>
<a name="l01642"></a>01642 <span class="comment"> *  @param buf Pointer to the buffer that will hold the string.</span>
<a name="l01643"></a>01643 <span class="comment"> *  @param size Size of the buffer.</span>
<a name="l01644"></a>01644 <span class="comment"> *  @param value Integer value to convert</span>
<a name="l01645"></a>01645 <span class="comment"> *  @param radix The base radix to use when encoding the number</span>
<a name="l01646"></a>01646 <span class="comment"> *  @return Returns the number of characters in the string.</span>
<a name="l01647"></a>01647 <span class="comment"> *  @ingroup MprString</span>
<a name="l01648"></a>01648 <span class="comment"> */</span>
<a name="l01649"></a>01649 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#c44ccf179c55dbbcf7aa04ba86090463" title="Convert an integer to a string.">mprItoa</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> size, int64 value, <span class="keywordtype">int</span> radix);
<a name="l01650"></a>01650 <span class="comment"></span>
<a name="l01651"></a>01651 <span class="comment">/**</span>
<a name="l01652"></a>01652 <span class="comment"> *  Convert a string to an integer.</span>
<a name="l01653"></a>01653 <span class="comment"> *  @description This call converts the supplied string to an integer using the specified radix (base).</span>
<a name="l01654"></a>01654 <span class="comment"> *  @param str Pointer to the string to parse.</span>
<a name="l01655"></a>01655 <span class="comment"> *  @param radix Base to use when parsing the string</span>
<a name="l01656"></a>01656 <span class="comment"> *  @return Returns the integer equivalent value of the string. </span>
<a name="l01657"></a>01657 <span class="comment"> *  @ingroup MprString</span>
<a name="l01658"></a>01658 <span class="comment"> */</span>
<a name="l01659"></a>01659 <span class="keyword">extern</span> int64 <a class="code" href="mpr_8h.html#b2b1ebf1965beac947ab9b77970f49c5" title="Convert a string to an integer.">mprAtoi</a>(cchar *str, <span class="keywordtype">int</span> radix);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661 <span class="comment">//  TODO</span>
<a name="l01662"></a>01662 <span class="keyword">extern</span> int64 mprParseNumber(cchar *str, <span class="keywordtype">int</span> radix, <span class="keywordtype">int</span> *err);
<a name="l01663"></a>01663 <span class="comment"></span>
<a name="l01664"></a>01664 <span class="comment">/**</span>
<a name="l01665"></a>01665 <span class="comment"> *  Get the next word token.</span>
<a name="l01666"></a>01666 <span class="comment"> *  @description Split a string into word tokens using the supplied separator.</span>
<a name="l01667"></a>01667 <span class="comment"> *  @param buf Buffer to use to hold the word token</span>
<a name="l01668"></a>01668 <span class="comment"> *  @param bufsize Size of the buffer</span>
<a name="l01669"></a>01669 <span class="comment"> *  @param str Input string to tokenize. Note this cannot be a const string. It will be written.</span>
<a name="l01670"></a>01670 <span class="comment"> *  @param delim String of separator characters to use when tokenizing</span>
<a name="l01671"></a>01671 <span class="comment"> *  @param tok Pointer to a word to hold a pointer to the next token in the original string.</span>
<a name="l01672"></a>01672 <span class="comment"> *  @return Returns the number of bytes in the allocated block.</span>
<a name="l01673"></a>01673 <span class="comment"> *  @ingroup MprString</span>
<a name="l01674"></a>01674 <span class="comment"> */</span>
<a name="l01675"></a>01675 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#38c5795e4d552281fbf168b679d89704" title="Get the next word token.">mprGetWordTok</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize, cchar *str, cchar *delim, cchar **tok);
<a name="l01676"></a>01676 <span class="comment"></span>
<a name="l01677"></a>01677 <span class="comment">/**</span>
<a name="l01678"></a>01678 <span class="comment"> *  Safe copy for a block of data.</span>
<a name="l01679"></a>01679 <span class="comment"> *  @description Safely copy a block of data into an existing memory block. The call ensures the destination </span>
<a name="l01680"></a>01680 <span class="comment"> *      block is not overflowed and returns the size of the block actually copied. This is similar to memcpy, but </span>
<a name="l01681"></a>01681 <span class="comment"> *      is a safer alternative.</span>
<a name="l01682"></a>01682 <span class="comment"> *  @param dest Pointer to the destination block.</span>
<a name="l01683"></a>01683 <span class="comment"> *  @param destMax Maximum size of the destination block.</span>
<a name="l01684"></a>01684 <span class="comment"> *  @param src Block to copy</span>
<a name="l01685"></a>01685 <span class="comment"> *  @param nbytes Size of the source block</span>
<a name="l01686"></a>01686 <span class="comment"> *  @return Returns the number of characters in the allocated block.</span>
<a name="l01687"></a>01687 <span class="comment"> *  @ingroup MprString</span>
<a name="l01688"></a>01688 <span class="comment"> */</span>
<a name="l01689"></a>01689 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#bcb752b124b706ebff6798cfeafc9f99" title="Safe copy for a block of data.">mprMemcpy</a>(<span class="keywordtype">void</span> *dest, <span class="keywordtype">int</span> destMax, cvoid *src, <span class="keywordtype">int</span> nbytes);
<a name="l01690"></a>01690 <span class="comment"></span>
<a name="l01691"></a>01691 <span class="comment">/**</span>
<a name="l01692"></a>01692 <span class="comment"> *  Compare two byte strings.</span>
<a name="l01693"></a>01693 <span class="comment"> *  @description Safely compare two byte strings. This is a safe replacement for memcmp.</span>
<a name="l01694"></a>01694 <span class="comment"> *  @param b1 Pointer to the first byte string.</span>
<a name="l01695"></a>01695 <span class="comment"> *  @param b1Len Length of the first byte string.</span>
<a name="l01696"></a>01696 <span class="comment"> *  @param b2 Pointer to the second byte string.</span>
<a name="l01697"></a>01697 <span class="comment"> *  @param b2Len Length of the second byte string.</span>
<a name="l01698"></a>01698 <span class="comment"> *  @return Returns zero if the byte strings are identical. Otherwise returns -1 if the first string is less than the </span>
<a name="l01699"></a>01699 <span class="comment"> *      second. Returns 1 if the first is greater than the first.</span>
<a name="l01700"></a>01700 <span class="comment"> *  @ingroup MprString</span>
<a name="l01701"></a>01701 <span class="comment"> */</span>
<a name="l01702"></a>01702 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#1775b8543a4e3b0559f0e279bb5e37a6" title="Compare two byte strings.">mprMemcmp</a>(cvoid *b1, <span class="keywordtype">int</span> b1Len, cvoid *b2, <span class="keywordtype">int</span> b2Len);
<a name="l01703"></a>01703 <span class="comment"></span>
<a name="l01704"></a>01704 <span class="comment">/**</span>
<a name="l01705"></a>01705 <span class="comment"> *  Catenate strings.</span>
<a name="l01706"></a>01706 <span class="comment"> *  @description Safe replacement for strcat. Catenates a string onto an existing string. This call accepts </span>
<a name="l01707"></a>01707 <span class="comment"> *      a variable list of strings to append. The list of strings is terminated by a null argument. The call</span>
<a name="l01708"></a>01708 <span class="comment"> *      returns the length of the resulting string. This call is similar to strcat, but it will enforce a </span>
<a name="l01709"></a>01709 <span class="comment"> *      maximum size for the resulting string and will ensure it is terminated with a null.</span>
<a name="l01710"></a>01710 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l01711"></a>01711 <span class="comment"> *  @param max Maximum size of the new block.</span>
<a name="l01712"></a>01712 <span class="comment"> *  @param src Variable list of strings to append. The final string argument must be null.</span>
<a name="l01713"></a>01713 <span class="comment"> *  @return Returns an allocated string.</span>
<a name="l01714"></a>01714 <span class="comment"> *  @ingroup MprString</span>
<a name="l01715"></a>01715 <span class="comment"> */</span>
<a name="l01716"></a>01716 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#d3156f9075164b2fee835a66f62eb4aa" title="Catenate strings.">mprStrcat</a>(MprCtx ctx, <span class="keywordtype">int</span> max, cchar *src, ...);
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 <span class="keyword">extern</span> <span class="keywordtype">char</span> *mprStrcatV(MprCtx ctx, <span class="keywordtype">int</span> max, cchar *src, va_list args);
<a name="l01719"></a>01719 <span class="comment"></span>
<a name="l01720"></a>01720 <span class="comment">/**</span>
<a name="l01721"></a>01721 <span class="comment"> *  Copy a string.</span>
<a name="l01722"></a>01722 <span class="comment"> *  @description Safe replacement for strcpy. Copy a string and ensure the target string is not overflowed. </span>
<a name="l01723"></a>01723 <span class="comment"> *      The call returns the length of the resultant string or an error code if it will not fit into the target</span>
<a name="l01724"></a>01724 <span class="comment"> *      string. This is similar to strcpy, but it will enforce a maximum size for the copied string and will </span>
<a name="l01725"></a>01725 <span class="comment"> *      ensure it is terminated with a null.</span>
<a name="l01726"></a>01726 <span class="comment"> *  @param dest Pointer to a pointer that will hold the address of the allocated block.</span>
<a name="l01727"></a>01727 <span class="comment"> *  @param destMax Maximum size of the target string.</span>
<a name="l01728"></a>01728 <span class="comment"> *  @param src String to copy</span>
<a name="l01729"></a>01729 <span class="comment"> *  @return Returns the number of characters in the target string.</span>
<a name="l01730"></a>01730 <span class="comment"> *  @ingroup MprString</span>
<a name="l01731"></a>01731 <span class="comment"> */</span>
<a name="l01732"></a>01732 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#239b2debb47dd4553372d0ad89294521" title="Copy a string.">mprStrcpy</a>(<span class="keywordtype">char</span> *dest, <span class="keywordtype">int</span> destMax, cchar *src);
<a name="l01733"></a>01733 <span class="comment"></span>
<a name="l01734"></a>01734 <span class="comment">/**</span>
<a name="l01735"></a>01735 <span class="comment"> *  Copy characters from a string.</span>
<a name="l01736"></a>01736 <span class="comment"> *  @description Safe replacement for strncpy. Copy bytes from a string and ensure the target string is not overflowed. </span>
<a name="l01737"></a>01737 <span class="comment"> *      The call returns the length of the resultant string or an error code if it will not fit into the target</span>
<a name="l01738"></a>01738 <span class="comment"> *      string. This is similar to strcpy, but it will enforce a maximum size for the copied string and will </span>
<a name="l01739"></a>01739 <span class="comment"> *      ensure it is terminated with a null.</span>
<a name="l01740"></a>01740 <span class="comment"> *  @param dest Pointer to a pointer that will hold the address of the allocated block.</span>
<a name="l01741"></a>01741 <span class="comment"> *  @param destMax Maximum size of the target string.</span>
<a name="l01742"></a>01742 <span class="comment"> *  @param src String to copy</span>
<a name="l01743"></a>01743 <span class="comment"> *  @param count Maximum count of characters to copy</span>
<a name="l01744"></a>01744 <span class="comment"> *  @return Returns the number of characters in the target string.</span>
<a name="l01745"></a>01745 <span class="comment"> *  @ingroup MprString</span>
<a name="l01746"></a>01746 <span class="comment"> */</span>
<a name="l01747"></a>01747 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#af8ce98847bb93316ca5f0c0ca9fcb67" title="Copy characters from a string.">mprStrcpyCount</a>(<span class="keywordtype">char</span> *dest, <span class="keywordtype">int</span> destMax, cchar *src, <span class="keywordtype">int</span> count);
<a name="l01748"></a>01748 <span class="comment"></span>
<a name="l01749"></a>01749 <span class="comment">/**</span>
<a name="l01750"></a>01750 <span class="comment"> *  Find a substring.</span>
<a name="l01751"></a>01751 <span class="comment"> *  @description Locate the first occurrence of pattern in a string, but do not search more than the given length. </span>
<a name="l01752"></a>01752 <span class="comment"> *  @param str Pointer to the string to search.</span>
<a name="l01753"></a>01753 <span class="comment"> *  @param pattern String pattern to search for.</span>
<a name="l01754"></a>01754 <span class="comment"> *  @param len Count of characters in the pattern to actually search for.</span>
<a name="l01755"></a>01755 <span class="comment"> *  @return Returns the number of characters in the target string.</span>
<a name="l01756"></a>01756 <span class="comment"> *  @ingroup MprString</span>
<a name="l01757"></a>01757 <span class="comment"> */</span>
<a name="l01758"></a>01758 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#3707c7892d469df5810a249fa1a51a69" title="Find a substring.">mprStrnstr</a>(cchar *str, cchar *pattern, <span class="keywordtype">int</span> len);
<a name="l01759"></a>01759 <span class="comment"></span>
<a name="l01760"></a>01760 <span class="comment">/**</span>
<a name="l01761"></a>01761 <span class="comment"> *  Compare strings.</span>
<a name="l01762"></a>01762 <span class="comment"> *  @description Compare two strings. This is a safe replacement for strcmp. It can handle null args.</span>
<a name="l01763"></a>01763 <span class="comment"> *  @param str1 First string to compare.</span>
<a name="l01764"></a>01764 <span class="comment"> *  @param str2 Second string to compare.</span>
<a name="l01765"></a>01765 <span class="comment"> *  @return Returns zero if the strings are identical. Return -1 if the first string is less than the second. Return 1</span>
<a name="l01766"></a>01766 <span class="comment"> *      if the first string is greater than the second.</span>
<a name="l01767"></a>01767 <span class="comment"> *  @ingroup MprString</span>
<a name="l01768"></a>01768 <span class="comment"> */</span>
<a name="l01769"></a>01769 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#937b35fb3e4a7cdac84e1c6985db6cc8" title="Compare strings.">mprStrcmp</a>(cchar *str1, cchar *str2);
<a name="l01770"></a>01770 <span class="comment"></span>
<a name="l01771"></a>01771 <span class="comment">/**</span>
<a name="l01772"></a>01772 <span class="comment"> *  Compare strings ignoring case.</span>
<a name="l01773"></a>01773 <span class="comment"> *  @description Compare two strings ignoring case differences. This call operates similarly to strcmp.</span>
<a name="l01774"></a>01774 <span class="comment"> *  @param str1 First string to compare.</span>
<a name="l01775"></a>01775 <span class="comment"> *  @param str2 Second string to compare. </span>
<a name="l01776"></a>01776 <span class="comment"> *  @return Returns zero if the strings are equivalent, &lt; 0 if s1 sorts lower than s2 in the collating sequence </span>
<a name="l01777"></a>01777 <span class="comment"> *      or &gt; 0 if it sorts higher.</span>
<a name="l01778"></a>01778 <span class="comment"> *  @ingroup MprString</span>
<a name="l01779"></a>01779 <span class="comment"> */</span>
<a name="l01780"></a>01780 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#e15c6b644b07a706125e13656d3be03b" title="Compare strings ignoring case.">mprStrcmpAnyCase</a>(cchar *str1, cchar *str2);
<a name="l01781"></a>01781 <span class="comment"></span>
<a name="l01782"></a>01782 <span class="comment">/**</span>
<a name="l01783"></a>01783 <span class="comment"> *  Compare strings ignoring case.</span>
<a name="l01784"></a>01784 <span class="comment"> *  @description Compare two strings ignoring case differences for a given string length. This call operates </span>
<a name="l01785"></a>01785 <span class="comment"> *      similarly to strncmp.</span>
<a name="l01786"></a>01786 <span class="comment"> *  @param str1 First string to compare.</span>
<a name="l01787"></a>01787 <span class="comment"> *  @param str2 Second string to compare.</span>
<a name="l01788"></a>01788 <span class="comment"> *  @param len Length of characters to compare.</span>
<a name="l01789"></a>01789 <span class="comment"> *  @return Returns zero if the strings are equivalent, &lt; 0 if s1 sorts lower than s2 in the collating sequence </span>
<a name="l01790"></a>01790 <span class="comment"> *      or &gt; 0 if it sorts higher.</span>
<a name="l01791"></a>01791 <span class="comment"> *  @ingroup MprString</span>
<a name="l01792"></a>01792 <span class="comment"> */</span>
<a name="l01793"></a>01793 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#12ece4a3c6060f5c09051b17212f14f8" title="Compare strings ignoring case.">mprStrcmpAnyCaseCount</a>(cchar *str1, cchar *str2, <span class="keywordtype">int</span> len);
<a name="l01794"></a>01794 <span class="comment"></span>
<a name="l01795"></a>01795 <span class="comment">/**</span>
<a name="l01796"></a>01796 <span class="comment"> *  Return the length of a string.</span>
<a name="l01797"></a>01797 <span class="comment"> *  @description Safe replacement for strlen. This call returns the length of a string and tests if the length is </span>
<a name="l01798"></a>01798 <span class="comment"> *      less than a given maximum.</span>
<a name="l01799"></a>01799 <span class="comment"> *  @param src String to measure.</span>
<a name="l01800"></a>01800 <span class="comment"> *  @param max Maximum length for the string</span>
<a name="l01801"></a>01801 <span class="comment"> *  @return Returns the length of the string or MPR_ERR_WONT_FIT if the length is greater than \a max.</span>
<a name="l01802"></a>01802 <span class="comment"> *  @ingroup MprString</span>
<a name="l01803"></a>01803 <span class="comment"> */</span>
<a name="l01804"></a>01804 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#d672f4f5cd20ea78325864b263460133" title="Return the length of a string.">mprStrlen</a>(cchar *src, <span class="keywordtype">int</span> max);
<a name="l01805"></a>01805 <span class="comment"></span>
<a name="l01806"></a>01806 <span class="comment">/**</span>
<a name="l01807"></a>01807 <span class="comment"> *  Convert a string to lower case.</span>
<a name="l01808"></a>01808 <span class="comment"> *  @description Convert a string to its lower case equivalent.</span>
<a name="l01809"></a>01809 <span class="comment"> *  @param str String to convert.</span>
<a name="l01810"></a>01810 <span class="comment"> *  @return Returns a pointer to the converted string. Will always equal str.</span>
<a name="l01811"></a>01811 <span class="comment"> *  @ingroup MprString</span>
<a name="l01812"></a>01812 <span class="comment"> */</span>
<a name="l01813"></a>01813 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#b9c7e8c93945fa0bc4aa3608ea2b9802" title="Convert a string to lower case.">mprStrLower</a>(<span class="keywordtype">char</span> *str);
<a name="l01814"></a>01814 <span class="comment"></span>
<a name="l01815"></a>01815 <span class="comment">/**</span>
<a name="l01816"></a>01816 <span class="comment"> *  Convert a string to upper case.</span>
<a name="l01817"></a>01817 <span class="comment"> *  @description Convert a string to its upper case equivalent.</span>
<a name="l01818"></a>01818 <span class="comment"> *  @param str String to convert.</span>
<a name="l01819"></a>01819 <span class="comment"> *  @return Returns a pointer to the converted string. Will always equal str.</span>
<a name="l01820"></a>01820 <span class="comment"> *  @ingroup MprString</span>
<a name="l01821"></a>01821 <span class="comment"> */</span>
<a name="l01822"></a>01822 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#f746a3a94464da0f6991d88d3d76ae75" title="Convert a string to upper case.">mprStrUpper</a>(<span class="keywordtype">char</span> *str);
<a name="l01823"></a>01823 <span class="comment"></span>
<a name="l01824"></a>01824 <span class="comment">/**</span>
<a name="l01825"></a>01825 <span class="comment"> *  Trim a string.</span>
<a name="l01826"></a>01826 <span class="comment"> *  @description Trim leading and trailing characters off a string.</span>
<a name="l01827"></a>01827 <span class="comment"> *  @param str String to trim.</span>
<a name="l01828"></a>01828 <span class="comment"> *  @param set String of characters to remove.</span>
<a name="l01829"></a>01829 <span class="comment"> *  @return Returns a pointer to the trimmed string. May not equal \a str. If \a str was dynamically allocated, </span>
<a name="l01830"></a>01830 <span class="comment"> *      do not call mprFree on the returned trimmed pointer. You must use \a str when calling mprFree.</span>
<a name="l01831"></a>01831 <span class="comment"> *  @ingroup MprString</span>
<a name="l01832"></a>01832 <span class="comment"> */</span>
<a name="l01833"></a>01833 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#cab0129f8454deb9debf1513ddf15738" title="Trim a string.">mprStrTrim</a>(<span class="keywordtype">char</span> *str, cchar *<span class="keyword">set</span>);
<a name="l01834"></a>01834 <span class="comment"></span>
<a name="l01835"></a>01835 <span class="comment">/**</span>
<a name="l01836"></a>01836 <span class="comment"> *  Tokenize a string</span>
<a name="l01837"></a>01837 <span class="comment"> *  @description Split a string into tokens.</span>
<a name="l01838"></a>01838 <span class="comment"> *  @param str String to tokenize.</span>
<a name="l01839"></a>01839 <span class="comment"> *  @param delim String of characters to use as token separators.</span>
<a name="l01840"></a>01840 <span class="comment"> *  @param last Last token pointer.</span>
<a name="l01841"></a>01841 <span class="comment"> *  @return Returns a pointer to the next token.</span>
<a name="l01842"></a>01842 <span class="comment"> *  @ingroup MprString</span>
<a name="l01843"></a>01843 <span class="comment"> */</span>
<a name="l01844"></a>01844 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#607579dc34bc84ebea2b67d7f9d55641" title="Tokenize a string.">mprStrTok</a>(<span class="keywordtype">char</span> *str, cchar *delim, <span class="keywordtype">char</span> **last);
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 <span class="preprocessor">#if BLD_DEBUG</span>
<a name="l01847"></a>01847 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01848"></a>01848 <span class="comment"> *  Just for easy debugging. Adds a "\n" automatically.</span>
<a name="l01849"></a>01849 <span class="comment"> */</span>
<a name="l01850"></a>01850 <span class="keyword">extern</span> <span class="keywordtype">int</span> print(cchar *fmt, ...);
<a name="l01851"></a>01851 <span class="preprocessor">#endif</span>
<a name="l01852"></a>01852 <span class="preprocessor"></span><span class="comment"></span>
<a name="l01853"></a>01853 <span class="comment">/**</span>
<a name="l01854"></a>01854 <span class="comment"> *  Buffer refill callback function</span>
<a name="l01855"></a>01855 <span class="comment"> *  @description Function to call when the buffer is depleted and needs more data.</span>
<a name="l01856"></a>01856 <span class="comment"> *  @param buf Instance of an MprBuf</span>
<a name="l01857"></a>01857 <span class="comment"> *  @param arg Data argument supplied to #mprSetBufRefillProc</span>
<a name="l01858"></a>01858 <span class="comment"> *  @returns The callback should return 0 if successful, otherwise a negative error code.</span>
<a name="l01859"></a>01859 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01860"></a>01860 <span class="comment"> */</span>
<a name="l01861"></a><a class="code" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7">01861</a> <span class="keyword">typedef</span> int (*<a class="code" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7" title="Buffer refill callback function.">MprBufProc</a>)(<span class="keyword">struct </span>MprBuf* bp, <span class="keywordtype">void</span> *arg);
<a name="l01862"></a>01862 <span class="comment"></span>
<a name="l01863"></a>01863 <span class="comment">/**</span>
<a name="l01864"></a>01864 <span class="comment"> *  Dynamic Buffer Module</span>
<a name="l01865"></a>01865 <span class="comment"> *  @description MprBuf is a flexible, dynamic growable buffer structure. It has start and end pointers to the</span>
<a name="l01866"></a>01866 <span class="comment"> *      data buffer which act as read/write pointers. Routines are provided to get and put data into and out of the</span>
<a name="l01867"></a>01867 <span class="comment"> *      buffer and automatically advance the appropriate start/end pointer. By definition, the buffer is empty when</span>
<a name="l01868"></a>01868 <span class="comment"> *      the start pointer == the end pointer. Buffers can be created with a fixed size or can grow dynamically as </span>
<a name="l01869"></a>01869 <span class="comment"> *      more data is added to the buffer. </span>
<a name="l01870"></a>01870 <span class="comment"> *  \n\n</span>
<a name="l01871"></a>01871 <span class="comment"> *  For performance, the specification of MprBuf is deliberately exposed. All members of MprBuf are implicitly public.</span>
<a name="l01872"></a>01872 <span class="comment"> *  However, it is still recommended that wherever possible, you use the accessor routines provided.</span>
<a name="l01873"></a>01873 <span class="comment"> *  @stability Evolving.</span>
<a name="l01874"></a>01874 <span class="comment"> *  @see MprBuf, mprCreateBuf, mprSetBufMax, mprStealBuf, mprAdjustBufStart, mprAdjustBufEnd, mprCopyBufDown,</span>
<a name="l01875"></a>01875 <span class="comment"> *      mprFlushBuf, mprGetCharFromBuf, mprGetBlockFromBuf, mprGetBufLength, mprGetBufOrigin, mprGetBufSize,</span>
<a name="l01876"></a>01876 <span class="comment"> *      mprGetBufEnd, mprGetBufSpace, mprGetGrowBuf, mprGrowBuf, mprInsertCharToBuf,</span>
<a name="l01877"></a>01877 <span class="comment"> *      mprLookAtNextCharInBuf, mprLookAtLastCharInBuf, mprPutCharToBuf, mprPutBlockToBuf, mprPutIntToBuf,</span>
<a name="l01878"></a>01878 <span class="comment"> *      mprPutStringToBuf, mprPutFmtToBuf, mprRefillBuf, mprResetBufIfEmpty, mprSetBufSize, mprGetBufRefillProc,</span>
<a name="l01879"></a>01879 <span class="comment"> *      mprSetBufRefillProc, mprFree, MprBufProc</span>
<a name="l01880"></a>01880 <span class="comment"> *  @defgroup MprBuf MprBuf</span>
<a name="l01881"></a>01881 <span class="comment"> */</span>
<a name="l01882"></a>01882 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprBuf {
<a name="l01883"></a>01883     <span class="keywordtype">char</span>            *data;              <span class="comment">/**&lt; Actual buffer for data */</span>
<a name="l01884"></a>01884     <span class="keywordtype">char</span>            *endbuf;            <span class="comment">/**&lt; Pointer one past the end of buffer */</span>
<a name="l01885"></a>01885     <span class="keywordtype">char</span>            *start;             <span class="comment">/**&lt; Pointer to next data char */</span>
<a name="l01886"></a>01886     <span class="keywordtype">char</span>            *end;               <span class="comment">/**&lt; Pointer one past the last data chr */</span>
<a name="l01887"></a>01887     <span class="keywordtype">int</span>             buflen;             <span class="comment">/**&lt; Current size of buffer */</span>
<a name="l01888"></a>01888     <span class="keywordtype">int</span>             maxsize;            <span class="comment">/**&lt; Max size the buffer can ever grow */</span>
<a name="l01889"></a>01889     <span class="keywordtype">int</span>             growBy;             <span class="comment">/**&lt; Next growth increment to use */</span>
<a name="l01890"></a>01890     <a class="code" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7" title="Buffer refill callback function.">MprBufProc</a>      refillProc;         <span class="comment">/**&lt; Auto-refill procedure */</span>
<a name="l01891"></a>01891     <span class="keywordtype">void</span>            *refillArg;         <span class="comment">/**&lt; Refill arg */</span>
<a name="l01892"></a>01892 } MprBuf;
<a name="l01893"></a>01893 <span class="comment"></span>
<a name="l01894"></a>01894 <span class="comment">/**</span>
<a name="l01895"></a>01895 <span class="comment"> *  Create a new buffer</span>
<a name="l01896"></a>01896 <span class="comment"> *  @description Create a new buffer. Use mprFree to free the buffer</span>
<a name="l01897"></a>01897 <span class="comment"> *  @param ctx Any memory context allocated by the MPR</span>
<a name="l01898"></a>01898 <span class="comment"> *  @param initialSize Initial size of the buffer</span>
<a name="l01899"></a>01899 <span class="comment"> *  @param maxSize Maximum size the buffer can grow to</span>
<a name="l01900"></a>01900 <span class="comment"> *  @return a new buffer</span>
<a name="l01901"></a>01901 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01902"></a>01902 <span class="comment"> */</span>
<a name="l01903"></a>01903 <span class="keyword">extern</span> MprBuf *<a class="code" href="group___mpr_buf.html#ga2d850779c9881637028fcf54a1ebe30" title="Create a new buffer.">mprCreateBuf</a>(MprCtx ctx, <span class="keywordtype">int</span> initialSize, <span class="keywordtype">int</span> maxSize);
<a name="l01904"></a>01904 <span class="comment"></span>
<a name="l01905"></a>01905 <span class="comment">/**</span>
<a name="l01906"></a>01906 <span class="comment"> *  Set the maximum buffer size</span>
<a name="l01907"></a>01907 <span class="comment"> *  @description Update the maximum buffer size set when the buffer was created</span>
<a name="l01908"></a>01908 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01909"></a>01909 <span class="comment"> *  @param maxSize New maximum size the buffer can grow to</span>
<a name="l01910"></a>01910 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01911"></a>01911 <span class="comment"> */</span>
<a name="l01912"></a>01912 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#gea06aa1b68fc99c1038e07066136fee3" title="Set the maximum buffer size.">mprSetBufMax</a>(MprBuf *buf, <span class="keywordtype">int</span> maxSize);
<a name="l01913"></a>01913 <span class="comment"></span>
<a name="l01914"></a>01914 <span class="comment">/**</span>
<a name="l01915"></a>01915 <span class="comment"> *  Steal the buffer memory from a buffer</span>
<a name="l01916"></a>01916 <span class="comment"> *  @description Steal ownership of the buffer memory from the buffer structure. All MPR memory is owned by a </span>
<a name="l01917"></a>01917 <span class="comment"> *      memory context and the contents of the buffer is owned by the MprBuf object. Stealing the buffer content </span>
<a name="l01918"></a>01918 <span class="comment"> *      memory is useful to preserve the buffer contents after the buffer is freed</span>
<a name="l01919"></a>01919 <span class="comment"> *  @param ctx Memory context to won the memory for the buffer</span>
<a name="l01920"></a>01920 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01921"></a>01921 <span class="comment"> *  @return pointer to the buffer contents. Use mprGetBufLength before calling mprStealBuf to determine the resulting</span>
<a name="l01922"></a>01922 <span class="comment"> *      size of the contents.</span>
<a name="l01923"></a>01923 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01924"></a>01924 <span class="comment"> */</span>
<a name="l01925"></a>01925 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_buf.html#g5800cbdbb6bac03b54fba8af893603b0" title="Steal the buffer memory from a buffer.">mprStealBuf</a>(MprCtx ctx, MprBuf *buf);
<a name="l01926"></a>01926 <span class="comment"></span>
<a name="l01927"></a>01927 <span class="comment">/**</span>
<a name="l01928"></a>01928 <span class="comment"> *  Add a null character to the buffer contents.</span>
<a name="l01929"></a>01929 <span class="comment"> *  @description Add a null byte but do not change the buffer content lengths. The null is added outside the</span>
<a name="l01930"></a>01930 <span class="comment"> *      "official" content length. This is useful when calling #mprGetBufStart and using the returned pointer </span>
<a name="l01931"></a>01931 <span class="comment"> *      as a "C" string pointer.</span>
<a name="l01932"></a>01932 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01933"></a>01933 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01934"></a>01934 <span class="comment"> */</span>
<a name="l01935"></a>01935 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#g159c096de4aec192e25b275f1f5e031d" title="Add a null character to the buffer contents.">mprAddNullToBuf</a>(MprBuf *buf);
<a name="l01936"></a>01936 <span class="comment"></span>
<a name="l01937"></a>01937 <span class="comment">/**</span>
<a name="l01938"></a>01938 <span class="comment"> *  Adjust the buffer start position</span>
<a name="l01939"></a>01939 <span class="comment"> *  @description Adjust the buffer start position by the specified amount. This is typically used to advance the</span>
<a name="l01940"></a>01940 <span class="comment"> *      start position as content is consumed. Adjusting the start or end position will change the value returned</span>
<a name="l01941"></a>01941 <span class="comment"> *      by #mprGetBufLength. If using the mprGetBlock or mprGetChar routines, adjusting the start position is</span>
<a name="l01942"></a>01942 <span class="comment"> *      done automatically.</span>
<a name="l01943"></a>01943 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01944"></a>01944 <span class="comment"> *  @param count Positive or negative count of bytes to adjust the start position.</span>
<a name="l01945"></a>01945 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01946"></a>01946 <span class="comment"> */</span>
<a name="l01947"></a>01947 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#g1fbe536bbdd8bc3f68a5246f69305994" title="Adjust the buffer start position.">mprAdjustBufStart</a>(MprBuf *buf, <span class="keywordtype">int</span> count);
<a name="l01948"></a>01948 <span class="comment"></span>
<a name="l01949"></a>01949 <span class="comment">/**</span>
<a name="l01950"></a>01950 <span class="comment"> *  Adjust the buffer end position</span>
<a name="l01951"></a>01951 <span class="comment"> *  @description Adjust the buffer start end position by the specified amount. This is typically used to advance the</span>
<a name="l01952"></a>01952 <span class="comment"> *      end position as content is appended to the buffer. Adjusting the start or end position will change the value </span>
<a name="l01953"></a>01953 <span class="comment"> *      returned by #mprGetBufLength. If using the mprPutBlock or mprPutChar routines, adjusting the end position is</span>
<a name="l01954"></a>01954 <span class="comment"> *      done automatically.</span>
<a name="l01955"></a>01955 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01956"></a>01956 <span class="comment"> *  @param count Positive or negative count of bytes to adjust the start position.</span>
<a name="l01957"></a>01957 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01958"></a>01958 <span class="comment"> */</span>
<a name="l01959"></a>01959 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#g61c8f33c54c45ad4d6bf33d8d72543c1" title="Adjust the buffer end position.">mprAdjustBufEnd</a>(MprBuf *buf, <span class="keywordtype">int</span> count);
<a name="l01960"></a>01960 <span class="comment"></span>
<a name="l01961"></a>01961 <span class="comment">/**</span>
<a name="l01962"></a>01962 <span class="comment"> *  Compact the buffer contents</span>
<a name="l01963"></a>01963 <span class="comment"> *  @description Compact the buffer contents by copying the contents down to start the the buffer origin.</span>
<a name="l01964"></a>01964 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01965"></a>01965 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01966"></a>01966 <span class="comment"> */</span>
<a name="l01967"></a>01967 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#gab2501188e2f3f59008f8f27e14732e9" title="Compact the buffer contents.">mprCompactBuf</a>(MprBuf *buf);
<a name="l01968"></a>01968 <span class="comment"></span>
<a name="l01969"></a>01969 <span class="comment">/**</span>
<a name="l01970"></a>01970 <span class="comment"> *  Flush the buffer contents</span>
<a name="l01971"></a>01971 <span class="comment"> *  @description Discard the buffer contents and reset the start end content pointers.</span>
<a name="l01972"></a>01972 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01973"></a>01973 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01974"></a>01974 <span class="comment"> */</span>
<a name="l01975"></a>01975 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#g453b62a6659fc9fa4d041165dad7461e" title="Flush the buffer contents.">mprFlushBuf</a>(MprBuf *buf);
<a name="l01976"></a>01976 <span class="comment"></span>
<a name="l01977"></a>01977 <span class="comment">/**</span>
<a name="l01978"></a>01978 <span class="comment"> *  Get a character from the buffer</span>
<a name="l01979"></a>01979 <span class="comment"> *  @description Get the next byte from the buffer start and advance the start position.</span>
<a name="l01980"></a>01980 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01981"></a>01981 <span class="comment"> *  @return The character or -1 if the buffer is empty.</span>
<a name="l01982"></a>01982 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01983"></a>01983 <span class="comment"> */</span>
<a name="l01984"></a>01984 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#gf128b71005bdd12507110e1f21b483d4" title="Get a character from the buffer.">mprGetCharFromBuf</a>(MprBuf *buf);
<a name="l01985"></a>01985 <span class="comment"></span>
<a name="l01986"></a>01986 <span class="comment">/**</span>
<a name="l01987"></a>01987 <span class="comment"> *  Get a block of data from the buffer</span>
<a name="l01988"></a>01988 <span class="comment"> *  @description Get a block of data from the buffer start and advance the start position. If the requested</span>
<a name="l01989"></a>01989 <span class="comment"> *      length is greater than the available buffer content, then return whatever data is available.</span>
<a name="l01990"></a>01990 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l01991"></a>01991 <span class="comment"> *  @param blk Destination block for the read data. </span>
<a name="l01992"></a>01992 <span class="comment"> *  @param count Count of bytes to read from the buffer.</span>
<a name="l01993"></a>01993 <span class="comment"> *  @return The count of bytes rread into the block or -1 if the buffer is empty.</span>
<a name="l01994"></a>01994 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l01995"></a>01995 <span class="comment"> */</span>
<a name="l01996"></a>01996 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g3a1388925b9ab4a209b0610cd674139f" title="Get a block of data from the buffer.">mprGetBlockFromBuf</a>(MprBuf *buf, <span class="keywordtype">char</span> *blk, <span class="keywordtype">int</span> count);
<a name="l01997"></a>01997 <span class="comment"></span>
<a name="l01998"></a>01998 <span class="comment">/**</span>
<a name="l01999"></a>01999 <span class="comment"> *  Get the buffer content length.</span>
<a name="l02000"></a>02000 <span class="comment"> *  @description Get the length of the buffer contents. This is not the same as the buffer size which may be larger.</span>
<a name="l02001"></a>02001 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02002"></a>02002 <span class="comment"> *  @returns The length of the content stored in the buffer.</span>
<a name="l02003"></a>02003 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02004"></a>02004 <span class="comment"> */</span>
<a name="l02005"></a>02005 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g4d39e8467818e491ecec68a4db8df054" title="Get the buffer content length.">mprGetBufLength</a>(MprBuf *buf);
<a name="l02006"></a>02006 <span class="comment"></span>
<a name="l02007"></a>02007 <span class="comment">/**</span>
<a name="l02008"></a>02008 <span class="comment"> *  Get the origin of the buffer content storage.</span>
<a name="l02009"></a>02009 <span class="comment"> *  @description Get a pointer to the start of the buffer content storage. This may not be equal to the start of</span>
<a name="l02011"></a>02011 <span class="comment"> *      the buffer content if #mprAdjustBufStart has been called. Use #mprGetBufSize to determine the length</span>
<a name="l02011"></a>02011 <span class="comment"> *      of the buffer content storage array. </span>
<a name="l02012"></a>02012 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02013"></a>02013 <span class="comment"> *  @returns A pointer to the buffer content storage.</span>
<a name="l02014"></a>02014 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02015"></a>02015 <span class="comment"> */</span>
<a name="l02016"></a>02016 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_buf.html#g962aeff07a87ab52da3bcd1973fe801b" title="Get the origin of the buffer content storage.">mprGetBufOrigin</a>(MprBuf *buf);
<a name="l02017"></a>02017 <span class="comment"></span>
<a name="l02018"></a>02018 <span class="comment">/**</span>
<a name="l02019"></a>02019 <span class="comment"> *  Get the current size of the buffer content storage.</span>
<a name="l02020"></a>02020 <span class="comment"> *  @description This returns the size of the memory block allocated for storing the buffer contents.</span>
<a name="l02021"></a>02021 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02022"></a>02022 <span class="comment"> *  @returns The size of the buffer content storage.</span>
<a name="l02023"></a>02023 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02024"></a>02024 <span class="comment"> */</span>
<a name="l02025"></a>02025 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#ga609f1dc4e3f8315949c4cf93e27aff1" title="Get the current size of the buffer content storage.">mprGetBufSize</a>(MprBuf *buf);
<a name="l02026"></a>02026 <span class="comment"></span>
<a name="l02027"></a>02027 <span class="comment">/**</span>
<a name="l02028"></a>02028 <span class="comment"> *  Get the space available to store content</span>
<a name="l02029"></a>02029 <span class="comment"> *  @description Get the number of bytes available to store content in the buffer</span>
<a name="l02030"></a>02030 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02031"></a>02031 <span class="comment"> *  @returns The number of bytes available</span>
<a name="l02032"></a>02032 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02033"></a>02033 <span class="comment"> */</span>
<a name="l02034"></a>02034 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g6c6646d8f5933dfbf31983a374b491e7" title="Get the space available to store content.">mprGetBufSpace</a>(MprBuf *buf);
<a name="l02035"></a>02035 <span class="comment"></span>
<a name="l02036"></a>02036 <span class="comment">/**</span>
<a name="l02037"></a>02037 <span class="comment"> *  Get the start of the buffer contents</span>
<a name="l02038"></a>02038 <span class="comment"> *  @description Get a pointer to the start of the buffer contents. Use #mprGetBufLength to determine the length</span>
<a name="l02039"></a>02039 <span class="comment"> *      of the content. Use #mprGetBufEnd to get a pointer to the location after the end of the content.</span>
<a name="l02040"></a>02040 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02041"></a>02041 <span class="comment"> *  @returns Pointer to the start of the buffer data contents</span>
<a name="l02042"></a>02042 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02043"></a>02043 <span class="comment"> */</span>
<a name="l02044"></a>02044 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_buf.html#gc982291efef3d49cce4bc2ecec6566e5" title="Get the start of the buffer contents.">mprGetBufStart</a>(MprBuf *buf);
<a name="l02045"></a>02045 <span class="comment"></span>
<a name="l02046"></a>02046 <span class="comment">/**</span>
<a name="l02047"></a>02047 <span class="comment"> *  Get a reference to the end of the buffer contents</span>
<a name="l02048"></a>02048 <span class="comment"> *  @description Get a pointer to the location immediately after the end of the buffer contents.</span>
<a name="l02049"></a>02049 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02050"></a>02050 <span class="comment"> *  @returns Pointer to the end of the buffer data contents. Points to the location one after the last data byte.</span>
<a name="l02051"></a>02051 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02052"></a>02052 <span class="comment"> */</span>
<a name="l02053"></a>02053 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_buf.html#gbd1fae7a41a8c38220de4f06e6d0e053" title="Get a reference to the end of the buffer contents.">mprGetBufEnd</a>(MprBuf *buf);
<a name="l02054"></a>02054 <span class="comment"></span>
<a name="l02055"></a>02055 <span class="comment">/**</span>
<a name="l02056"></a>02056 <span class="comment"> *  Grow the buffer</span>
<a name="l02057"></a>02057 <span class="comment"> *  @description Grow the storage allocated for content for the buffer. The new size must be less than the maximum</span>
<a name="l02058"></a>02058 <span class="comment"> *      limit specified via #mprCreateBuf or #mprSetBufSize.</span>
<a name="l02059"></a>02059 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02060"></a>02060 <span class="comment"> *  @param count Count of bytes by which to grow the buffer content size. </span>
<a name="l02061"></a>02061 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02062"></a>02062 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02063"></a>02063 <span class="comment"> */</span>
<a name="l02064"></a>02064 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g6c40bdb62af47cbae761c6bfdc7da11b" title="Grow the buffer.">mprGrowBuf</a>(MprBuf *buf, <span class="keywordtype">int</span> count);
<a name="l02065"></a>02065 <span class="comment"></span>
<a name="l02066"></a>02066 <span class="comment">/**</span>
<a name="l02067"></a>02067 <span class="comment"> *  Insert a character into the buffer</span>
<a name="l02068"></a>02068 <span class="comment"> *  @description Insert a character into to the buffer prior to the current buffer start point.</span>
<a name="l02069"></a>02069 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02070"></a>02070 <span class="comment"> *  @param c Character to append.</span>
<a name="l02071"></a>02071 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02072"></a>02072 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02073"></a>02073 <span class="comment"> */</span>
<a name="l02074"></a>02074 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g6f91b177cd36508c9d470636b04fa7b5" title="Insert a character into the buffer.">mprInsertCharToBuf</a>(MprBuf *buf, <span class="keywordtype">int</span> c);
<a name="l02075"></a>02075 <span class="comment"></span>
<a name="l02076"></a>02076 <span class="comment">/**</span>
<a name="l02077"></a>02077 <span class="comment"> *  Peek at the next character in the buffer</span>
<a name="l02078"></a>02078 <span class="comment"> *  @description Non-destructively return the next character from the start position in the buffer. </span>
<a name="l02079"></a>02079 <span class="comment"> *      The character is returned and the start position is not altered.</span>
<a name="l02080"></a>02080 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02081"></a>02081 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02082"></a>02082 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02083"></a>02083 <span class="comment"> */</span>
<a name="l02084"></a>02084 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#gbe01ab970d735db5a92cea5f9456de5e" title="Peek at the next character in the buffer.">mprLookAtNextCharInBuf</a>(MprBuf *buf);
<a name="l02085"></a>02085 <span class="comment"></span>
<a name="l02086"></a>02086 <span class="comment">/**</span>
<a name="l02087"></a>02087 <span class="comment"> *  Peek at the last character in the buffer</span>
<a name="l02088"></a>02088 <span class="comment"> *  @description Non-destructively return the last character from just prior to the end position in the buffer. </span>
<a name="l02089"></a>02089 <span class="comment"> *      The character is returned and the end position is not altered.</span>
<a name="l02090"></a>02090 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02091"></a>02091 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02092"></a>02092 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02093"></a>02093 <span class="comment"> */</span>
<a name="l02094"></a>02094 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g9ae5abc2e8c8b3359ca450e505564359" title="Peek at the last character in the buffer.">mprLookAtLastCharInBuf</a>(MprBuf *buf);
<a name="l02095"></a>02095 <span class="comment"></span>
<a name="l02096"></a>02096 <span class="comment">/**</span>
<a name="l02097"></a>02097 <span class="comment"> *  Put a character to the buffer.</span>
<a name="l02098"></a>02098 <span class="comment"> *  @description Append a character to the buffer at the end position and increment the end pointer.</span>
<a name="l02099"></a>02099 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02100"></a>02100 <span class="comment"> *  @param c Character to append</span>
<a name="l02101"></a>02101 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02102"></a>02102 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02103"></a>02103 <span class="comment"> */</span>
<a name="l02104"></a>02104 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g5ab66b5d96db8b33e3bb0c3bbb9c90e2" title="Put a character to the buffer.">mprPutCharToBuf</a>(MprBuf *buf, <span class="keywordtype">int</span> c);
<a name="l02105"></a>02105 <span class="comment"></span>
<a name="l02106"></a>02106 <span class="comment">/**</span>
<a name="l02107"></a>02107 <span class="comment"> *  Put padding characters to the buffer.</span>
<a name="l02108"></a>02108 <span class="comment"> *  @description Append padding characters to the buffer at the end position and increment the end pointer.</span>
<a name="l02109"></a>02109 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02110"></a>02110 <span class="comment"> *  @param c Character to append</span>
<a name="l02111"></a>02111 <span class="comment"> *  @param count Count of pad characters to put</span>
<a name="l02112"></a>02112 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02113"></a>02113 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02114"></a>02114 <span class="comment"> */</span>
<a name="l02115"></a>02115 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g3a72ff88a352a7d2a5cd01e46fb1fdd1" title="Put padding characters to the buffer.">mprPutPadToBuf</a>(MprBuf *buf, <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> count);
<a name="l02116"></a>02116 <span class="comment"></span>
<a name="l02117"></a>02117 <span class="comment">/**</span>
<a name="l02118"></a>02118 <span class="comment"> *  Put a block to the buffer.</span>
<a name="l02119"></a>02119 <span class="comment"> *  @description Append a block of data  to the buffer at the end position and increment the end pointer.</span>
<a name="l02120"></a>02120 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02121"></a>02121 <span class="comment"> *  @param ptr Block to append</span>
<a name="l02122"></a>02122 <span class="comment"> *  @param size Size of block to append</span>
<a name="l02123"></a>02123 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02124"></a>02124 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02125"></a>02125 <span class="comment"> */</span>
<a name="l02126"></a>02126 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g3a8934d430c8345cd1e19b42173b1336" title="Put a block to the buffer.">mprPutBlockToBuf</a>(MprBuf *buf, cchar *ptr, <span class="keywordtype">int</span> size);
<a name="l02127"></a>02127 <span class="comment"></span>
<a name="l02128"></a>02128 <span class="comment">/**</span>
<a name="l02129"></a>02129 <span class="comment"> *  Put an integer to the buffer.</span>
<a name="l02130"></a>02130 <span class="comment"> *  @description Append a integer to the buffer at the end position and increment the end pointer.</span>
<a name="l02131"></a>02131 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02132"></a>02132 <span class="comment"> *  @param i Integer to append to the buffer</span>
<a name="l02133"></a>02133 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02134"></a>02134 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02135"></a>02135 <span class="comment"> */</span>
<a name="l02136"></a>02136 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g117b7d1d0a1b08b7395a2ad67a1a5ccc" title="Put an integer to the buffer.">mprPutIntToBuf</a>(MprBuf *buf, <span class="keywordtype">int</span> i);
<a name="l02137"></a>02137 <span class="comment"></span>
<a name="l02138"></a>02138 <span class="comment">/**</span>
<a name="l02139"></a>02139 <span class="comment"> *  Put a string to the buffer.</span>
<a name="l02140"></a>02140 <span class="comment"> *  @description Append a null terminated string to the buffer at the end position and increment the end pointer.</span>
<a name="l02141"></a>02141 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02142"></a>02142 <span class="comment"> *  @param str String to append</span>
<a name="l02143"></a>02143 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02144"></a>02144 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02145"></a>02145 <span class="comment"> */</span>
<a name="l02146"></a>02146 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g482c21dd3356edd53d804b14c5c9f253" title="Put a string to the buffer.">mprPutStringToBuf</a>(MprBuf *buf, cchar *str);
<a name="l02147"></a>02147 <span class="comment"></span>
<a name="l02148"></a>02148 <span class="comment">/**</span>
<a name="l02149"></a>02149 <span class="comment"> *  Put a substring to the buffer.</span>
<a name="l02150"></a>02150 <span class="comment"> *  @description Append a null terminated substring to the buffer at the end position and increment the end pointer.</span>
<a name="l02151"></a>02151 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02152"></a>02152 <span class="comment"> *  @param str String to append</span>
<a name="l02153"></a>02153 <span class="comment"> *  @param count Put at most count characters to the buffer</span>
<a name="l02154"></a>02154 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02155"></a>02155 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02156"></a>02156 <span class="comment"> */</span>
<a name="l02157"></a>02157 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g41b37490b7840471fb6a03288f00df06" title="Put a substring to the buffer.">mprPutSubStringToBuf</a>(MprBuf *buf, cchar *str, <span class="keywordtype">int</span> count);
<a name="l02158"></a>02158 <span class="comment"></span>
<a name="l02159"></a>02159 <span class="comment">/**</span>
<a name="l02160"></a>02160 <span class="comment"> *  Put a formatted string to the buffer.</span>
<a name="l02161"></a>02161 <span class="comment"> *  @description Format a string and Append to the buffer at the end position and increment the end pointer.</span>
<a name="l02162"></a>02162 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02163"></a>02163 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l02164"></a>02164 <span class="comment"> *  @param ... Variable arguments for the format string</span>
<a name="l02165"></a>02165 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02166"></a>02166 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02167"></a>02167 <span class="comment"> */</span>
<a name="l02168"></a>02168 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g87bc8fae31c0dc3ffae2c7d4fb4aa49b" title="Put a formatted string to the buffer.">mprPutFmtToBuf</a>(MprBuf *buf, cchar *fmt, ...);
<a name="l02169"></a>02169 <span class="comment"></span>
<a name="l02170"></a>02170 <span class="comment">/**</span>
<a name="l02171"></a>02171 <span class="comment"> *  Refill the buffer with data</span>
<a name="l02172"></a>02172 <span class="comment"> *  @description Refill the buffer by calling the refill procedure specified via #mprSetBufRefillProc</span>
<a name="l02173"></a>02173 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02174"></a>02174 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02175"></a>02175 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02176"></a>02176 <span class="comment"> */</span>
<a name="l02177"></a>02177 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#g9e7451ec61507706a06c6c8149bebc52" title="Refill the buffer with data.">mprRefillBuf</a>(MprBuf *buf);
<a name="l02178"></a>02178 <span class="comment"></span>
<a name="l02179"></a>02179 <span class="comment">/**</span>
<a name="l02180"></a>02180 <span class="comment"> *  Reset the buffer</span>
<a name="l02181"></a>02181 <span class="comment"> *  @description If the buffer is empty, reset the buffer start and end pointers to the beginning of the buffer.</span>
<a name="l02182"></a>02182 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02183"></a>02183 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02184"></a>02184 <span class="comment"> */</span>
<a name="l02185"></a>02185 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#ge6f9d70c3aab3eb2d9235a1c2a8f63a8" title="Reset the buffer.">mprResetBufIfEmpty</a>(MprBuf *buf);
<a name="l02186"></a>02186 <span class="comment"></span>
<a name="l02187"></a>02187 <span class="comment">/**</span>
<a name="l02188"></a>02188 <span class="comment"> *  Set the buffer size</span>
<a name="l02189"></a>02189 <span class="comment"> *  @description Set the current buffer content size and maximum size limit. Setting a current size will</span>
<a name="l02190"></a>02190 <span class="comment"> *      immediately grow the buffer to be this size. If the size is less than the current buffer size, </span>
<a name="l02191"></a>02191 <span class="comment"> *      the requested size will be ignored. ie. this call will not shrink the buffer. Setting a maxSize </span>
<a name="l02192"></a>02192 <span class="comment"> *      will define a maximum limit for how big the buffer contents can grow. Set either argument to </span>
<a name="l02193"></a>02193 <span class="comment"> *      -1 to be ignored.</span>
<a name="l02194"></a>02194 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02195"></a>02195 <span class="comment"> *  @param size Size to immediately make the buffer. If size is less than the current buffer size, it will be ignored.</span>
<a name="l02196"></a>02196 <span class="comment"> *      Set to -1 to ignore this parameter.</span>
<a name="l02197"></a>02197 <span class="comment"> *  @param maxSize Maximum size the buffer contents can grow to.</span>
<a name="l02198"></a>02198 <span class="comment"> *  @returns Zero if successful and otherwise a negative error code </span>
<a name="l02199"></a>02199 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02200"></a>02200 <span class="comment"> */</span>
<a name="l02201"></a>02201 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_buf.html#gb66fa4b1cc3c02e8808811b027d54898" title="Set the buffer size.">mprSetBufSize</a>(MprBuf *buf, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> maxSize);
<a name="l02202"></a>02202 <span class="comment"></span>
<a name="l02203"></a>02203 <span class="comment">/**</span>
<a name="l02204"></a>02204 <span class="comment"> *  Get the buffer refill procedure</span>
<a name="l02205"></a>02205 <span class="comment"> *  @description Return the buffer refill callback function.</span>
<a name="l02206"></a>02206 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02207"></a>02207 <span class="comment"> *  @returns The refill call back function if defined.</span>
<a name="l02208"></a>02208 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02209"></a>02209 <span class="comment"> */</span>
<a name="l02210"></a>02210 <span class="keyword">extern</span> <a class="code" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7" title="Buffer refill callback function.">MprBufProc</a> <a class="code" href="group___mpr_buf.html#g2791daeb72ae2e3f455250dfba72aa67" title="Get the buffer refill procedure.">mprGetBufRefillProc</a>(MprBuf *buf);
<a name="l02211"></a>02211 <span class="comment"></span>
<a name="l02212"></a>02212 <span class="comment">/**</span>
<a name="l02213"></a>02213 <span class="comment"> *  Set the buffer refill procedure</span>
<a name="l02214"></a>02214 <span class="comment"> *  @description Define a buffer refill procedure. The MprBuf module will not invoke or manage this refill procedure.</span>
<a name="l02215"></a>02215 <span class="comment"> *      It is simply stored to allow upper layers to use and provide their own auto-refill mechanism.</span>
<a name="l02216"></a>02216 <span class="comment"> *  @param buf Buffer created via mprCreateBuf</span>
<a name="l02217"></a>02217 <span class="comment"> *  @param fn Callback function to store.</span>
<a name="l02218"></a>02218 <span class="comment"> *  @param arg Callback data argument.</span>
<a name="l02219"></a>02219 <span class="comment"> *  @ingroup MprBuf</span>
<a name="l02220"></a>02220 <span class="comment"> */</span>
<a name="l02221"></a>02221 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_buf.html#g7f74f8c3d5af9db8c064b365f39cae2c" title="Set the buffer refill procedure.">mprSetBufRefillProc</a>(MprBuf *buf, <a class="code" href="group___mpr_buf.html#ga0f2f003728ef5bb244fdabe2edc56f7" title="Buffer refill callback function.">MprBufProc</a> fn, <span class="keywordtype">void</span> *arg);
<a name="l02222"></a>02222 
<a name="l02223"></a>02223 <span class="comment">/*</span>
<a name="l02224"></a>02224 <span class="comment"> *  Format a date according to RFC822: (Fri, 07 Jan 2003 12:12:21 PDT)</span>
<a name="l02225"></a>02225 <span class="comment"> */</span>
<a name="l02226"></a>02226 <span class="preprocessor">#define MPR_RFC_DATE        "%a, %d %b %Y %T %Z"</span>
<a name="l02227"></a>02227 <span class="preprocessor"></span><span class="preprocessor">#define MPR_DEFAULT_DATE    "%a %b %d %T %Y %Z"</span>
<a name="l02228"></a>02228 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02229"></a>02229 <span class="comment">/**</span>
<a name="l02230"></a>02230 <span class="comment"> *  Date and Time Service</span>
<a name="l02231"></a>02231 <span class="comment"> *  @stability Evolving</span>
<a name="l02232"></a>02232 <span class="comment"> *  @see MprTime, mprDecodeLocalTime, mprDecodeUniversalTime, mprFormatLocalTime, mprFormatTime, mprParseTime</span>
<a name="l02233"></a>02233 <span class="comment"> *  @defgroup MprDate MprDate</span>
<a name="l02234"></a>02234 <span class="comment"> */</span>
<a name="l02235"></a>02235 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprDate { <span class="keywordtype">int</span> dummy; } MprDate;
<a name="l02236"></a>02236 <span class="comment"></span>
<a name="l02237"></a>02237 <span class="comment">/**</span>
<a name="l02238"></a>02238 <span class="comment"> *  Mpr time structure.</span>
<a name="l02239"></a>02239 <span class="comment"> *  @description MprTime is the cross platform time abstraction structure. Time is stored as milliseconds</span>
<a name="l02240"></a>02240 <span class="comment"> *      since the epoch: 00:00:00 UTC Jan 1 1970. MprTime is typically a 64 bit quantity.</span>
<a name="l02241"></a>02241 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02242"></a>02242 <span class="comment"> */</span>
<a name="l02243"></a><a class="code" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b">02243</a> <span class="keyword">typedef</span> int64 <a class="code" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b" title="Mpr time structure.">MprTime</a>;
<a name="l02244"></a>02244 <span class="keyword">struct </span>tm;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprCreateTimeService(MprCtx ctx);
<a name="l02247"></a>02247 <span class="comment"></span>
<a name="l02248"></a>02248 <span class="comment">/**</span>
<a name="l02249"></a>02249 <span class="comment"> *  Compare two times</span>
<a name="l02250"></a>02250 <span class="comment"> *  @description compare two times and return a code indicating which is greater, less or equal</span>
<a name="l02251"></a>02251 <span class="comment"> *  @param t1 First time</span>
<a name="l02252"></a>02252 <span class="comment"> *  @param t2 Second time</span>
<a name="l02253"></a>02253 <span class="comment"> *  @returns Zero if equal, -1 if t1 is less than t2 otherwise one.</span>
<a name="l02254"></a>02254 <span class="comment"> */</span>
<a name="l02255"></a>02255 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#087ffc47d75b5f88dbfcabb8c3cd2d21" title="Compare two times.">mprCompareTime</a>(MprTime t1, MprTime t2);
<a name="l02256"></a>02256 <span class="comment"></span>
<a name="l02257"></a>02257 <span class="comment">/**</span>
<a name="l02258"></a>02258 <span class="comment"> *  Decode a time value into a tokenized local time value.</span>
<a name="l02259"></a>02259 <span class="comment"> *  @description Safe replacement for localtime. This call converts the time value to local time and formats </span>
<a name="l02260"></a>02260 <span class="comment"> *      the as a struct tm.</span>
<a name="l02261"></a>02261 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02262"></a>02262 <span class="comment"> *  @param timep Pointer to a tm structure to hold the result</span>
<a name="l02263"></a>02263 <span class="comment"> *  @param time Time to format</span>
<a name="l02264"></a>02264 <span class="comment"> *  @return Returns a pointer to the tmBuf.</span>
<a name="l02265"></a>02265 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02266"></a>02266 <span class="comment"> */</span>
<a name="l02267"></a>02267 <span class="keyword">extern</span> <span class="keyword">struct </span>tm *<a class="code" href="group___mpr_date.html#g1fe29b0b5a726295afe36d28ab027270" title="Decode a time value into a tokenized local time value.">mprDecodeLocalTime</a>(MprCtx ctx, <span class="keyword">struct</span> tm *timep, MprTime time);
<a name="l02268"></a>02268 <span class="comment"></span>
<a name="l02269"></a>02269 <span class="comment">/**</span>
<a name="l02270"></a>02270 <span class="comment"> *  Decode a time value into a tokenized UTC time structure.</span>
<a name="l02271"></a>02271 <span class="comment"> *  @description Safe replacement for gmtime. This call converts the supplied time value</span>
<a name="l02272"></a>02272 <span class="comment"> *      to UTC time and parses the result into a tm structure.</span>
<a name="l02273"></a>02273 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02274"></a>02274 <span class="comment"> *  @param timep Pointer to a tm structure to hold the result.</span>
<a name="l02275"></a>02275 <span class="comment"> *  @param time The time to format</span>
<a name="l02276"></a>02276 <span class="comment"> *  @return Returns the tm structure reference</span>
<a name="l02277"></a>02277 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02278"></a>02278 <span class="comment"> */</span>
<a name="l02279"></a>02279 <span class="keyword">extern</span> <span class="keyword">struct </span>tm *<a class="code" href="group___mpr_date.html#g4437f3ff3a58a9cf9d4d7d9e763fcc1a" title="Decode a time value into a tokenized UTC time structure.">mprDecodeUniversalTime</a>(MprCtx ctx, <span class="keyword">struct</span> tm *timep, MprTime time);
<a name="l02280"></a>02280 <span class="comment"></span>
<a name="l02281"></a>02281 <span class="comment">/**</span>
<a name="l02282"></a>02282 <span class="comment"> *  Convert a time value to local time and format as a string.</span>
<a name="l02283"></a>02283 <span class="comment"> *  @description Safe replacement for ctime. This call formats the time value supplied via \a timep.</span>
<a name="l02284"></a>02284 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02285"></a>02285 <span class="comment"> *  @param time Time to format. Use mprGetTime to retrieve the current time.</span>
<a name="l02286"></a>02286 <span class="comment"> *  @return The formatting time string</span>
<a name="l02287"></a>02287 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02288"></a>02288 <span class="comment"> */</span>
<a name="l02289"></a>02289 <span class="keyword">extern</span> <span class="keywordtype">char</span> * <a class="code" href="group___mpr_date.html#g70e43deb465cef84d2387800ae07a194" title="Convert a time value to local time and format as a string.">mprFormatLocalTime</a>(MprCtx ctx, MprTime time);
<a name="l02290"></a>02290 <span class="comment"></span>
<a name="l02291"></a>02291 <span class="comment">/**</span>
<a name="l02292"></a>02292 <span class="comment"> *  Format a time value as a local time.</span>
<a name="l02293"></a>02293 <span class="comment"> *  @description This call formats the time value supplied via \a timep.</span>
<a name="l02294"></a>02294 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02295"></a>02295 <span class="comment"> *  @param fmt The time format to use.</span>
<a name="l02296"></a>02296 <span class="comment"> *  @param timep The time value to format.</span>
<a name="l02297"></a>02297 <span class="comment"> *  @return The formatting time string. Caller should free.</span>
<a name="l02298"></a>02298 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02299"></a>02299 <span class="comment"> */</span>
<a name="l02300"></a>02300 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_date.html#g315d7591e179c57cd2072796a8dce0c5" title="Format a time value as a local time.">mprFormatTime</a>(MprCtx ctx, cchar *fmt, <span class="keyword">struct</span> tm *timep);
<a name="l02301"></a>02301 <span class="comment"></span>
<a name="l02302"></a>02302 <span class="comment">/**</span>
<a name="l02303"></a>02303 <span class="comment"> *  Get the system time.</span>
<a name="l02304"></a>02304 <span class="comment"> *  @description Get the system time in milliseconds.</span>
<a name="l02305"></a>02305 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02306"></a>02306 <span class="comment"> *  @return Returns the time in milliseconds since boot.</span>
<a name="l02307"></a>02307 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02308"></a>02308 <span class="comment"> */</span>
<a name="l02309"></a>02309 <span class="keyword">extern</span> MprTime  <a class="code" href="group___mpr_date.html#gedc887ffd106e62ff9f4e69044910c92" title="Get the system time.">mprGetTime</a>(MprCtx ctx);
<a name="l02310"></a>02310 <span class="comment"></span>
<a name="l02311"></a>02311 <span class="comment">/**</span>
<a name="l02312"></a>02312 <span class="comment"> *  Return the time remaining until a timeout has elapsed</span>
<a name="l02313"></a>02313 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02314"></a>02314 <span class="comment"> *  @param mark Starting time stamp </span>
<a name="l02315"></a>02315 <span class="comment"> *  @param timeout Time in milliseconds</span>
<a name="l02316"></a>02316 <span class="comment"> *  @return Time in milliseconds until the timeout elapses  </span>
<a name="l02317"></a>02317 <span class="comment"> *  @ingroup MprDate</span>
<a name="l02318"></a>02318 <span class="comment"> */</span>
<a name="l02319"></a>02319 <span class="keyword">extern</span> MprTime  <a class="code" href="group___mpr_date.html#gc0334d0cee72fb5d5bd9a5dd63b62b03" title="Return the time remaining until a timeout has elapsed.">mprGetRemainingTime</a>(MprCtx ctx, MprTime mark, uint timeout);
<a name="l02320"></a>02320 <span class="comment"></span>
<a name="l02321"></a>02321 <span class="comment">/**</span>
<a name="l02322"></a>02322 <span class="comment"> *  Get the elapsed time since a time mark. Create the time mark with mprGetTime()</span>
<a name="l02323"></a>02323 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02324"></a>02324 <span class="comment"> *  @param mark Starting time stamp </span>
<a name="l02325"></a>02325 <span class="comment"> *  @returns the time elapsed since the mark was taken.</span>
<a name="l02326"></a>02326 <span class="comment"> */</span>
<a name="l02327"></a>02327 <span class="keyword">extern</span> MprTime  <a class="code" href="mpr_8h.html#ebad4782acd4f2cd541ce68737f98471" title="Get the elapsed time since a time mark.">mprGetElapsedTime</a>(MprCtx ctx, MprTime mark);
<a name="l02328"></a>02328 
<a name="l02329"></a>02329 <span class="comment">/*</span>
<a name="l02330"></a>02330 <span class="comment"> *  Convert a time structure into a time value using local time.</span>
<a name="l02331"></a>02331 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02332"></a>02332 <span class="comment"> *  @param timep Pointer to a time structure</span>
<a name="l02333"></a>02333 <span class="comment"> *  @return a time value</span>
<a name="l02334"></a>02334 <span class="comment"> */</span>
<a name="l02335"></a>02335 <span class="keyword">extern</span> MprTime  mprMakeTime(MprCtx ctx, <span class="keyword">struct</span> tm *timep);
<a name="l02336"></a>02336 
<a name="l02337"></a>02337 <span class="comment">/*</span>
<a name="l02338"></a>02338 <span class="comment"> *  Convert a time structure into a time value using UTC time.</span>
<a name="l02339"></a>02339 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02340"></a>02340 <span class="comment"> *  @param timep Pointer to a time structure</span>
<a name="l02341"></a>02341 <span class="comment"> *  @return a time value</span>
<a name="l02342"></a>02342 <span class="comment"> */</span>
<a name="l02343"></a>02343 MprTime mprMakeUniversalTime(MprCtx ctx, <span class="keyword">struct</span> tm *tm);
<a name="l02344"></a>02344 
<a name="l02345"></a>02345 <span class="comment">/*</span>
<a name="l02346"></a>02346 <span class="comment">    Constants for mprParseTime</span>
<a name="l02347"></a>02347 <span class="comment"> */</span>
<a name="l02348"></a>02348 <span class="preprocessor">#define MPR_LOCAL_TIMEZONE     MAXINT   </span><span class="comment">/* Use local timezone */</span>
<a name="l02349"></a>02349 <span class="preprocessor">#define MPR_UTC_TIMEZONE        0       </span><span class="comment">/* Use UTC timezone */</span>
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="comment">/*</span>
<a name="l02352"></a>02352 <span class="comment"> *  Parse a string into a time value</span>
<a name="l02353"></a>02353 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l02354"></a>02354 <span class="comment"> *  @param time Pointer to a time value to receive the parsed time value</span>
<a name="l02355"></a>02355 <span class="comment"> *  @param dateString String to parse</span>
<a name="l02356"></a>02356 <span class="comment"> *  @param timezone Timezone in which to interpret the date</span>
<a name="l02357"></a>02357 <span class="comment"> *  @param defaults Date default values to use for missing components</span>
<a name="l02358"></a>02358 <span class="comment"> *  @returns Zero if successful</span>
<a name="l02359"></a>02359 <span class="comment"> */</span>
<a name="l02360"></a>02360 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprParseTime(MprCtx ctx, MprTime *time, cchar *dateString, <span class="keywordtype">int</span> timezone, <span class="keyword">struct</span> tm *defaults);
<a name="l02361"></a>02361 <span class="comment"></span>
<a name="l02362"></a>02362 <span class="comment">/**</span>
<a name="l02363"></a>02363 <span class="comment"> *  List Module.</span>
<a name="l02364"></a>02364 <span class="comment"> *  @description The MprList is a dynamic growable list suitable for storing pointers to arbitrary objects.</span>
<a name="l02365"></a>02365 <span class="comment"> *  @stability Evolving.</span>
<a name="l02366"></a>02366 <span class="comment"> *  @see MprList, mprAddItem, mprGetItem, mprCreateList, mprClearList, mprLookupItem, mprFree, </span>
<a name="l02367"></a>02367 <span class="comment"> *      mprGetFirstItem, mprGetListCapacity, mprGetListCount, mprGetNextItem, mprGetPrevItem, </span>
<a name="l02368"></a>02368 <span class="comment"> *      mprRemoveItem, mprRemoveItemByIndex, mprRemoveRangeOfItems, mprAppendList, mprSortList, </span>
<a name="l02369"></a>02369 <span class="comment"> *      mprDupList, MprListCompareProc, mprFree, mprCreateKeyPair</span>
<a name="l02370"></a>02370 <span class="comment"> *  @defgroup MprList MprList</span>
<a name="l02371"></a>02371 <span class="comment"> */</span>
<a name="l02372"></a>02372 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprList {
<a name="l02373"></a>02373     <span class="keywordtype">void</span>    **items;                    <span class="comment">/**&lt; List item data */</span>
<a name="l02374"></a>02374     <span class="keywordtype">int</span>     length;                     <span class="comment">/**&lt; Current length of the list contents */</span>
<a name="l02375"></a>02375     <span class="keywordtype">int</span>     capacity;                   <span class="comment">/**&lt; Current list size */</span> 
<a name="l02376"></a>02376     <span class="keywordtype">int</span>     maxSize;                    <span class="comment">/**&lt; Maximum capacity */</span>
<a name="l02377"></a>02377 } MprList;
<a name="l02378"></a>02378 <span class="comment"></span>
<a name="l02379"></a>02379 <span class="comment">/**</span>
<a name="l02380"></a>02380 <span class="comment"> *  List comparison procedure for sorting</span>
<a name="l02381"></a>02381 <span class="comment"> *  @description Callback function signature used by #mprSortList</span>
<a name="l02382"></a>02382 <span class="comment"> *  @param arg1 First list item to compare</span>
<a name="l02383"></a>02383 <span class="comment"> *  @param arg2 Second list item to compare</span>
<a name="l02384"></a>02384 <span class="comment"> *  @returns Return zero if the items are equal. Return -1 if the first arg is less than the second. Otherwise return 1.</span>
<a name="l02385"></a>02385 <span class="comment"> *  @ingroup MprList</span>
<a name="l02386"></a>02386 <span class="comment"> */</span>
<a name="l02387"></a><a class="code" href="group___mpr_list.html#ga4064169552596b7923bc734da239f96">02387</a> <span class="keyword">typedef</span> int (*<a class="code" href="group___mpr_list.html#ga4064169552596b7923bc734da239f96" title="List comparison procedure for sorting.">MprListCompareProc</a>)(cvoid *arg1, cvoid *arg2);
<a name="l02388"></a>02388 <span class="comment"></span>
<a name="l02389"></a>02389 <span class="comment">/**</span>
<a name="l02390"></a>02390 <span class="comment"> *  Add an item to a list</span>
<a name="l02391"></a>02391 <span class="comment"> *  @description Add the specified item to the list. The list must have been previously created via </span>
<a name="l02392"></a>02392 <span class="comment"> *      mprCreateList. The list will grow as required to store the item</span>
<a name="l02393"></a>02393 <span class="comment"> *  @param list List pointer returned from #mprCreateList</span>
<a name="l02394"></a>02394 <span class="comment"> *  @param item Pointer to item to store</span>
<a name="l02395"></a>02395 <span class="comment"> *  @return Returns a positive integer list index for the inserted item. If the item cannot be inserted due </span>
<a name="l02396"></a>02396 <span class="comment"> *      to a memory allocation failure, -1 is returned</span>
<a name="l02397"></a>02397 <span class="comment"> *  @ingroup MprList</span>
<a name="l02398"></a>02398 <span class="comment"> */</span>
<a name="l02399"></a>02399 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#gbf10109abc063c47702769c0e89442cf" title="Add an item to a list.">mprAddItem</a>(MprList *list, cvoid *item);
<a name="l02400"></a>02400 <span class="comment"></span>
<a name="l02401"></a>02401 <span class="comment">/**</span>
<a name="l02402"></a>02402 <span class="comment"> *  Append a list</span>
<a name="l02403"></a>02403 <span class="comment"> *  @description Append the contents of one list to another. The list will grow as required to store the item</span>
<a name="l02404"></a>02404 <span class="comment"> *  @param list List pointer returned from #mprCreateList</span>
<a name="l02405"></a>02405 <span class="comment"> *  @param add List whose contents are added</span>
<a name="l02406"></a>02406 <span class="comment"> *  @return Returns a pointer to the original list if successful. Returns NULL on memory allocation errors.</span>
<a name="l02407"></a>02407 <span class="comment"> *  @ingroup MprList</span>
<a name="l02408"></a>02408 <span class="comment"> */</span>
<a name="l02409"></a>02409 <span class="keyword">extern</span> MprList *<a class="code" href="group___mpr_list.html#g5f81ae14eecf28b6e6bdd64677860e39" title="Append a list.">mprAppendList</a>(MprList *list, MprList *<span class="keyword">add</span>);
<a name="l02410"></a>02410 <span class="comment"></span>
<a name="l02411"></a>02411 <span class="comment">/**</span>
<a name="l02412"></a>02412 <span class="comment"> *  Create a list.</span>
<a name="l02413"></a>02413 <span class="comment"> *  @description Creates an empty list. MprList's can store generic pointers. They automatically grow as </span>
<a name="l02414"></a>02414 <span class="comment"> *      required when items are added to the list. Callers should invoke mprFree when finished with the</span>
<a name="l02415"></a>02415 <span class="comment"> *      list to release allocated storage.</span>
<a name="l02416"></a>02416 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02417"></a>02417 <span class="comment"> *  @return Returns a pointer to the list. </span>
<a name="l02418"></a>02418 <span class="comment"> *  @ingroup MprList</span>
<a name="l02419"></a>02419 <span class="comment"> */</span>
<a name="l02420"></a>02420 <span class="keyword">extern</span> MprList *<a class="code" href="group___mpr_list.html#gd5e29adbb51053e84bcb52b9f6756e37" title="Create a list.">mprCreateList</a>(MprCtx ctx);
<a name="l02421"></a>02421 <span class="comment"></span>
<a name="l02422"></a>02422 <span class="comment">/**</span>
<a name="l02423"></a>02423 <span class="comment"> *  Copy a list</span>
<a name="l02424"></a>02424 <span class="comment"> *  @description Copy the contents of a list into an existing list. The destination list is cleared first and </span>
<a name="l02425"></a>02425 <span class="comment"> *      has its dimensions set to that of the source clist.</span>
<a name="l02426"></a>02426 <span class="comment"> *  @param dest Destination list for the copy</span>
<a name="l02427"></a>02427 <span class="comment"> *  @param src Source list</span>
<a name="l02428"></a>02428 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02429"></a>02429 <span class="comment"> *  @ingroup MprList</span>
<a name="l02430"></a>02430 <span class="comment"> */</span>
<a name="l02431"></a>02431 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g64b04ef8c2be20d2d952ecfa22b7ce54" title="Copy a list.">mprCopyList</a>(MprList *dest, MprList *src);
<a name="l02432"></a>02432 <span class="comment"></span>
<a name="l02433"></a>02433 <span class="comment">/**</span>
<a name="l02434"></a>02434 <span class="comment"> *  Duplicate a list</span>
<a name="l02435"></a>02435 <span class="comment"> *  @description Copy the contents of a list into a new list. </span>
<a name="l02436"></a>02436 <span class="comment"> *  @param ctx Memory context from which to allocate the list. See #mprAlloc</span>
<a name="l02437"></a>02437 <span class="comment"> *  @param src Source list to copy</span>
<a name="l02438"></a>02438 <span class="comment"> *  @return Returns a new list reference</span>
<a name="l02439"></a>02439 <span class="comment"> *  @ingroup MprList</span>
<a name="l02440"></a>02440 <span class="comment"> */</span>
<a name="l02441"></a>02441 <span class="keyword">extern</span> MprList *<a class="code" href="group___mpr_list.html#gc6512c8fa92c1d91cf99f4e3ad6af2f1" title="Duplicate a list.">mprDupList</a>(MprCtx ctx, MprList *src);
<a name="l02442"></a>02442 <span class="comment"></span>
<a name="l02443"></a>02443 <span class="comment">/**</span>
<a name="l02444"></a>02444 <span class="comment"> *  Clears the list of all items.</span>
<a name="l02445"></a>02445 <span class="comment"> *  @description Resets the list length to zero and clears all items. Existing items are not freed, they </span>
<a name="l02446"></a>02446 <span class="comment"> *      are only removed from the list.</span>
<a name="l02447"></a>02447 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02448"></a>02448 <span class="comment"> *  @ingroup MprList</span>
<a name="l02449"></a>02449 <span class="comment"> */</span>
<a name="l02450"></a>02450 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_list.html#gcf49292693e22c7bdc43fbb41a83817d" title="Clears the list of all items.">mprClearList</a>(MprList *list);
<a name="l02451"></a>02451 <span class="comment"></span>
<a name="l02452"></a>02452 <span class="comment">/**</span>
<a name="l02453"></a>02453 <span class="comment"> *  Find an item and return its index.</span>
<a name="l02454"></a>02454 <span class="comment"> *  @description Search for an item in the list and return its index.</span>
<a name="l02455"></a>02455 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02456"></a>02456 <span class="comment"> *  @param item Pointer to value stored in the list.</span>
<a name="l02457"></a>02457 <span class="comment"> *  @ingroup MprList</span>
<a name="l02458"></a>02458 <span class="comment"> */</span>
<a name="l02459"></a>02459 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g8b3d6afe4be8d416e28f64d05e8391eb" title="Find an item and return its index.">mprLookupItem</a>(MprList *list, cvoid *item);
<a name="l02460"></a>02460 <span class="comment"></span>
<a name="l02461"></a>02461 <span class="comment">/**</span>
<a name="l02462"></a>02462 <span class="comment"> *  Get the first item in the list.</span>
<a name="l02463"></a>02463 <span class="comment"> *  @description Returns the value of the first item in the list. After calling this routine, the remaining </span>
<a name="l02464"></a>02464 <span class="comment"> *      list items can be walked using mprGetNextItem.</span>
<a name="l02465"></a>02465 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02466"></a>02466 <span class="comment"> *  @ingroup MprList</span>
<a name="l02467"></a>02467 <span class="comment"> */</span>
<a name="l02468"></a>02468 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#g34b6f80710796e4d3d766299ebf37078" title="Get the first item in the list.">mprGetFirstItem</a>(MprList *list);
<a name="l02469"></a>02469 <span class="comment"></span>
<a name="l02470"></a>02470 <span class="comment">/**</span>
<a name="l02471"></a>02471 <span class="comment"> *  Get the last item in the list.</span>
<a name="l02472"></a>02472 <span class="comment"> *  @description Returns the value of the last item in the list. After calling this routine, the remaining </span>
<a name="l02473"></a>02473 <span class="comment"> *      list items can be walked using mprGetPrevItem.</span>
<a name="l02474"></a>02474 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02475"></a>02475 <span class="comment"> *  @ingroup MprList</span>
<a name="l02476"></a>02476 <span class="comment"> */</span>
<a name="l02477"></a>02477 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#g629c61d9bfbea110851227fd61569093" title="Get the last item in the list.">mprGetLastItem</a>(MprList *list);
<a name="l02478"></a>02478 <span class="comment"></span>
<a name="l02479"></a>02479 <span class="comment">/**</span>
<a name="l02480"></a>02480 <span class="comment"> *  Get an list item.</span>
<a name="l02481"></a>02481 <span class="comment"> *  @description Get an list item specified by its index.</span>
<a name="l02482"></a>02482 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02483"></a>02483 <span class="comment"> *  @param index Item index into the list. Indexes have a range from zero to the lenghth of the list - 1.</span>
<a name="l02484"></a>02484 <span class="comment"> *  @ingroup MprList</span>
<a name="l02485"></a>02485 <span class="comment"> */</span>
<a name="l02486"></a>02486 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#g4535837cc644f208063b1ca3e2ae46c2" title="Get an list item.">mprGetItem</a>(MprList *list, <span class="keywordtype">int</span> index);
<a name="l02487"></a>02487 <span class="comment"></span>
<a name="l02488"></a>02488 <span class="comment">/**</span>
<a name="l02489"></a>02489 <span class="comment"> *  Get the current capacity of the list.</span>
<a name="l02490"></a>02490 <span class="comment"> *  @description Returns the capacity of the list. This will always be equal to or greater than the list length.</span>
<a name="l02491"></a>02491 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02492"></a>02492 <span class="comment"> *  @ingroup MprList</span>
<a name="l02493"></a>02493 <span class="comment"> */</span>
<a name="l02494"></a>02494 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#gc47331b3442493d84405d32ffcb98aba" title="Get the current capacity of the list.">mprGetListCapacity</a>(MprList *list);
<a name="l02495"></a>02495 <span class="comment"></span>
<a name="l02496"></a>02496 <span class="comment">/**</span>
<a name="l02497"></a>02497 <span class="comment"> *  Get the number of items in the list.</span>
<a name="l02498"></a>02498 <span class="comment"> *  @description Returns the number of items in the list. This will always be less than or equal to the list capacity.</span>
<a name="l02499"></a>02499 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02500"></a>02500 <span class="comment"> *  @ingroup MprList</span>
<a name="l02501"></a>02501 <span class="comment"> */</span>
<a name="l02502"></a>02502 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g8710190bcf91677b3758890b7deefd75" title="Get the number of items in the list.">mprGetListCount</a>(MprList *list);
<a name="l02503"></a>02503 <span class="comment"></span>
<a name="l02504"></a>02504 <span class="comment">/**</span>
<a name="l02505"></a>02505 <span class="comment"> *  Get the next item in the list.</span>
<a name="l02506"></a>02506 <span class="comment"> *  @description Returns the value of the next item in the list. Before calling</span>
<a name="l02507"></a>02507 <span class="comment"> *      this routine, mprGetFirstItem must be called to initialize the traversal of the list.</span>
<a name="l02508"></a>02508 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02509"></a>02509 <span class="comment"> *  @param lastIndex Pointer to an integer that will hold the last index retrieved.</span>
<a name="l02510"></a>02510 <span class="comment"> *  @ingroup MprList</span>
<a name="l02511"></a>02511 <span class="comment"> */</span>
<a name="l02512"></a>02512 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#gf84ab68545207f073e9f916adc8817e4" title="Get the next item in the list.">mprGetNextItem</a>(MprList *list, <span class="keywordtype">int</span> *lastIndex);
<a name="l02513"></a>02513 <span class="comment"></span>
<a name="l02514"></a>02514 <span class="comment">/**</span>
<a name="l02515"></a>02515 <span class="comment"> *  Get the previous item in the list.</span>
<a name="l02516"></a>02516 <span class="comment"> *  @description Returns the value of the previous item in the list. Before </span>
<a name="l02517"></a>02517 <span class="comment"> *      calling this routine, mprGetFirstItem and/or mprGetNextItem must be</span>
<a name="l02518"></a>02518 <span class="comment"> *      called to initialize the traversal of the list.</span>
<a name="l02519"></a>02519 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02520"></a>02520 <span class="comment"> *  @param lastIndex Pointer to an integer that will hold the last index retrieved.</span>
<a name="l02521"></a>02521 <span class="comment"> *  @ingroup MprList</span>
<a name="l02522"></a>02522 <span class="comment"> */</span>
<a name="l02523"></a>02523 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#g701e2771ac787973c94e523898d596a6" title="Get the previous item in the list.">mprGetPrevItem</a>(MprList *list, <span class="keywordtype">int</span> *lastIndex);
<a name="l02524"></a>02524 <span class="comment"></span>
<a name="l02525"></a>02525 <span class="comment">/**</span>
<a name="l02526"></a>02526 <span class="comment"> *  Initialize a list structure</span>
<a name="l02527"></a>02527 <span class="comment"> *  @description If a list is statically declared inside another structure, mprInitList can be used to </span>
<a name="l02528"></a>02528 <span class="comment"> *      initialize it before use.</span>
<a name="l02529"></a>02529 <span class="comment"> *  @param list Reference to the MprList struct.</span>
<a name="l02530"></a>02530 <span class="comment"> *  @ingroup MprList</span>
<a name="l02531"></a>02531 <span class="comment"> */</span>
<a name="l02532"></a>02532 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_list.html#gc1b1433c9a3b963c78572f53cf2a6fd8" title="Initialize a list structure.">mprInitList</a>(MprList *list);
<a name="l02533"></a>02533 <span class="comment"></span>
<a name="l02534"></a>02534 <span class="comment">/**</span>
<a name="l02535"></a>02535 <span class="comment"> *  Insert an item into a list at a specific position</span>
<a name="l02536"></a>02536 <span class="comment"> *  @description Insert the item into the list before the specified position. The list will grow as required </span>
<a name="l02537"></a>02537 <span class="comment"> *      to store the item</span>
<a name="l02538"></a>02538 <span class="comment"> *  @param list List pointer returned from #mprCreateList</span>
<a name="l02539"></a>02539 <span class="comment"> *  @param index Location at which to store the item. The previous item at this index is moved up to make room.</span>
<a name="l02540"></a>02540 <span class="comment"> *  @param item Pointer to item to store</span>
<a name="l02541"></a>02541 <span class="comment"> *  @return Returns the position index (positive integer) if successful. If the item cannot be inserted due </span>
<a name="l02542"></a>02542 <span class="comment"> *      to a memory allocation failure, -1 is returned</span>
<a name="l02543"></a>02543 <span class="comment"> *  @ingroup MprList</span>
<a name="l02544"></a>02544 <span class="comment"> */</span>
<a name="l02545"></a>02545 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#gf3e8599ae4707459cf42ad960256af98" title="Insert an item into a list at a specific position.">mprInsertItemAtPos</a>(MprList *list, <span class="keywordtype">int</span> index, cvoid *item);
<a name="l02546"></a>02546 <span class="comment"></span>
<a name="l02547"></a>02547 <span class="comment">/**</span>
<a name="l02548"></a>02548 <span class="comment"> *  Remove an item from the list</span>
<a name="l02549"></a>02549 <span class="comment"> *  @description Search for a specified item and then remove it from the list.</span>
<a name="l02550"></a>02550 <span class="comment"> *      Existing items are not freed, they are only removed from the list.</span>
<a name="l02551"></a>02551 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02552"></a>02552 <span class="comment"> *  @param item Item pointer to remove. </span>
<a name="l02553"></a>02553 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02554"></a>02554 <span class="comment"> *  @ingroup MprList</span>
<a name="l02555"></a>02555 <span class="comment"> */</span>
<a name="l02556"></a>02556 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g2206c8d8a7049ad6f26ff74c215f32a7" title="Remove an item from the list.">mprRemoveItem</a>(MprList *list, <span class="keywordtype">void</span> *item);
<a name="l02557"></a>02557 <span class="comment"></span>
<a name="l02558"></a>02558 <span class="comment">/**</span>
<a name="l02559"></a>02559 <span class="comment"> *  Remove an item from the list</span>
<a name="l02560"></a>02560 <span class="comment"> *  @description Removes the element specified by \a index, from the list. The</span>
<a name="l02561"></a>02561 <span class="comment"> *      list index is provided by mprInsertItem.</span>
<a name="l02562"></a>02562 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02563"></a>02563 <span class="comment"> *  @ingroup MprList</span>
<a name="l02564"></a>02564 <span class="comment"> */</span>
<a name="l02565"></a>02565 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#gc758d5af71b0bbf943bb6a1e263a494c" title="Remove an item from the list.">mprRemoveItemAtPos</a>(MprList *list, <span class="keywordtype">int</span> index);
<a name="l02566"></a>02566 <span class="comment"></span>
<a name="l02567"></a>02567 <span class="comment">/**</span>
<a name="l02568"></a>02568 <span class="comment"> *  Remove the last item from the list</span>
<a name="l02569"></a>02569 <span class="comment"> *  @description Remove the item at the highest index position.</span>
<a name="l02570"></a>02570 <span class="comment"> *      Existing items are not freed, they are only removed from the list.</span>
<a name="l02571"></a>02571 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02572"></a>02572 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02573"></a>02573 <span class="comment"> *  @ingroup MprList</span>
<a name="l02574"></a>02574 <span class="comment"> */</span>
<a name="l02575"></a>02575 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g85633d8034896cf4f056caa1857bf4a8" title="Remove the last item from the list.">mprRemoveLastItem</a>(MprList *list);
<a name="l02576"></a>02576 <span class="comment"></span>
<a name="l02577"></a>02577 <span class="comment">/**</span>
<a name="l02578"></a>02578 <span class="comment"> *  Remove a range of items from the list.</span>
<a name="l02579"></a>02579 <span class="comment"> *  @description Remove a range of items from the list. The range is specified</span>
<a name="l02580"></a>02580 <span class="comment"> *      from the \a start index up to and including the \a end index.</span>
<a name="l02581"></a>02581 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02582"></a>02582 <span class="comment"> *  @param start Starting item index to remove (inclusive)</span>
<a name="l02583"></a>02583 <span class="comment"> *  @param end Ending item index to remove (inclusive)</span>
<a name="l02584"></a>02584 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02585"></a>02585 <span class="comment"> *  @ingroup MprList</span>
<a name="l02586"></a>02586 <span class="comment"> */</span>
<a name="l02587"></a>02587 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g16748fa2520761d373cebe4b39be3e8e" title="Remove a range of items from the list.">mprRemoveRangeOfItems</a>(MprList *list, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end);
<a name="l02588"></a>02588 <span class="comment"></span>
<a name="l02589"></a>02589 <span class="comment">/**</span>
<a name="l02590"></a>02590 <span class="comment"> *  Set a list item</span>
<a name="l02591"></a>02591 <span class="comment"> *  @description Update the list item stored at the specified index</span>
<a name="l02592"></a>02592 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02593"></a>02593 <span class="comment"> *  @param index Location to update</span>
<a name="l02594"></a>02594 <span class="comment"> *  @param item Pointer to item to store</span>
<a name="l02595"></a>02595 <span class="comment"> *  @return Returns the old item previously at that location index</span>
<a name="l02596"></a>02596 <span class="comment"> *  @ingroup MprList</span>
<a name="l02597"></a>02597 <span class="comment"> */</span>
<a name="l02598"></a>02598 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_list.html#g20dffb6f04ddb568db844dd1a83025f7" title="Set a list item.">mprSetItem</a>(MprList *list, <span class="keywordtype">int</span> index, cvoid *item);
<a name="l02599"></a>02599 <span class="comment"></span>
<a name="l02600"></a>02600 <span class="comment">/**</span>
<a name="l02601"></a>02601 <span class="comment"> *  Define the list size limits</span>
<a name="l02602"></a>02602 <span class="comment"> *  @description Define the list initial size and maximum size it can grow to.</span>
<a name="l02603"></a>02603 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02604"></a>02604 <span class="comment"> *  @param initialSize Initial size for the list. This call will allocate space for at least this number of items.</span>
<a name="l02605"></a>02605 <span class="comment"> *  @param maxSize Set the maximum limit the list can grow to become.</span>
<a name="l02606"></a>02606 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l02607"></a>02607 <span class="comment"> *  @ingroup MprList</span>
<a name="l02608"></a>02608 <span class="comment"> */</span>
<a name="l02609"></a>02609 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_list.html#g38bd862a8bc3076d86b0185d5bd81aa6" title="Define the list size limits.">mprSetListLimits</a>(MprList *list, <span class="keywordtype">int</span> initialSize, <span class="keywordtype">int</span> maxSize);
<a name="l02610"></a>02610 <span class="comment"></span>
<a name="l02611"></a>02611 <span class="comment">/**</span>
<a name="l02612"></a>02612 <span class="comment"> *  Sort a list</span>
<a name="l02613"></a>02613 <span class="comment"> *  @description Sort a list using the sort ordering dictated by the supplied compare function.</span>
<a name="l02614"></a>02614 <span class="comment"> *  @param list List pointer returned from mprCreateList.</span>
<a name="l02615"></a>02615 <span class="comment"> *  @param compare Comparison function. If null, then a default string comparison is used.</span>
<a name="l02616"></a>02616 <span class="comment"> *  @ingroup MprList</span>
<a name="l02617"></a>02617 <span class="comment"> */</span>
<a name="l02618"></a>02618 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_list.html#g50c9e84e551dffe01dfe6a2697464f5d" title="Sort a list.">mprSortList</a>(MprList *list, <a class="code" href="group___mpr_list.html#ga4064169552596b7923bc734da239f96" title="List comparison procedure for sorting.">MprListCompareProc</a> compare);
<a name="l02619"></a>02619 <span class="comment"></span>
<a name="l02620"></a>02620 <span class="comment">/**</span>
<a name="l02621"></a>02621 <span class="comment"> *  Key value pairs for use with MprList or MprHash</span>
<a name="l02622"></a>02622 <span class="comment"> *  @ingroup MprList</span>
<a name="l02623"></a>02623 <span class="comment"> */</span>
<a name="l02624"></a><a class="code" href="struct_mpr_key_value.html">02624</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_key_value.html" title="Key value pairs for use with MprList or MprHash.">MprKeyValue</a> {
<a name="l02625"></a><a class="code" href="struct_mpr_key_value.html#11b8e4d0b99d275bb413b931f63e6f13">02625</a>     <span class="keywordtype">char</span>        *<a class="code" href="struct_mpr_key_value.html#11b8e4d0b99d275bb413b931f63e6f13" title="Key string.">key</a>;               <span class="comment">/**&lt; Key string */</span>
<a name="l02626"></a><a class="code" href="struct_mpr_key_value.html#9f1f2fb7752821282465570d42cbb965">02626</a>     <span class="keywordtype">char</span>        *<a class="code" href="struct_mpr_key_value.html#9f1f2fb7752821282465570d42cbb965" title="Associated value for the key.">value</a>;             <span class="comment">/**&lt; Associated value for the key */</span>
<a name="l02627"></a>02627 } <a class="code" href="struct_mpr_key_value.html" title="Key value pairs for use with MprList or MprHash.">MprKeyValue</a>;
<a name="l02628"></a>02628 <span class="comment"></span>
<a name="l02629"></a>02629 <span class="comment">/**</span>
<a name="l02630"></a>02630 <span class="comment"> *  Create a key / value pair</span>
<a name="l02631"></a>02631 <span class="comment"> *  @description Allocate and initialize a key value pair for use by the MprList or MprHash modules.</span>
<a name="l02632"></a>02632 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02633"></a>02633 <span class="comment"> *  @param key Key string</span>
<a name="l02634"></a>02634 <span class="comment"> *  @param value Key value string</span>
<a name="l02635"></a>02635 <span class="comment"> *  @returns An initialized MprKeyValue</span>
<a name="l02636"></a>02636 <span class="comment"> *  @ingroup MprList</span>
<a name="l02637"></a>02637 <span class="comment"> */</span>
<a name="l02638"></a>02638 <span class="keyword">extern</span> <a class="code" href="struct_mpr_key_value.html" title="Key value pairs for use with MprList or MprHash.">MprKeyValue</a> *<a class="code" href="group___mpr_list.html#g6dc1e2980f934578a5a88f9f987adcf5" title="Create a key / value pair.">mprCreateKeyPair</a>(MprCtx ctx, cchar *key, cchar *value);
<a name="l02639"></a>02639 <span class="comment"></span>
<a name="l02640"></a>02640 <span class="comment">/**</span>
<a name="l02641"></a>02641 <span class="comment"> *  Logging Services</span>
<a name="l02642"></a>02642 <span class="comment"> *  @stability Evolving</span>
<a name="l02643"></a>02643 <span class="comment"> *  @defgroup MprLog MprLog</span>
<a name="l02644"></a>02644 <span class="comment"> *  @see mprError, mprLog, mprSetLogHandler, mprSetLogLevel, mprUserError, mprRawLog, mprFatalError, MprLogHandler</span>
<a name="l02645"></a>02645 <span class="comment"> *      mprGetLogHandler, mprMemoryError, mprStaticAssert, mprStaticError</span>
<a name="l02646"></a>02646 <span class="comment"> */</span>
<a name="l02647"></a>02647 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprLog { <span class="keywordtype">int</span> dummy; } MprLog;
<a name="l02648"></a>02648 <span class="comment"></span>
<a name="l02649"></a>02649 <span class="comment">/**</span>
<a name="l02650"></a>02650 <span class="comment"> *  Log handler callback type.</span>
<a name="l02651"></a>02651 <span class="comment"> *  @description Callback prototype for the log handler. Used by mprSetLogHandler to define </span>
<a name="l02652"></a>02652 <span class="comment"> *      a message logging handler to process log and error messages. </span>
<a name="l02653"></a>02653 <span class="comment"> *  @param file Source filename. Derived by using __FILE__.</span>
<a name="l02654"></a>02654 <span class="comment"> *  @param line Source line number. Derived by using __LINE__.</span>
<a name="l02655"></a>02655 <span class="comment"> *  @param flags Error flags.</span>
<a name="l02656"></a>02656 <span class="comment"> *  @param level Message logging level. Levels are 0-9 with zero being the most verbose.</span>
<a name="l02657"></a>02657 <span class="comment"> *  @param msg Message being logged.</span>
<a name="l02658"></a>02658 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02659"></a>02659 <span class="comment"> */</span>
<a name="l02660"></a><a class="code" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689">02660</a> <span class="keyword">typedef</span> void (*<a class="code" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689" title="Log handler callback type.">MprLogHandler</a>)(MprCtx ctx, <span class="keywordtype">int</span> flags, <span class="keywordtype">int</span> level, cchar *msg);
<a name="l02661"></a>02661 <span class="comment"></span>
<a name="l02662"></a>02662 <span class="comment">/**</span>
<a name="l02663"></a>02663 <span class="comment"> *  Set an MPR debug log handler.</span>
<a name="l02664"></a>02664 <span class="comment"> *  @description Defines a callback handler for MPR debug and error log messages. When output is sent to </span>
<a name="l02665"></a>02665 <span class="comment"> *      the debug channel, the log handler will be invoked to accept the output message.</span>
<a name="l02666"></a>02666 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02667"></a>02667 <span class="comment"> *  @param handler Callback handler</span>
<a name="l02668"></a>02668 <span class="comment"> *  @param handlerData Callback handler data</span>
<a name="l02669"></a>02669 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02670"></a>02670 <span class="comment"> */</span>
<a name="l02671"></a>02671 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#gb2ac022607500626163a8c3bb997c5c8" title="Set an MPR debug log handler.">mprSetLogHandler</a>(MprCtx ctx, <a class="code" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689" title="Log handler callback type.">MprLogHandler</a> handler, <span class="keywordtype">void</span> *handlerData);
<a name="l02672"></a>02672 <span class="comment"></span>
<a name="l02673"></a>02673 <span class="comment">/**</span>
<a name="l02674"></a>02674 <span class="comment"> *  Get the current MPR debug log handler.</span>
<a name="l02675"></a>02675 <span class="comment"> *  @description Get the log handler defined via #mprSetLogHandler</span>
<a name="l02676"></a>02676 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02677"></a>02677 <span class="comment"> *  @returns A function of the signature #MprLogHandler</span>
<a name="l02678"></a>02678 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02679"></a>02679 <span class="comment"> */</span>
<a name="l02680"></a>02680 <span class="keyword">extern</span> <a class="code" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689" title="Log handler callback type.">MprLogHandler</a> <a class="code" href="group___mpr_log.html#gdfefb0345bcaca30d7d86650b06d6bae" title="Get the current MPR debug log handler.">mprGetLogHandler</a>(MprCtx ctx);
<a name="l02681"></a>02681 <span class="comment"></span>
<a name="l02682"></a>02682 <span class="comment">/**</span>
<a name="l02683"></a>02683 <span class="comment"> *  Log an error message.</span>
<a name="l02684"></a>02684 <span class="comment"> *  @description Send an error message to the MPR debug logging subsystem. The </span>
<a name="l02685"></a>02685 <span class="comment"> *      message will be to the log handler defined by #mprSetLogHandler. It </span>
<a name="l02686"></a>02686 <span class="comment"> *      is up to the log handler to respond appropriately and log the message.</span>
<a name="l02687"></a>02687 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02688"></a>02688 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02689"></a>02689 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02690"></a>02690 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02691"></a>02691 <span class="comment"> */</span>
<a name="l02692"></a>02692 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#gba80d025830577c73b7fab45b3ecd256" title="Log an error message.">mprError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l02693"></a>02693 <span class="comment"></span>
<a name="l02694"></a>02694 <span class="comment">/**</span>
<a name="l02695"></a>02695 <span class="comment"> *  Log a fatal error message and exit.</span>
<a name="l02696"></a>02696 <span class="comment"> *  @description Send a fatal error message to the MPR debug logging subsystem and then exit the application by</span>
<a name="l02697"></a>02697 <span class="comment"> *      calling exit(). The message will be to the log handler defined by #mprSetLogHandler. It </span>
<a name="l02698"></a>02698 <span class="comment"> *      is up to the log handler to respond appropriately and log the message.</span>
<a name="l02699"></a>02699 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02700"></a>02700 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02701"></a>02701 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02702"></a>02702 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02703"></a>02703 <span class="comment"> */</span>
<a name="l02704"></a>02704 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g44e05f9b1cb74a3abd9271d140f5d66d" title="Log a fatal error message and exit.">mprFatalError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l02705"></a>02705 <span class="comment"></span>
<a name="l02706"></a>02706 <span class="comment">/**</span>
<a name="l02707"></a>02707 <span class="comment"> *  Log a memory error message.</span>
<a name="l02708"></a>02708 <span class="comment"> *  @description Send a memory error message to the MPR debug logging subsystem. The message will be </span>
<a name="l02709"></a>02709 <span class="comment"> *      passed to the log handler defined by #mprSetLogHandler. It is up to the log handler to respond appropriately</span>
<a name="l02710"></a>02710 <span class="comment"> *      to the fatal message, the MPR takes no other action other than logging the message. Typically, a memory </span>
<a name="l02711"></a>02711 <span class="comment"> *      message will be logged and the application will be shutdown. The preferred method of operation is to define</span>
<a name="l02712"></a>02712 <span class="comment"> *      a memory depletion callback via #mprCreate. This will be invoked whenever a memory allocation error occurs.</span>
<a name="l02713"></a>02713 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02714"></a>02714 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02715"></a>02715 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02716"></a>02716 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02717"></a>02717 <span class="comment"> */</span>
<a name="l02718"></a>02718 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g53e8e5ceb47594177a2db18c5acc5f65" title="Log a memory error message.">mprMemoryError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l02719"></a>02719 <span class="comment"></span>
<a name="l02720"></a>02720 <span class="comment">/**</span>
<a name="l02721"></a>02721 <span class="comment"> *  Write a message to the diagnostic log file.</span>
<a name="l02722"></a>02722 <span class="comment"> *  @description Send a message to the MPR logging subsystem.</span>
<a name="l02723"></a>02723 <span class="comment"> *  @param level Logging level for this message. The level is 0-9 with zero being the most verbose.</span>
<a name="l02724"></a>02724 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02725"></a>02725 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02726"></a>02726 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02727"></a>02727 <span class="comment"> *  @remarks mprLog is highly useful as a debugging aid when integrating or when developing new modules. </span>
<a name="l02728"></a>02728 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02729"></a>02729 <span class="comment"> */</span>
<a name="l02730"></a>02730 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g86f03e0fb54d0f897fec0981d3671c41" title="Write a message to the diagnostic log file.">mprLog</a>(MprCtx ctx, <span class="keywordtype">int</span> level, cchar *fmt, ...);
<a name="l02731"></a>02731 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprDebug(MprCtx ctx, <span class="keywordtype">int</span> level, cchar *fmt, ...);
<a name="l02732"></a>02732 
<a name="l02733"></a>02733 <span class="comment">/*</span>
<a name="l02734"></a>02734 <span class="comment"> *  Optimized calling sequence.</span>
<a name="l02735"></a>02735 <span class="comment"> */</span>
<a name="l02736"></a>02736 <span class="preprocessor">#if BLD_DEBUG</span>
<a name="l02737"></a>02737 <span class="preprocessor"></span><span class="preprocessor">#define LOG if (mprGetMpr()-&gt;logLevel &gt; 1) mprLog</span>
<a name="l02738"></a>02738 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l02739"></a>02739 <span class="preprocessor"></span><span class="preprocessor">#define LOG if (0) mprLog</span>
<a name="l02740"></a>02740 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02741"></a>02741 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02742"></a>02742 <span class="comment">/**</span>
<a name="l02743"></a>02743 <span class="comment"> *  Write a raw log message to the diagnostic log file.</span>
<a name="l02744"></a>02744 <span class="comment"> *  @description Send a raw message to the MPR logging subsystem. Raw messages do not have any application prefix</span>
<a name="l02745"></a>02745 <span class="comment"> *      attached to the message and do not append a newline to the message.</span>
<a name="l02746"></a>02746 <span class="comment"> *  @param level Logging level for this message. The level is 0-9 with zero being the most verbose.</span>
<a name="l02747"></a>02747 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02748"></a>02748 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02749"></a>02749 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02750"></a>02750 <span class="comment"> *  @remarks mprLog is highly useful as a debugging aid when integrating or when developing new modules. </span>
<a name="l02751"></a>02751 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02752"></a>02752 <span class="comment"> */</span>
<a name="l02753"></a>02753 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g54e411388517de37fddd5537b0339e07" title="Write a raw log message to the diagnostic log file.">mprRawLog</a>(MprCtx ctx, <span class="keywordtype">int</span> level, cchar *fmt, ...);
<a name="l02754"></a>02754 <span class="comment"></span>
<a name="l02755"></a>02755 <span class="comment">/**</span>
<a name="l02756"></a>02756 <span class="comment"> *  Output an assertion failed message.</span>
<a name="l02757"></a>02757 <span class="comment"> *  @description This will emit an assertion failed message to the standard error output. It will bypass the logging</span>
<a name="l02758"></a>02758 <span class="comment"> *      system.</span>
<a name="l02759"></a>02759 <span class="comment"> *  @param loc Source code location string. Use MPR_LOC to define a file name and line number string suitable for this</span>
<a name="l02760"></a>02760 <span class="comment"> *      parameter.</span>
<a name="l02761"></a>02761 <span class="comment"> *  @param msg Simple string message to output</span>
<a name="l02762"></a>02762 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02763"></a>02763 <span class="comment"> */</span>
<a name="l02764"></a>02764 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g0c03cfaa89967bee56ef3eebb36b4713" title="Output an assertion failed message.">mprStaticAssert</a>(cchar *loc, cchar *msg);
<a name="l02765"></a>02765 <span class="comment"></span>
<a name="l02766"></a>02766 <span class="comment">/**</span>
<a name="l02767"></a>02767 <span class="comment"> *  Write a message to the diagnostic log file without allocating any memory. Useful for log messages from within the</span>
<a name="l02768"></a>02768 <span class="comment"> *      memory allocator.</span>
<a name="l02769"></a>02769 <span class="comment"> *  @description Send a message to the MPR logging subsystem. This will not allocate any memory while formatting the </span>
<a name="l02770"></a>02770 <span class="comment"> *      message. The formatted message string will be truncated in size to #MPR_MAX_STRING bytes. </span>
<a name="l02771"></a>02771 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02772"></a>02772 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02773"></a>02773 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02774"></a>02774 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02775"></a>02775 <span class="comment"> */</span>
<a name="l02776"></a>02776 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g4d8c3a25cdbb3771266ee265a46156dd" title="Write a message to the diagnostic log file without allocating any memory.">mprStaticError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l02777"></a>02777 <span class="comment"></span>
<a name="l02778"></a>02778 <span class="comment">/**</span>
<a name="l02779"></a>02779 <span class="comment"> *  Display an error message to the user.</span>
<a name="l02780"></a>02780 <span class="comment"> *  @description Display an error message to the user and then send it to the </span>
<a name="l02781"></a>02781 <span class="comment"> *      MPR debug logging subsystem. The message will be passed to the log </span>
<a name="l02782"></a>02782 <span class="comment"> *      handler defined by mprSetLogHandler. It is up to the log handler to </span>
<a name="l02783"></a>02783 <span class="comment"> *      respond appropriately and display the message to the user.</span>
<a name="l02784"></a>02784 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02785"></a>02785 <span class="comment"> *  @param fmt Printf style format string. Variable number of arguments to </span>
<a name="l02786"></a>02786 <span class="comment"> *  @param ... Variable number of arguments for printf data</span>
<a name="l02787"></a>02787 <span class="comment"> *  @ingroup MprLog</span>
<a name="l02788"></a>02788 <span class="comment"> */</span>
<a name="l02789"></a>02789 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g0b7873bee991ee0160420868906eeb8c" title="Display an error message to the user.">mprUserError</a>(MprCtx ctx, cchar *fmt, ...);
<a name="l02790"></a>02790 <span class="comment"></span>
<a name="l02791"></a>02791 <span class="comment">/**</span>
<a name="l02792"></a>02792 <span class="comment"> *  Hash table entry structure.</span>
<a name="l02793"></a>02793 <span class="comment"> *  @description Each hash entry has a descriptor entry. This is used to manage the hash table link chains.</span>
<a name="l02794"></a>02794 <span class="comment"> *  @see MprHash, mprAddHash, mprAddDuplicateHash, mprCopyHash, mprCreateHash, mprGetFirstHash, mprGetNextHash,</span>
<a name="l02795"></a>02795 <span class="comment"> *      mprGethashCount, mprLookupHash, mprLookupHashEntry, mprRemoveHash, mprFree, mprCreateKeyPair</span>
<a name="l02796"></a>02796 <span class="comment"> *  @stability Evolving.</span>
<a name="l02797"></a>02797 <span class="comment"> *  @defgroup MprHash MprHash</span>
<a name="l02798"></a>02798 <span class="comment"> */</span>
<a name="l02799"></a>02799 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprHash {
<a name="l02800"></a>02800     <span class="keyword">struct </span>MprHash *next;               <span class="comment">/**&lt; Next symbol in hash chain */</span>
<a name="l02801"></a>02801     <span class="keywordtype">char</span>            *key;               <span class="comment">/**&lt; Hash key */</span>
<a name="l02802"></a>02802     cvoid           *data;              <span class="comment">/**&lt; Pointer to symbol data */</span>
<a name="l02803"></a>02803     <span class="keywordtype">int</span>             bucket;             <span class="comment">/**&lt; Hash bucket index */</span>
<a name="l02804"></a>02804 } MprHash;
<a name="l02805"></a>02805 <span class="comment"></span>
<a name="l02806"></a>02806 <span class="comment">/**</span>
<a name="l02807"></a>02807 <span class="comment"> *  Hash table control structure</span>
<a name="l02808"></a>02808 <span class="comment"> */</span>
<a name="l02809"></a><a class="code" href="struct_mpr_hash_table.html">02809</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> {
<a name="l02810"></a><a class="code" href="struct_mpr_hash_table.html#f2a7c133a69958ebe429f73f7e70f40a">02810</a>     MprHash         **<a class="code" href="struct_mpr_hash_table.html#f2a7c133a69958ebe429f73f7e70f40a" title="Hash collision bucket table.">buckets</a>;          <span class="comment">/**&lt; Hash collision bucket table */</span>
<a name="l02811"></a><a class="code" href="struct_mpr_hash_table.html#d9c80cbb86727a9758eed87879142cd1">02811</a>     <span class="keywordtype">int</span>             <a class="code" href="struct_mpr_hash_table.html#d9c80cbb86727a9758eed87879142cd1" title="Size of the buckets array.">hashSize</a>;           <span class="comment">/**&lt; Size of the buckets array */</span>
<a name="l02812"></a><a class="code" href="struct_mpr_hash_table.html#138d2e8720dd302652ac2799d2fbd16f">02812</a>     <span class="keywordtype">int</span>             <a class="code" href="struct_mpr_hash_table.html#138d2e8720dd302652ac2799d2fbd16f" title="Number of symbols in the table.">count</a>;              <span class="comment">/**&lt; Number of symbols in the table */</span>
<a name="l02813"></a>02813 } <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a>;
<a name="l02814"></a>02814 <span class="comment"></span>
<a name="l02815"></a>02815 <span class="comment">/**</span>
<a name="l02816"></a>02816 <span class="comment"> *  Add a symbol value into the hash table</span>
<a name="l02817"></a>02817 <span class="comment"> *  @description Associate an arbitrary value with a string symbol key and insert into the symbol table.</span>
<a name="l02818"></a>02818 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02819"></a>02819 <span class="comment"> *  @param key String key of the symbole entry to delete.</span>
<a name="l02820"></a>02820 <span class="comment"> *  @param ptr Arbitrary pointer to associate with the key in the table.</span>
<a name="l02821"></a>02821 <span class="comment"> *  @return Integer count of the number of entries.</span>
<a name="l02822"></a>02822 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02823"></a>02823 <span class="comment"> */</span>
<a name="l02824"></a>02824 <span class="keyword">extern</span> MprHash *<a class="code" href="group___mpr_hash.html#gdd7d9c74e9073729c721efe1e5dec0aa" title="Add a symbol value into the hash table.">mprAddHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, cchar *key, cvoid *ptr);
<a name="l02825"></a>02825 <span class="comment"></span>
<a name="l02826"></a>02826 <span class="comment">/**</span>
<a name="l02827"></a>02827 <span class="comment"> *  Add a duplicate symbol value into the hash table</span>
<a name="l02828"></a>02828 <span class="comment"> *  @description Add a symbol to the hash which may clash with an existing entry. Duplicate symbols can be added to</span>
<a name="l02829"></a>02829 <span class="comment"> *      the hash, but only one may be retrieved via #mprLookupHash. To recover duplicate entries walk the hash using</span>
<a name="l02830"></a>02830 <span class="comment"> *      #mprGetNextHash.</span>
<a name="l02831"></a>02831 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02832"></a>02832 <span class="comment"> *  @param key String key of the symbole entry to delete.</span>
<a name="l02833"></a>02833 <span class="comment"> *  @param ptr Arbitrary pointer to associate with the key in the table.</span>
<a name="l02834"></a>02834 <span class="comment"> *  @return Integer count of the number of entries.</span>
<a name="l02835"></a>02835 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02836"></a>02836 <span class="comment"> */</span>
<a name="l02837"></a>02837 <span class="keyword">extern</span> MprHash *<a class="code" href="group___mpr_hash.html#g6cac9e79143bfdc2c884590446e5edaf" title="Add a duplicate symbol value into the hash table.">mprAddDuplicateHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, cchar *key, cvoid *ptr);
<a name="l02838"></a>02838 <span class="comment"></span>
<a name="l02839"></a>02839 <span class="comment">/**</span>
<a name="l02840"></a>02840 <span class="comment"> *  Copy a hash table</span>
<a name="l02841"></a>02841 <span class="comment"> *  @description Create a new hash table and copy all the entries from an existing table.</span>
<a name="l02842"></a>02842 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02843"></a>02843 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02844"></a>02844 <span class="comment"> *  @return A new hash table initialized with the contents of the original hash table.</span>
<a name="l02845"></a>02845 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02846"></a>02846 <span class="comment"> */</span>
<a name="l02847"></a>02847 <span class="keyword">extern</span> <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *<a class="code" href="group___mpr_hash.html#g84a5c66179387a6fc1090f5117d49af1" title="Copy a hash table.">mprCopyHash</a>(MprCtx ctx, <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table);
<a name="l02848"></a>02848 <span class="comment"></span>
<a name="l02849"></a>02849 <span class="comment">/**</span>
<a name="l02850"></a>02850 <span class="comment"> *  Create a hash table</span>
<a name="l02851"></a>02851 <span class="comment"> *  @description Creates a hash table that can store arbitrary objects associated with string key values.</span>
<a name="l02852"></a>02852 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l02853"></a>02853 <span class="comment"> *  @param hashSize Size of the hash table for the symbol table. Should be a prime number.</span>
<a name="l02854"></a>02854 <span class="comment"> *  @return Returns a pointer to the allocated symbol table. Caller should use mprFree to dispose of the table </span>
<a name="l02855"></a>02855 <span class="comment"> *      when complete.</span>
<a name="l02856"></a>02856 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02857"></a>02857 <span class="comment"> */</span>
<a name="l02858"></a>02858 <span class="keyword">extern</span> <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *<a class="code" href="group___mpr_hash.html#gf653f8353d355f27d6fc00883daa82d9" title="Create a hash table.">mprCreateHash</a>(MprCtx ctx, <span class="keywordtype">int</span> hashSize);
<a name="l02859"></a>02859 <span class="comment"></span>
<a name="l02860"></a>02860 <span class="comment">/**</span>
<a name="l02861"></a>02861 <span class="comment"> *  Return the first symbol in a symbol entry</span>
<a name="l02862"></a>02862 <span class="comment"> *  @description Prepares for walking the contents of a symbol table by returning the first entry in the symbol table.</span>
<a name="l02863"></a>02863 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02864"></a>02864 <span class="comment"> *  @return Pointer to the first entry in the symbol table.</span>
<a name="l02865"></a>02865 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02866"></a>02866 <span class="comment"> */</span>
<a name="l02867"></a>02867 <span class="keyword">extern</span> MprHash *<a class="code" href="group___mpr_hash.html#g56c37e6def80582b297fa3c27cd5a15e" title="Return the first symbol in a symbol entry.">mprGetFirstHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table);
<a name="l02868"></a>02868 <span class="comment"></span>
<a name="l02869"></a>02869 <span class="comment">/**</span>
<a name="l02870"></a>02870 <span class="comment"> *  Return the next symbol in a symbol entry</span>
<a name="l02871"></a>02871 <span class="comment"> *  @description Continues walking the contents of a symbol table by returning</span>
<a name="l02872"></a>02872 <span class="comment"> *      the next entry in the symbol table. A previous call to mprGetFirstSymbol</span>
<a name="l02873"></a>02873 <span class="comment"> *      or mprGetNextSymbol is required to supply the value of the \a last</span>
<a name="l02874"></a>02874 <span class="comment"> *      argument.</span>
<a name="l02875"></a>02875 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02876"></a>02876 <span class="comment"> *  @param last Symbol table entry returned via mprGetFirstSymbol or mprGetNextSymbol.</span>
<a name="l02877"></a>02877 <span class="comment"> *  @return Pointer to the first entry in the symbol table.</span>
<a name="l02878"></a>02878 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02879"></a>02879 <span class="comment"> */</span>
<a name="l02880"></a>02880 <span class="keyword">extern</span> MprHash *<a class="code" href="group___mpr_hash.html#gba1514fa60bf0b72bf528b2c1fbecfc3" title="Return the next symbol in a symbol entry.">mprGetNextHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, MprHash *last);
<a name="l02881"></a>02881 <span class="comment"></span>
<a name="l02882"></a>02882 <span class="comment">/**</span>
<a name="l02883"></a>02883 <span class="comment"> *  Return the count of symbols in a symbol entry</span>
<a name="l02884"></a>02884 <span class="comment"> *  @description Returns the number of symbols currently existing in a symbol table.</span>
<a name="l02885"></a>02885 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02886"></a>02886 <span class="comment"> *  @return Integer count of the number of entries.</span>
<a name="l02887"></a>02887 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02888"></a>02888 <span class="comment"> */</span>
<a name="l02889"></a>02889 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_hash.html#gb18f7a0015706d7c7ded172357978875" title="Return the count of symbols in a symbol entry.">mprGetHashCount</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table);
<a name="l02890"></a>02890 <span class="comment"></span>
<a name="l02891"></a>02891 <span class="comment">/**</span>
<a name="l02892"></a>02892 <span class="comment"> *  Lookup a symbol in the hash table.</span>
<a name="l02893"></a>02893 <span class="comment"> *  @description Lookup a symbol key and return the value associated with that key.</span>
<a name="l02894"></a>02894 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02895"></a>02895 <span class="comment"> *  @param key String key of the symbole entry to delete.</span>
<a name="l02896"></a>02896 <span class="comment"> *  @return Value associated with the key when the entry was inserted via mprInsertSymbol.</span>
<a name="l02897"></a>02897 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02898"></a>02898 <span class="comment"> */</span>
<a name="l02899"></a>02899 <span class="keyword">extern</span> cvoid *<a class="code" href="group___mpr_hash.html#gf3613de4c34a09b684aebddadc0851cb" title="Lookup a symbol in the hash table.">mprLookupHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, cchar *key);
<a name="l02900"></a>02900 <span class="comment"></span>
<a name="l02901"></a>02901 <span class="comment">/**</span>
<a name="l02902"></a>02902 <span class="comment"> *  Lookup a symbol in the hash table and return the hash entry</span>
<a name="l02903"></a>02903 <span class="comment"> *  @description Lookup a symbol key and return the hash table descriptor associated with that key.</span>
<a name="l02904"></a>02904 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02905"></a>02905 <span class="comment"> *  @param key String key of the symbole entry to delete.</span>
<a name="l02906"></a>02906 <span class="comment"> *  @return MprHash table structure for the entry</span>
<a name="l02907"></a>02907 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02908"></a>02908 <span class="comment"> */</span>
<a name="l02909"></a>02909 <span class="keyword">extern</span> MprHash *<a class="code" href="group___mpr_hash.html#g69e2a6c5e3b8f36892d841d7019a657f" title="Lookup a symbol in the hash table and return the hash entry.">mprLookupHashEntry</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, cchar *key);
<a name="l02910"></a>02910 <span class="comment"></span>
<a name="l02911"></a>02911 <span class="comment">/**</span>
<a name="l02912"></a>02912 <span class="comment"> *  Remove a symbol entry from the hash table.</span>
<a name="l02913"></a>02913 <span class="comment"> *  @description Removes a symbol entry from the symbol table. The entry is looked up via the supplied \a key.</span>
<a name="l02914"></a>02914 <span class="comment"> *  @param table Symbol table returned via mprCreateSymbolTable.</span>
<a name="l02915"></a>02915 <span class="comment"> *  @param key String key of the symbole entry to delete.</span>
<a name="l02916"></a>02916 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code is returned.</span>
<a name="l02917"></a>02917 <span class="comment"> *  @ingroup MprHash</span>
<a name="l02918"></a>02918 <span class="comment"> */</span>
<a name="l02919"></a>02919 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_hash.html#g18a3c4ccbb662c68f32d6eff52f045bf" title="Remove a symbol entry from the hash table.">mprRemoveHash</a>(<a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a> *table, cchar *key);
<a name="l02920"></a>02920 
<a name="l02921"></a>02921 <span class="comment">/*</span>
<a name="l02922"></a>02922 <span class="comment"> *  Prototypes for file system switch methods</span>
<a name="l02923"></a>02923 <span class="comment"> */</span>
<a name="l02924"></a>02924 <span class="keyword">typedef</span> bool            (*MprAccessFileProc)(<span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path, <span class="keywordtype">int</span> omode);
<a name="l02925"></a>02925 <span class="keyword">typedef</span> int             (*MprDeleteFileProc)(<span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path);
<a name="l02926"></a>02926 <span class="keyword">typedef</span> int             (*MprDeleteDirProc)(<span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path);
<a name="l02927"></a>02927 <span class="keyword">typedef</span> int             (*MprGetPathInfoProc)(<span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path, <span class="keyword">struct </span>MprPath *info);
<a name="l02928"></a>02928 <span class="keyword">typedef</span> int             (*MprMakeDirProc)(<span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path, <span class="keywordtype">int</span> perms);
<a name="l02929"></a>02929 <span class="keyword">typedef</span> int             (*MprCloseFileProc)(<span class="keyword">struct </span>MprFile *file);
<a name="l02930"></a>02930 <span class="keyword">typedef</span> int             (*MprReadFileProc)(<span class="keyword">struct </span>MprFile *file, <span class="keywordtype">void</span> *buf, uint size);
<a name="l02931"></a>02931 <span class="keyword">typedef</span> long            (*MprSeekFileProc)(<span class="keyword">struct </span>MprFile *file, <span class="keywordtype">int</span> seekType, <span class="keywordtype">long</span> distance);
<a name="l02932"></a>02932 <span class="keyword">typedef</span> int             (*MprSetBufferedProc)(<span class="keyword">struct </span>MprFile *file, <span class="keywordtype">int</span> initialSize, <span class="keywordtype">int</span> maxSize);
<a name="l02933"></a>02933 <span class="keyword">typedef</span> int             (*MprWriteFileProc)(<span class="keyword">struct </span>MprFile *file, cvoid *buf, uint count);
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="preprocessor">#if !DOXYGEN</span>
<a name="l02936"></a>02936 <span class="preprocessor"></span><span class="comment">/* Work around doxygen bug */</span>
<a name="l02937"></a>02937 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprFile* (*MprOpenFileProc)(MprCtx ctx, <span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs, cchar *path, <span class="keywordtype">int</span> omode, <span class="keywordtype">int</span> perms);
<a name="l02938"></a>02938 <span class="preprocessor">#endif</span>
<a name="l02939"></a>02939 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02940"></a>02940 <span class="comment">/**</span>
<a name="l02941"></a>02941 <span class="comment"> *  File system service</span>
<a name="l02942"></a>02942 <span class="comment"> *  @description The MPR provides a file system abstraction to support non-disk based file access such as flash or </span>
<a name="l02943"></a>02943 <span class="comment"> *      other ROM based file systems. The MprFileSystem structure defines a virtual file system interface that</span>
<a name="l02944"></a>02944 <span class="comment"> *      will be invoked by the various MPR file routines.</span>
<a name="l02945"></a>02945 <span class="comment"> */</span>
<a name="l02946"></a><a class="code" href="struct_mpr_file_system.html">02946</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> {
<a name="l02947"></a><a class="code" href="struct_mpr_file_system.html#5e38be96c5740833a45e22af727841ad">02947</a>     MprAccessFileProc   <a class="code" href="struct_mpr_file_system.html#5e38be96c5740833a45e22af727841ad" title="Virtual access file routine.">accessPath</a>;     <span class="comment">/**&lt; Virtual access file routine */</span>
<a name="l02948"></a><a class="code" href="struct_mpr_file_system.html#de70dd4a4a64b35b9e8e01786d4b5cbb">02948</a>     MprDeleteFileProc   <a class="code" href="struct_mpr_file_system.html#de70dd4a4a64b35b9e8e01786d4b5cbb" title="Virtual delete file routine.">deletePath</a>;     <span class="comment">/**&lt; Virtual delete file routine */</span>
<a name="l02949"></a><a class="code" href="struct_mpr_file_system.html#0ec09744445986fe68db0aca69fa15f3">02949</a>     MprGetPathInfoProc  <a class="code" href="struct_mpr_file_system.html#0ec09744445986fe68db0aca69fa15f3" title="Virtual get file information routine.">getPathInfo</a>;    <span class="comment">/**&lt; Virtual get file information routine */</span>
<a name="l02950"></a><a class="code" href="struct_mpr_file_system.html#64221e1859f7d931b789bcf48a605e3e">02950</a>     MprMakeDirProc      <a class="code" href="struct_mpr_file_system.html#64221e1859f7d931b789bcf48a605e3e" title="Virtual make directory routine.">makeDir</a>;        <span class="comment">/**&lt; Virtual make directory routine */</span>
<a name="l02951"></a><a class="code" href="struct_mpr_file_system.html#a99b374f8a7246c0994b431fb7e464be">02951</a>     MprOpenFileProc     <a class="code" href="struct_mpr_file_system.html#a99b374f8a7246c0994b431fb7e464be" title="Virtual open file routine.">openFile</a>;       <span class="comment">/**&lt; Virtual open file routine */</span>
<a name="l02952"></a><a class="code" href="struct_mpr_file_system.html#7df8785da0a67e2016265d3b59d738e5">02952</a>     MprCloseFileProc    <a class="code" href="struct_mpr_file_system.html#7df8785da0a67e2016265d3b59d738e5" title="Virtual close file routine.">closeFile</a>;      <span class="comment">/**&lt; Virtual close file routine */</span>
<a name="l02953"></a><a class="code" href="struct_mpr_file_system.html#7175e397f99eb660db76ad895646133d">02953</a>     MprReadFileProc     <a class="code" href="struct_mpr_file_system.html#7175e397f99eb660db76ad895646133d" title="Virtual read file routine.">readFile</a>;       <span class="comment">/**&lt; Virtual read file routine */</span>
<a name="l02954"></a><a class="code" href="struct_mpr_file_system.html#2a8005c378cbc4055d508f2b63ca0339">02954</a>     MprSeekFileProc     <a class="code" href="struct_mpr_file_system.html#2a8005c378cbc4055d508f2b63ca0339" title="Virtual seek file routine.">seekFile</a>;       <span class="comment">/**&lt; Virtual seek file routine */</span>
<a name="l02955"></a><a class="code" href="struct_mpr_file_system.html#c0abc8c8d32e710ca939941d980d4939">02955</a>     MprSetBufferedProc  <a class="code" href="struct_mpr_file_system.html#c0abc8c8d32e710ca939941d980d4939" title="Virtual set buffered I/O routine.">setBuffered</a>;    <span class="comment">/**&lt; Virtual set buffered I/O routine */</span>
<a name="l02956"></a><a class="code" href="struct_mpr_file_system.html#0f0d990df095b7581f9897b40744b1ed">02956</a>     MprWriteFileProc    <a class="code" href="struct_mpr_file_system.html#0f0d990df095b7581f9897b40744b1ed" title="Virtual write file routine.">writeFile</a>;      <span class="comment">/**&lt; Virtual write file routine */</span>
<a name="l02957"></a><a class="code" href="struct_mpr_file_system.html#c899e638f8607eae5ab63e5b5972ef34">02957</a>     <span class="keyword">struct </span>MprFile      *<a class="code" href="struct_mpr_file_system.html#c899e638f8607eae5ab63e5b5972ef34" title="Standard error file.">stdError</a>;      <span class="comment">/**&lt; Standard error file */</span>
<a name="l02958"></a><a class="code" href="struct_mpr_file_system.html#be08971a623907993f3ca6277e3b5921">02958</a>     <span class="keyword">struct </span>MprFile      *<a class="code" href="struct_mpr_file_system.html#be08971a623907993f3ca6277e3b5921" title="Standard input file.">stdInput</a>;      <span class="comment">/**&lt; Standard input file */</span>
<a name="l02959"></a><a class="code" href="struct_mpr_file_system.html#0028d6e0f1a5c606a7fb2c25fffe4b78">02959</a>     <span class="keyword">struct </span>MprFile      *<a class="code" href="struct_mpr_file_system.html#0028d6e0f1a5c606a7fb2c25fffe4b78" title="Standard output file.">stdOutput</a>;     <span class="comment">/**&lt; Standard output file */</span>
<a name="l02960"></a><a class="code" href="struct_mpr_file_system.html#9b4688b394cbaf9e9ee4657529f1e39a">02960</a>     <span class="keywordtype">bool</span>                <a class="code" href="struct_mpr_file_system.html#9b4688b394cbaf9e9ee4657529f1e39a" title="Path comparisons are case sensitive.">caseSensitive</a>;  <span class="comment">/**&lt; Path comparisons are case sensitive */</span>
<a name="l02961"></a><a class="code" href="struct_mpr_file_system.html#c8949ced258642ec23295cb6f875f35e">02961</a>     <span class="keywordtype">bool</span>                <a class="code" href="struct_mpr_file_system.html#c8949ced258642ec23295cb6f875f35e" title="Paths can have drive specifications.">hasDriveSpecs</a>;  <span class="comment">/**&lt; Paths can have drive specifications */</span>
<a name="l02962"></a><a class="code" href="struct_mpr_file_system.html#8fbd13ce78415325e0e1152cbe90ad03">02962</a>     <span class="keywordtype">char</span>                *<a class="code" href="struct_mpr_file_system.html#8fbd13ce78415325e0e1152cbe90ad03" title="Filename path separators.">separators</a>;    <span class="comment">/**&lt; Filename path separators. First separator is the preferred separator. */</span>
<a name="l02963"></a><a class="code" href="struct_mpr_file_system.html#0fadda61688308594e9f3fbcbd5234d9">02963</a>     <span class="keywordtype">char</span>                *<a class="code" href="struct_mpr_file_system.html#0fadda61688308594e9f3fbcbd5234d9" title="Portable path separators.">portSeparators</a>;<span class="comment">/**&lt; Portable path separators. Typically "/\\" */</span>
<a name="l02964"></a><a class="code" href="struct_mpr_file_system.html#e73fbee65d384f31201b4da6532078b5">02964</a>     <span class="keywordtype">char</span>                *<a class="code" href="struct_mpr_file_system.html#e73fbee65d384f31201b4da6532078b5" title="Newline for text files.">newline</a>;       <span class="comment">/**&lt; Newline for text files */</span>
<a name="l02965"></a><a class="code" href="struct_mpr_file_system.html#0fed3fab45a0a7492c0a0cc152a44473">02965</a>     cchar               *<a class="code" href="struct_mpr_file_system.html#0fed3fab45a0a7492c0a0cc152a44473" title="Root file path.">root</a>;          <span class="comment">/**&lt; Root file path */</span>
<a name="l02966"></a>02966 
<a name="l02967"></a>02967 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l02968"></a><a class="code" href="struct_mpr_file_system.html#120bf58a6da09dc91d7fe17b72a5c056">02968</a> <span class="preprocessor"></span>    <span class="keywordtype">char</span>            *<a class="code" href="struct_mpr_file_system.html#120bf58a6da09dc91d7fe17b72a5c056" title="Cygwin drive root.">cygdrive</a>;          <span class="comment">/**&lt; Cygwin drive root */</span>
<a name="l02969"></a>02969 <span class="preprocessor">#endif</span>
<a name="l02970"></a>02970 <span class="preprocessor"></span>
<a name="l02971"></a>02971 } <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a>;
<a name="l02972"></a>02972 
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="preprocessor">#if BLD_FEATURE_ROMFS</span>
<a name="l02975"></a>02975 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l02976"></a>02976 <span class="comment"> *  A RomInode is created for each file in the Rom file system.</span>
<a name="l02977"></a>02977 <span class="comment"> */</span>
<a name="l02978"></a>02978 <span class="keyword">typedef</span> <span class="keyword">struct  </span>MprRomInode {
<a name="l02979"></a>02979     <span class="keywordtype">char</span>            *path;              <span class="comment">/* File path */</span>
<a name="l02980"></a>02980     uchar           *data;              <span class="comment">/* Pointer to file data */</span>
<a name="l02981"></a>02981     <span class="keywordtype">int</span>             size;               <span class="comment">/* Size of file */</span>
<a name="l02982"></a>02982     <span class="keywordtype">int</span>             num;                <span class="comment">/* Inode number */</span>
<a name="l02983"></a>02983 } MprRomInode;
<a name="l02984"></a>02984 
<a name="l02985"></a>02985 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprRomFileSystem {
<a name="l02986"></a>02986     <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a>   fileSystem;
<a name="l02987"></a>02987     <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a>    *fileIndex;
<a name="l02988"></a>02988     MprRomInode     *romInodes;
<a name="l02989"></a>02989     <span class="keywordtype">char</span>            *root;
<a name="l02990"></a>02990     <span class="keywordtype">int</span>             rootLen;
<a name="l02991"></a>02991 } MprRomFileSystem;
<a name="l02992"></a>02992 <span class="preprocessor">#else</span>
<a name="l02993"></a>02993 <span class="preprocessor"></span>
<a name="l02994"></a>02994 <span class="keyword">typedef</span> <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> MprDiskFileSystem;
<a name="l02995"></a>02995 <span class="preprocessor">#endif</span>
<a name="l02996"></a>02996 <span class="preprocessor"></span>
<a name="l02997"></a>02997 <span class="comment">/*</span>
<a name="l02998"></a>02998 <span class="comment"> *  File system initialization routines</span>
<a name="l02999"></a>02999 <span class="comment"> */</span>
<a name="l03000"></a>03000 <span class="keyword">extern</span> <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *mprCreateFileSystem(MprCtx ctx, cchar *path);
<a name="l03001"></a>03001 <span class="preprocessor">#if BLD_FEATURE_ROMFS</span>
<a name="l03002"></a>03002 <span class="preprocessor"></span>    <span class="keyword">extern</span> MprRomFileSystem *mprCreateRomFileSystem(MprCtx ctx, cchar *path);
<a name="l03003"></a>03003     <span class="keyword">extern</span> <span class="keywordtype">int</span> mprSetRomFileSystem(MprCtx ctx, MprRomInode *inodeList);
<a name="l03004"></a>03004 <span class="preprocessor">#else</span>
<a name="l03005"></a>03005 <span class="preprocessor"></span>    <span class="keyword">extern</span> MprDiskFileSystem *mprCreateDiskFileSystem(MprCtx ctx, cchar *path);
<a name="l03006"></a>03006 <span class="preprocessor">#endif</span>
<a name="l03007"></a>03007 <span class="preprocessor"></span>
<a name="l03008"></a>03008 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprAddFileSystem(MprCtx ctx, <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *fs);
<a name="l03009"></a>03009 <span class="keyword">extern</span> <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a> *mprLookupFileSystem(MprCtx ctx, cchar *path);
<a name="l03010"></a>03010 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetPathSeparators(MprCtx ctx, cchar *path, cchar *separators);
<a name="l03011"></a>03011 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetPathNewline(MprCtx ctx, cchar *path, cchar *newline);
<a name="l03012"></a>03012 <span class="comment"></span>
<a name="l03013"></a>03013 <span class="comment">/**</span>
<a name="l03014"></a>03014 <span class="comment"> *  File I/O Module</span>
<a name="l03015"></a>03015 <span class="comment"> *  @description MprFile is the cross platform File I/O abstraction control structure. An instance will be</span>
<a name="l03016"></a>03016 <span class="comment"> *       created when a file is created or opened via #mprOpen.</span>
<a name="l03017"></a>03017 <span class="comment"> *  @stability Evolving.</span>
<a name="l03018"></a>03018 <span class="comment"> *  @see MprFile mprClose mprGets mprOpen mprPutc mprPuts mprRead mprSeek mprWrite mprWriteString mprWriteFormat</span>
<a name="l03019"></a>03019 <span class="comment"> *      mprFlush MprFile mprGetc mprDisableFileBuffering mprEnableFileBuffering mprGetFileSize </span>
<a name="l03020"></a>03020 <span class="comment"> *      mprGetFilePosition mprPeekc</span>
<a name="l03021"></a>03021 <span class="comment"> *</span>
<a name="l03022"></a>03022 <span class="comment"> *  @defgroup MprFile MprFile</span>
<a name="l03023"></a>03023 <span class="comment"> */</span>
<a name="l03024"></a>03024 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprFile {
<a name="l03025"></a>03025     cchar           *path;              <span class="comment">/**&lt; Filename */</span>
<a name="l03026"></a>03026     <a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a>   *fileSystem;        <span class="comment">/**&lt; File system owning this file */</span>
<a name="l03027"></a>03027     MprBuf          *buf;               <span class="comment">/**&lt; Buffer for I/O if buffered */</span>
<a name="l03028"></a>03028     MprOffset       pos;                <span class="comment">/**&lt; Current read position  */</span>
<a name="l03029"></a>03029     MprOffset       iopos;              <span class="comment">/**&lt; Raw I/O position  */</span>
<a name="l03030"></a>03030     MprOffset       size;               <span class="comment">/**&lt; Current file size */</span>
<a name="l03031"></a>03031     <span class="keywordtype">int</span>             mode;               <span class="comment">/**&lt; File open mode */</span>
<a name="l03032"></a>03032     <span class="keywordtype">int</span>             perms;              <span class="comment">/**&lt; File permissions */</span>
<a name="l03033"></a>03033     <span class="keywordtype">int</span>             fd;                 <span class="comment">/**&lt; File handle */</span>
<a name="l03034"></a>03034 <span class="preprocessor">#if BLD_FEATURE_ROMFS</span>
<a name="l03035"></a>03035 <span class="preprocessor"></span>    MprRomInode     *inode;             <span class="comment">/**&lt; Reference to ROM file */</span>
<a name="l03036"></a>03036 <span class="preprocessor">#endif</span>
<a name="l03037"></a>03037 <span class="preprocessor"></span>} MprFile;
<a name="l03038"></a>03038 
<a name="l03039"></a>03039 <span class="comment"></span>
<a name="l03040"></a>03040 <span class="comment">/**</span>
<a name="l03041"></a>03041 <span class="comment"> *  Attach to an existing file descriptor</span>
<a name="l03042"></a>03042 <span class="comment"> *  @description Attach a file to an open file decriptor and return a file object.</span>
<a name="l03043"></a>03043 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03044"></a>03044 <span class="comment"> *  @param fd File descriptor to attach to</span>
<a name="l03045"></a>03045 <span class="comment"> *  @param name Descriptive name for the file.</span>
<a name="l03046"></a>03046 <span class="comment"> *  @param omode Posix style file open mode mask. The open mode may contain </span>
<a name="l03047"></a>03047 <span class="comment"> *      the following mask values ored together:</span>
<a name="l03048"></a>03048 <span class="comment"> *      @li O_RDONLY Open read only</span>
<a name="l03049"></a>03049 <span class="comment"> *      @li O_WRONLY Open write only</span>
<a name="l03050"></a>03050 <span class="comment"> *      @li O_RDWR Open for read and write</span>
<a name="l03051"></a>03051 <span class="comment"> *      @li O_CREAT Create or re-create</span>
<a name="l03052"></a>03052 <span class="comment"> *      @li O_TRUNC Truncate</span>
<a name="l03053"></a>03053 <span class="comment"> *      @li O_BINARY Open for binary data</span>
<a name="l03054"></a>03054 <span class="comment"> *      @li O_TEXT Open for text data</span>
<a name="l03055"></a>03055 <span class="comment"> *      @li O_EXCL Open with an exclusive lock</span>
<a name="l03056"></a>03056 <span class="comment"> *      @li O_APPEND Open to append</span>
<a name="l03057"></a>03057 <span class="comment"> *  @return Returns an MprFile object to use in other file operations.</span>
<a name="l03058"></a>03058 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03059"></a>03059 <span class="comment"> */</span>
<a name="l03060"></a>03060 <span class="keyword">extern</span> MprFile *<a class="code" href="group___mpr_file.html#ge05c883c658aef3c2e9da52e82e2a39b" title="Attach to an existing file descriptor.">mprAttachFd</a>(MprCtx ctx, <span class="keywordtype">int</span> fd, cchar *name, <span class="keywordtype">int</span> omode);
<a name="l03061"></a>03061 <span class="comment"></span>
<a name="l03062"></a>03062 <span class="comment">/**</span>
<a name="l03063"></a>03063 <span class="comment"> *  Disable file buffering</span>
<a name="l03064"></a>03064 <span class="comment"> *  @description Disable any buffering of data when using the buffer.</span>
<a name="l03065"></a>03065 <span class="comment"> *  @param file File instance returned from #mprOpen</span>
<a name="l03066"></a>03066 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03067"></a>03067 <span class="comment"> */</span>
<a name="l03068"></a>03068 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_file.html#g457be50126337e42f1df6c30af9db510" title="Disable file buffering.">mprDisableFileBuffering</a>(MprFile *file);
<a name="l03069"></a>03069 <span class="comment"></span>
<a name="l03070"></a>03070 <span class="comment">/**</span>
<a name="l03071"></a>03071 <span class="comment"> *  Enable file buffering</span>
<a name="l03072"></a>03072 <span class="comment"> *  @description Enable data buffering when using the buffer.</span>
<a name="l03073"></a>03073 <span class="comment"> *  @param file File instance returned from #mprOpen</span>
<a name="l03074"></a>03074 <span class="comment"> *  @param size Size to allocate for the buffer.</span>
<a name="l03075"></a>03075 <span class="comment"> *  @param maxSize Maximum size the data buffer can grow to</span>
<a name="l03076"></a>03076 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03077"></a>03077 <span class="comment"> */</span>
<a name="l03078"></a>03078 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g1912be708fa60f6afde7e174413507bc" title="Enable file buffering.">mprEnableFileBuffering</a>(MprFile *file, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> maxSize);
<a name="l03079"></a>03079 <span class="comment"></span>
<a name="l03080"></a>03080 <span class="comment">/**</span>
<a name="l03081"></a>03081 <span class="comment"> *  Flush any buffered write data</span>
<a name="l03082"></a>03082 <span class="comment"> *  @description Write buffered write data and then reset the internal buffers.</span>
<a name="l03083"></a>03083 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03084"></a>03084 <span class="comment"> *  @return Zero if successful, otherwise a negative MPR error code.</span>
<a name="l03085"></a>03085 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03086"></a>03086 <span class="comment"> */</span>
<a name="l03087"></a>03087 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g91dff182995e9e7f443373a5b27da4f4" title="Flush any buffered write data.">mprFlush</a>(MprFile *file);
<a name="l03088"></a>03088 <span class="comment"></span>
<a name="l03089"></a>03089 <span class="comment">/**</span>
<a name="l03090"></a>03090 <span class="comment"> *  Return the current file position</span>
<a name="l03091"></a>03091 <span class="comment"> *  @description Return the current read/write file position.</span>
<a name="l03092"></a>03092 <span class="comment"> *  @param file A file object returned from #mprOpen</span>
<a name="l03093"></a>03093 <span class="comment"> *  @returns The current file offset position if successful. Returns a negative MPR error code on errors.</span>
<a name="l03094"></a>03094 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03095"></a>03095 <span class="comment"> */</span>
<a name="l03096"></a>03096 <span class="keyword">extern</span> MprOffset <a class="code" href="group___mpr_file.html#g96273fe03aa3e5e1de8820e8aaba7e5c" title="Return the current file position.">mprGetFilePosition</a>(MprFile *file);
<a name="l03097"></a>03097 <span class="comment"></span>
<a name="l03098"></a>03098 <span class="comment">/**</span>
<a name="l03099"></a>03099 <span class="comment"> *  Get the size of the file</span>
<a name="l03100"></a>03100 <span class="comment"> *  @description Return the current file size</span>
<a name="l03101"></a>03101 <span class="comment"> *  @param file A file object returned from #mprOpen</span>
<a name="l03102"></a>03102 <span class="comment"> *  @returns The current file size if successful. Returns a negative MPR error code on errors.</span>
<a name="l03103"></a>03103 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03104"></a>03104 <span class="comment"> */</span>
<a name="l03105"></a>03105 <span class="keyword">extern</span> MprOffset <a class="code" href="group___mpr_file.html#gb1ae4e8c4128773497a609e444dbe8c7" title="Get the size of the file.">mprGetFileSize</a>(MprFile *file);
<a name="l03106"></a>03106 
<a name="l03107"></a>03107 <span class="comment">//  TODO - this should malloc</span><span class="comment"></span>
<a name="l03108"></a>03108 <span class="comment">/**</span>
<a name="l03109"></a>03109 <span class="comment"> *  Read a line from the file.</span>
<a name="l03110"></a>03110 <span class="comment"> *  @description Read a single line from the file and advance the read position. Lines are delimited by the </span>
<a name="l03111"></a>03111 <span class="comment"> *      newline character. The newline is not included in the returned buffer.</span>
<a name="l03112"></a>03112 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03113"></a>03113 <span class="comment"> *  @param buf Pre-allocated buffer to contain the line of data.</span>
<a name="l03114"></a>03114 <span class="comment"> *  @param size Size of \a buf.</span>
<a name="l03115"></a>03115 <span class="comment"> *  @return The number of characters read into \a buf.</span>
<a name="l03116"></a>03116 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03117"></a>03117 <span class="comment"> */</span>
<a name="l03118"></a>03118 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_file.html#g15a5b5e70b74166eb1aea7d278d11358" title="Read a line from the file.">mprGets</a>(MprFile *file, <span class="keywordtype">char</span> *buf, uint size);
<a name="l03119"></a>03119 <span class="comment"></span>
<a name="l03120"></a>03120 <span class="comment">/**</span>
<a name="l03121"></a>03121 <span class="comment"> *  Read a character from the file.</span>
<a name="l03122"></a>03122 <span class="comment"> *  @description Read a single character from the file and advance the read position.</span>
<a name="l03123"></a>03123 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03124"></a>03124 <span class="comment"> *  @return If successful, return the character just read. Otherwise return a negative MPR error code.</span>
<a name="l03125"></a>03125 <span class="comment"> *      End of file is signified by reading 0.</span>
<a name="l03126"></a>03126 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03127"></a>03127 <span class="comment"> */</span>
<a name="l03128"></a>03128 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g33e438e507e4e5effcddb2cc103e5c26" title="Read a character from the file.">mprGetc</a>(MprFile *file);
<a name="l03129"></a>03129 <span class="comment"></span>
<a name="l03130"></a>03130 <span class="comment">/**</span>
<a name="l03131"></a>03131 <span class="comment"> *  Return a file object for the Stdout I/O channel</span>
<a name="l03132"></a>03132 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03133"></a>03133 <span class="comment"> *  @returns A file object</span>
<a name="l03134"></a>03134 <span class="comment"> */</span>
<a name="l03135"></a>03135 <span class="keyword">extern</span> MprFile *<a class="code" href="mpr_8h.html#29ffea058d6f735313ee8a81fd3334dd" title="Return a file object for the Stdout I/O channel.">mprGetStdout</a>(MprCtx ctx);
<a name="l03136"></a>03136 <span class="comment"></span>
<a name="l03137"></a>03137 <span class="comment">/**</span>
<a name="l03138"></a>03138 <span class="comment"> *  Return a file object for the Stdin I/O channel</span>
<a name="l03139"></a>03139 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03140"></a>03140 <span class="comment"> *  @returns A file object</span>
<a name="l03141"></a>03141 <span class="comment"> */</span>
<a name="l03142"></a>03142 <span class="keyword">extern</span> MprFile *<a class="code" href="mpr_8h.html#f260b8f2c8c000a6f4ec1ac7569e8416" title="Return a file object for the Stdin I/O channel.">mprGetStdin</a>(MprCtx ctx);
<a name="l03143"></a>03143 <span class="comment"></span>
<a name="l03144"></a>03144 <span class="comment">/**</span>
<a name="l03145"></a>03145 <span class="comment"> *  Return a file object for the Stderr I/O channel</span>
<a name="l03146"></a>03146 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03147"></a>03147 <span class="comment"> *  @returns A file object</span>
<a name="l03148"></a>03148 <span class="comment"> */</span>
<a name="l03149"></a>03149 <span class="keyword">extern</span> MprFile *<a class="code" href="mpr_8h.html#7084bfea78dcf720c82e7163b9dbc4da" title="Return a file object for the Stderr I/O channel.">mprGetStderr</a>(MprCtx ctx);
<a name="l03150"></a>03150 <span class="comment"></span>
<a name="l03151"></a>03151 <span class="comment">/**</span>
<a name="l03152"></a>03152 <span class="comment"> *  Open a file</span>
<a name="l03153"></a>03153 <span class="comment"> *  @description Open a file and return a file object.</span>
<a name="l03154"></a>03154 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03155"></a>03155 <span class="comment"> *  @param filename String containing the filename to open or create.</span>
<a name="l03156"></a>03156 <span class="comment"> *  @param omode Posix style file open mode mask. The open mode may contain </span>
<a name="l03157"></a>03157 <span class="comment"> *      the following mask values ored together:</span>
<a name="l03158"></a>03158 <span class="comment"> *      @li O_RDONLY Open read only</span>
<a name="l03159"></a>03159 <span class="comment"> *      @li O_WRONLY Open write only</span>
<a name="l03160"></a>03160 <span class="comment"> *      @li O_RDWR Open for read and write</span>
<a name="l03161"></a>03161 <span class="comment"> *      @li O_CREAT Create or re-create</span>
<a name="l03162"></a>03162 <span class="comment"> *      @li O_TRUNC Truncate</span>
<a name="l03163"></a>03163 <span class="comment"> *      @li O_BINARY Open for binary data</span>
<a name="l03164"></a>03164 <span class="comment"> *      @li O_TEXT Open for text data</span>
<a name="l03165"></a>03165 <span class="comment"> *      @li O_EXCL Open with an exclusive lock</span>
<a name="l03166"></a>03166 <span class="comment"> *      @li O_APPEND Open to append</span>
<a name="l03167"></a>03167 <span class="comment"> *  @param perms Posix style file permissions mask.</span>
<a name="l03168"></a>03168 <span class="comment"> *  @return Returns an MprFile object to use in other file operations.</span>
<a name="l03169"></a>03169 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03170"></a>03170 <span class="comment"> */</span>
<a name="l03171"></a>03171 <span class="keyword">extern</span> MprFile *<a class="code" href="group___mpr_file.html#g4f97953317f303fe033be11fcbcec4e9" title="Open a file.">mprOpen</a>(MprCtx ctx, cchar *filename, <span class="keywordtype">int</span> omode, <span class="keywordtype">int</span> perms);
<a name="l03172"></a>03172 <span class="comment"></span>
<a name="l03173"></a>03173 <span class="comment">/**</span>
<a name="l03174"></a>03174 <span class="comment"> *  Non-destructively read a character from the file.</span>
<a name="l03175"></a>03175 <span class="comment"> *  @description Read a single character from the file without advancing the read position.</span>
<a name="l03176"></a>03176 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03177"></a>03177 <span class="comment"> *  @return If successful, return the character just read. Otherwise return a negative MPR error code.</span>
<a name="l03178"></a>03178 <span class="comment"> *      End of file is signified by reading 0.</span>
<a name="l03179"></a>03179 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03180"></a>03180 <span class="comment"> */</span>
<a name="l03181"></a>03181 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#gb50f74711c89a6eb57363aee8090b6bb" title="Non-destructively read a character from the file.">mprPeekc</a>(MprFile *file);
<a name="l03182"></a>03182 <span class="comment"></span>
<a name="l03183"></a>03183 <span class="comment">/**</span>
<a name="l03184"></a>03184 <span class="comment"> *  Write a character to the file.</span>
<a name="l03185"></a>03185 <span class="comment"> *  @description Writes a single character to the file. Output is buffered and is</span>
<a name="l03186"></a>03186 <span class="comment"> *      flushed as required or when mprClose is called.</span>
<a name="l03187"></a>03187 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03188"></a>03188 <span class="comment"> *  @param c Character to write</span>
<a name="l03189"></a>03189 <span class="comment"> *  @return One if successful, otherwise returns a negative MPR error code on errors.</span>
<a name="l03190"></a>03190 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03191"></a>03191 <span class="comment"> */</span>
<a name="l03192"></a>03192 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#gda34b4c0fbd1cd04fd636ab49e7dcb71" title="Write a character to the file.">mprPutc</a>(MprFile *file, <span class="keywordtype">int</span> c);
<a name="l03193"></a>03193 <span class="comment"></span>
<a name="l03194"></a>03194 <span class="comment">/**</span>
<a name="l03195"></a>03195 <span class="comment"> *  Write a string to the file.</span>
<a name="l03196"></a>03196 <span class="comment"> *  @description Writes a string to the file. Output is buffered and is flushed as required or when mprClose is called.</span>
<a name="l03197"></a>03197 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03198"></a>03198 <span class="comment"> *  @param str String to write</span>
<a name="l03199"></a>03199 <span class="comment"> *  @return The number of characters written to the file. Returns a negative MPR error code on errors.</span>
<a name="l03200"></a>03200 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03201"></a>03201 <span class="comment"> */</span>
<a name="l03202"></a>03202 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#ge172b6c82656af8d7a4f82bdff01977c" title="Write a string to the file.">mprPuts</a>(MprFile *file, cchar *str);
<a name="l03203"></a>03203 <span class="comment"></span>
<a name="l03204"></a>03204 <span class="comment">/**</span>
<a name="l03205"></a>03205 <span class="comment"> *  Read data from a file.</span>
<a name="l03206"></a>03206 <span class="comment"> *  @description Reads data from a file. </span>
<a name="l03207"></a>03207 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03208"></a>03208 <span class="comment"> *  @param buf Buffer to contain the read data.</span>
<a name="l03209"></a>03209 <span class="comment"> *  @param size Size of \a buf in characters.</span>
<a name="l03210"></a>03210 <span class="comment"> *  @return The number of characters read from the file. Returns a negative MPR error code on errors.</span>
<a name="l03211"></a>03211 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03212"></a>03212 <span class="comment"> */</span>
<a name="l03213"></a>03213 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#ge3052b9893259fb2f245d5e08310d9c5" title="Read data from a file.">mprRead</a>(MprFile *file, <span class="keywordtype">void</span> *buf, uint size);
<a name="l03214"></a>03214 <span class="comment"></span>
<a name="l03215"></a>03215 <span class="comment">/**</span>
<a name="l03216"></a>03216 <span class="comment"> *  Seek the I/O pointer to a new location in the file.</span>
<a name="l03217"></a>03217 <span class="comment"> *  @description Move the position in the file to/from which I/O will be performed in the file. Seeking prior </span>
<a name="l03218"></a>03218 <span class="comment"> *      to a read or write will cause the next I/O to occur at that location.</span>
<a name="l03219"></a>03219 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03220"></a>03220 <span class="comment"> *  @param seekType Seek type may be one of the following three values:</span>
<a name="l03221"></a>03221 <span class="comment"> *      @li SEEK_SET    Seek to a position relative to the start of the file</span>
<a name="l03222"></a>03222 <span class="comment"> *      @li SEEK_CUR    Seek relative to the current position</span>
<a name="l03223"></a>03223 <span class="comment"> *      @li SEEK_END    Seek relative to the end of the file</span>
<a name="l03224"></a>03224 <span class="comment"> *  @param distance A positive or negative byte offset.</span>
<a name="l03225"></a>03225 <span class="comment"> *  @return Returns the new file position if successful otherwise a negative MPR error code is returned.</span>
<a name="l03226"></a>03226 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03227"></a>03227 <span class="comment"> */</span>
<a name="l03228"></a>03228 <span class="keyword">extern</span> <span class="keywordtype">long</span> <a class="code" href="group___mpr_file.html#g6510f5de249f68beee6bbbe880549793" title="Seek the I/O pointer to a new location in the file.">mprSeek</a>(MprFile *file, <span class="keywordtype">int</span> seekType, <span class="keywordtype">long</span> distance);
<a name="l03229"></a>03229 <span class="comment"></span>
<a name="l03230"></a>03230 <span class="comment">/**</span>
<a name="l03231"></a>03231 <span class="comment"> *  Write data to a file.</span>
<a name="l03232"></a>03232 <span class="comment"> *  @description Writes data to a file. </span>
<a name="l03233"></a>03233 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03234"></a>03234 <span class="comment"> *  @param buf Buffer containing the data to write.</span>
<a name="l03235"></a>03235 <span class="comment"> *  @param count Cound of characters in \a buf to write</span>
<a name="l03236"></a>03236 <span class="comment"> *  @return The number of characters actually written to the file. Returns a negative MPR error code on errors.</span>
<a name="l03237"></a>03237 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03238"></a>03238 <span class="comment"> */</span>
<a name="l03239"></a>03239 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g1ccf3d98a34232049c0e97384fca88c3" title="Write data to a file.">mprWrite</a>(MprFile *file, cvoid *buf, uint count);
<a name="l03240"></a>03240 <span class="comment"></span>
<a name="l03241"></a>03241 <span class="comment">/**</span>
<a name="l03242"></a>03242 <span class="comment"> *  Write a string to a file.</span>
<a name="l03243"></a>03243 <span class="comment"> *  @description Writes a string to a file. </span>
<a name="l03244"></a>03244 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03245"></a>03245 <span class="comment"> *  @param str String to write</span>
<a name="l03246"></a>03246 <span class="comment"> *  @return The number of characters actually written to the file. Returns a negative MPR error code on errors.</span>
<a name="l03247"></a>03247 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03248"></a>03248 <span class="comment"> */</span>
<a name="l03249"></a>03249 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g3874c994f9f5b1c4c4fd57100a656148" title="Write a string to a file.">mprWriteString</a>(MprFile *file, cchar *str);
<a name="l03250"></a>03250 <span class="comment"></span>
<a name="l03251"></a>03251 <span class="comment">/**</span>
<a name="l03252"></a>03252 <span class="comment"> *  Write formatted data to a file.</span>
<a name="l03253"></a>03253 <span class="comment"> *  @description Writes a formatted string to a file. </span>
<a name="l03254"></a>03254 <span class="comment"> *  @param file Pointer to an MprFile object returned via MprOpen.</span>
<a name="l03255"></a>03255 <span class="comment"> *  @param fmt Format string</span>
<a name="l03256"></a>03256 <span class="comment"> *  @return The number of characters actually written to the file. Returns a negative MPR error code on errors.</span>
<a name="l03257"></a>03257 <span class="comment"> *  @ingroup MprFile</span>
<a name="l03258"></a>03258 <span class="comment"> */</span>
<a name="l03259"></a>03259 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_file.html#g7acf925a7a7f34a50f45e72e34ccc2c7" title="Write formatted data to a file.">mprWriteFormat</a>(MprFile *file, cchar *fmt, ...);
<a name="l03260"></a>03260 
<a name="l03261"></a>03261 <span class="comment"></span>
<a name="l03262"></a>03262 <span class="comment">/**</span>
<a name="l03263"></a>03263 <span class="comment"> *  Path (filename) Information</span>
<a name="l03264"></a>03264 <span class="comment"> *  @description MprPath is the cross platform Path (filename) information structure.</span>
<a name="l03265"></a>03265 <span class="comment"> *  @stability Evolving.</span>
<a name="l03266"></a>03266 <span class="comment"> *  @see MprPath mprComparePath mprCopyPath mprDeletePath mprGetAbsPath mprGetCurrentPath</span>
<a name="l03267"></a>03267 <span class="comment"> *      mprGetPathBase mprGetPathDir mprGetPathFiles mprGetPathExtension mprGetPathParent </span>
<a name="l03268"></a>03268 <span class="comment"> *      mprGetPathNewline mprGetPathSeparators mprGetPortablePath mprGetRelPath mprGetTempPath  mprGetTransformedPath</span>
<a name="l03269"></a>03269 <span class="comment"> *      mprIsAbsPath mprIsRelPath mprMakeDir mprGetNormalizedPath mprJoinPath mprJoinPathExt mprMapSeparators </span>
<a name="l03270"></a>03270 <span class="comment"> *      mprPathExists mprResolvePath mprSearchPath mprTruncatePath mprTrimExtension</span>
<a name="l03271"></a>03271 <span class="comment"> *      MprFile</span>
<a name="l03272"></a>03272 <span class="comment"> *  @defgroup MprPath MprPath</span>
<a name="l03273"></a>03273 <span class="comment"> */</span>
<a name="l03274"></a>03274 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprPath {
<a name="l03275"></a>03275     MprTime         atime;              <span class="comment">/**&lt; Access time */</span>
<a name="l03276"></a>03276     MprTime         ctime;              <span class="comment">/**&lt; Create time */</span>
<a name="l03277"></a>03277     MprTime         mtime;              <span class="comment">/**&lt; Modified time */</span>
<a name="l03278"></a>03278     int64           size;               <span class="comment">/**&lt; File length */</span>
<a name="l03279"></a>03279     uint            inode;              <span class="comment">/**&lt; Inode number */</span>
<a name="l03280"></a>03280     <span class="keywordtype">bool</span>            isDir;              <span class="comment">/**&lt; Set if directory */</span>
<a name="l03281"></a>03281     <span class="keywordtype">bool</span>            isReg;              <span class="comment">/**&lt; Set if a regular file */</span>
<a name="l03282"></a>03282     <span class="keywordtype">bool</span>            caseMatters;        <span class="comment">/**&lt; Case comparisons matter */</span>
<a name="l03283"></a>03283     <span class="keywordtype">int</span>             perms;              <span class="comment">/**&lt; Permission mask */</span>
<a name="l03284"></a>03284     <span class="keywordtype">int</span>             valid;              <span class="comment">/**&lt; Valid data bit */</span>
<a name="l03285"></a>03285     <span class="keywordtype">int</span>             checked;            <span class="comment">/**&lt; Path has been checked */</span>
<a name="l03286"></a>03286 } MprPath;
<a name="l03287"></a>03287 <span class="comment"></span>
<a name="l03288"></a>03288 <span class="comment">/**</span>
<a name="l03289"></a>03289 <span class="comment"> *  Directory entry description</span>
<a name="l03290"></a>03290 <span class="comment"> *  @description The MprGetDirList will create a list of directory entries.</span>
<a name="l03291"></a>03291 <span class="comment"> */</span>
<a name="l03292"></a><a class="code" href="struct_mpr_dir_entry.html">03292</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_dir_entry.html" title="Directory entry description.">MprDirEntry</a> {
<a name="l03293"></a><a class="code" href="struct_mpr_dir_entry.html#16a16d99cbcc311dee6203be8ad451af">03293</a>     <span class="keywordtype">char</span>            *<a class="code" href="struct_mpr_dir_entry.html#16a16d99cbcc311dee6203be8ad451af" title="Name of the file.">name</a>;              <span class="comment">/**&lt; Name of the file */</span>
<a name="l03294"></a><a class="code" href="struct_mpr_dir_entry.html#b1d21a790f6c8408f503749aea3cd0e6">03294</a>     MprTime         <a class="code" href="struct_mpr_dir_entry.html#b1d21a790f6c8408f503749aea3cd0e6" title="Time the file was last modified.">lastModified</a>;       <span class="comment">/**&lt; Time the file was last modified */</span>
<a name="l03295"></a><a class="code" href="struct_mpr_dir_entry.html#678268edb7f1b491c58d8f567bded12f">03295</a>     MprOffset       <a class="code" href="struct_mpr_dir_entry.html#678268edb7f1b491c58d8f567bded12f" title="Size of the file.">size</a>;               <span class="comment">/**&lt; Size of the file */</span>
<a name="l03296"></a><a class="code" href="struct_mpr_dir_entry.html#8f99ebdb879798eb9a39d355393f6e23">03296</a>     <span class="keywordtype">bool</span>            <a class="code" href="struct_mpr_dir_entry.html#8f99ebdb879798eb9a39d355393f6e23" title="True if the file is a directory.">isDir</a>;              <span class="comment">/**&lt; True if the file is a directory */</span>
<a name="l03297"></a>03297 } <a class="code" href="struct_mpr_dir_entry.html" title="Directory entry description.">MprDirEntry</a>;
<a name="l03298"></a>03298 <span class="comment"></span>
<a name="l03299"></a>03299 <span class="comment">/**</span>
<a name="l03300"></a>03300 <span class="comment"> *  Copy a file</span>
<a name="l03301"></a>03301 <span class="comment"> *  @description Create a new copy of a file with the specified open permissions mode.</span>
<a name="l03302"></a>03302 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03303"></a>03303 <span class="comment"> *  @param from Path of the existing file to copy</span>
<a name="l03304"></a>03304 <span class="comment"> *  @param to Name of the new file copy</span>
<a name="l03305"></a>03305 <span class="comment"> *  @param omode Posix style file open mode mask. See #mprOpen for the various modes.</span>
<a name="l03306"></a>03306 <span class="comment"> *  @returns True if the file exists and can be accessed</span>
<a name="l03307"></a>03307 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03308"></a>03308 <span class="comment"> */</span>
<a name="l03309"></a>03309 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g5819b28cca6734f98b1fe114c5620d8a" title="Copy a file.">mprCopyPath</a>(MprCtx ctx, cchar *from, cchar *to, <span class="keywordtype">int</span> omode);
<a name="l03310"></a>03310 <span class="comment"></span>
<a name="l03311"></a>03311 <span class="comment">/**</span>
<a name="l03312"></a>03312 <span class="comment"> *  Return the current working directory</span>
<a name="l03313"></a>03313 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03314"></a>03314 <span class="comment"> *  @return Returns an allocated string with the current working directory as an absolute path.</span>
<a name="l03315"></a>03315 <span class="comment"> */</span>
<a name="l03316"></a>03316 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#8b5d0f5ed666f1ec48caaf65a9304acb" title="Return the current working directory.">mprGetCurrentPath</a>(MprCtx ctx);
<a name="l03317"></a>03317 <span class="comment"></span>
<a name="l03318"></a>03318 <span class="comment">/**</span>
<a name="l03319"></a>03319 <span class="comment"> *  Delete a file.</span>
<a name="l03320"></a>03320 <span class="comment"> *  @description Delete a file or directory.</span>
<a name="l03321"></a>03321 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03322"></a>03322 <span class="comment"> *  @param path String containing the path to delete. </span>
<a name="l03323"></a>03323 <span class="comment"> *  @return Returns zero if successful otherwise a negative MPR error code is returned.</span>
<a name="l03324"></a>03324 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03325"></a>03325 <span class="comment"> */</span>
<a name="l03326"></a>03326 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g4e9f46a4287d3c8392e2bacfc45fea75" title="Delete a file.">mprDeletePath</a>(MprCtx ctx, cchar *path);
<a name="l03327"></a>03327 <span class="comment"></span>
<a name="l03328"></a>03328 <span class="comment">/**</span>
<a name="l03329"></a>03329 <span class="comment"> *  Convert a path to an absolute path</span>
<a name="l03330"></a>03330 <span class="comment"> *  @description Get an absolute (canonical) equivalent representation of a path. </span>
<a name="l03331"></a>03331 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03332"></a>03332 <span class="comment"> *  @param path Path to examine</span>
<a name="l03333"></a>03333 <span class="comment"> *  @returns An absolute path. Caller should free via #mprFree</span>
<a name="l03334"></a>03334 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03335"></a>03335 <span class="comment"> */</span>
<a name="l03336"></a>03336 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g6d804c1b812c9ea7a1d0fb09764def90" title="Convert a path to an absolute path.">mprGetAbsPath</a>(MprCtx ctx, cchar *path);
<a name="l03337"></a>03337 <span class="comment"></span>
<a name="l03338"></a>03338 <span class="comment">/**</span>
<a name="l03339"></a>03339 <span class="comment"> *  Get a path formatted according to the native O/S conventions.</span>
<a name="l03340"></a>03340 <span class="comment"> *  @description Get an equivalent absolute path formatted using the directory separators native to the O/S platform.</span>
<a name="l03341"></a>03341 <span class="comment"> *  On Windows, it will use backward slashes ("\") as the directory separator and will contain a drive specification.</span>
<a name="l03342"></a>03342 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03343"></a>03343 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03344"></a>03344 <span class="comment"> *  @returns An allocated string containing the new path. Caller must free using #mprFree.</span>
<a name="l03345"></a>03345 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03346"></a>03346 <span class="comment"> */</span>
<a name="l03347"></a>03347 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g2de05fa43e494c05da7b2e941f3f407d" title="Get a path formatted according to the native O/S conventions.">mprGetNativePath</a>(MprCtx ctx, cchar *path);
<a name="l03348"></a>03348 <span class="comment"></span>
<a name="l03349"></a>03349 <span class="comment">/**</span>
<a name="l03350"></a>03350 <span class="comment"> *  Get the base portion of a path</span>
<a name="l03351"></a>03351 <span class="comment"> *  @description Get the base portion of a path by stripping off all directory components</span>
<a name="l03352"></a>03352 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03353"></a>03353 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03354"></a>03354 <span class="comment"> *  @returns A path without any directory portion. The path is a reference into the original file string and </span>
<a name="l03355"></a>03355 <span class="comment"> *      should not be freed. </span>
<a name="l03356"></a>03356 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03357"></a>03357 <span class="comment"> */</span>
<a name="l03358"></a>03358 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g40b746d52c5d360b93e62cd7f151e790" title="Get the base portion of a path.">mprGetPathBase</a>(MprCtx ctx, cchar *path);
<a name="l03359"></a>03359 <span class="comment"></span>
<a name="l03360"></a>03360 <span class="comment">/**</span>
<a name="l03361"></a>03361 <span class="comment"> *  Get the directory portion of a path</span>
<a name="l03362"></a>03362 <span class="comment"> *  @description Get the directory portion of a path by stripping off the base name.</span>
<a name="l03363"></a>03363 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03364"></a>03364 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03365"></a>03365 <span class="comment"> *  @returns A new string containing the directory name. Caller must free.</span>
<a name="l03366"></a>03366 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03367"></a>03367 <span class="comment"> */</span>
<a name="l03368"></a>03368 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g0b13450482bec406bd1ca4f97e8b0ac9" title="Get the directory portion of a path.">mprGetPathDir</a>(MprCtx ctx, cchar *path);
<a name="l03369"></a>03369 <span class="comment"></span>
<a name="l03370"></a>03370 <span class="comment">/**</span>
<a name="l03371"></a>03371 <span class="comment"> *  Create a directory list of files.</span>
<a name="l03372"></a>03372 <span class="comment"> *  @description Get the list of files in a directory and return a list.</span>
<a name="l03373"></a>03373 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03374"></a>03374 <span class="comment"> *  @param dir Directory to list.</span>
<a name="l03375"></a>03375 <span class="comment"> *  @param enumDirs Set to true to enumerate directory entries as well as regular paths. </span>
<a name="l03376"></a>03376 <span class="comment"> *  @returns A list (MprList) of directory paths. Each path is a regular string owned by the list object.</span>
<a name="l03377"></a>03377 <span class="comment"> *      Use #mprFree to free the memory for the list and directory paths.</span>
<a name="l03378"></a>03378 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03379"></a>03379 <span class="comment"> */</span>
<a name="l03380"></a>03380 <span class="keyword">extern</span> MprList *<a class="code" href="group___mpr_path.html#gbee132c7baac86f676fa60f28d387341" title="Create a directory list of files.">mprGetPathFiles</a>(MprCtx ctx, cchar *dir, <span class="keywordtype">bool</span> enumDirs);
<a name="l03381"></a>03381 <span class="comment"></span>
<a name="l03382"></a>03382 <span class="comment">/**</span>
<a name="l03383"></a>03383 <span class="comment"> *  Get the file extension portion of a path</span>
<a name="l03384"></a>03384 <span class="comment"> *  @description Get the file extension portion of a path. The file extension is the portion starting with the last "."</span>
<a name="l03385"></a>03385 <span class="comment"> *      in the path. It thus includes "." as the first charcter.</span>
<a name="l03386"></a>03386 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03387"></a>03387 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03388"></a>03388 <span class="comment"> *  @returns A path extension. The extension is a reference into the original file string and should not be freed.</span>
<a name="l03389"></a>03389 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03390"></a>03390 <span class="comment"> */</span>
<a name="l03391"></a>03391 <span class="keyword">extern</span> cchar *<a class="code" href="group___mpr_path.html#g2aca381507c3d8455a896015d3532421" title="Get the file extension portion of a path.">mprGetPathExtension</a>(MprCtx ctx, cchar *path);
<a name="l03392"></a>03392 <span class="comment"></span>
<a name="l03393"></a>03393 <span class="comment">/**</span>
<a name="l03394"></a>03394 <span class="comment"> *  Return information about a file represented by a path.</span>
<a name="l03395"></a>03395 <span class="comment"> *  @description Returns file status information regarding the \a path.</span>
<a name="l03396"></a>03396 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03397"></a>03397 <span class="comment"> *  @param path String containing the path to query.</span>
<a name="l03398"></a>03398 <span class="comment"> *  @param info Pointer to a pre-allocated MprPath structure.</span>
<a name="l03399"></a>03399 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code is returned.</span>
<a name="l03400"></a>03400 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03401"></a>03401 <span class="comment"> */</span>
<a name="l03402"></a>03402 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g57c6c3e051b4c39dc2f320adbb27df9d" title="Return information about a file represented by a path.">mprGetPathInfo</a>(MprCtx ctx, cchar *path, MprPath *info);
<a name="l03403"></a>03403 <span class="comment"></span>
<a name="l03404"></a>03404 <span class="comment">/**</span>
<a name="l03405"></a>03405 <span class="comment"> *  Get the parent directory of a path</span>
<a name="l03406"></a>03406 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03407"></a>03407 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03408"></a>03408 <span class="comment"> *  @returns An allocated string containing the parent directory. Caller must free using #mprFree.</span>
<a name="l03409"></a>03409 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03410"></a>03410 <span class="comment"> */</span>
<a name="l03411"></a>03411 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g962d4a24986091501b0db73e3d55d2b2" title="Get the parent directory of a path.">mprGetPathParent</a>(MprCtx ctx, cchar *path);
<a name="l03412"></a>03412 <span class="comment"></span>
<a name="l03413"></a>03413 <span class="comment">/**</span>
<a name="l03414"></a>03414 <span class="comment"> *  Get the path directory separator.</span>
<a name="l03415"></a>03415 <span class="comment"> *  Return the directory separator characters used to separate directories on a given file system. Typically "/" or "\"</span>
<a name="l03416"></a>03416 <span class="comment"> *      The first entry is the default separator.</span>
<a name="l03417"></a>03417 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03418"></a>03418 <span class="comment"> *  @param path Use this path to specify either the root of the file system or a file on the file system.</span>
<a name="l03419"></a>03419 <span class="comment"> *  @returns The string of path separators. The first entry is the default separator.</span>
<a name="l03420"></a>03420 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03421"></a>03421 <span class="comment"> */</span>
<a name="l03422"></a>03422 <span class="keyword">extern</span> cchar *<a class="code" href="group___mpr_path.html#g15dd176c544a6d52fa77c32cec9ab45d" title="Get the path directory separator.">mprGetPathSeparators</a>(MprCtx ctx, cchar *path);
<a name="l03423"></a>03423 <span class="comment"></span>
<a name="l03424"></a>03424 <span class="comment">/**</span>
<a name="l03425"></a>03425 <span class="comment"> *  Get the file newline character string for a given path.</span>
<a name="l03426"></a>03426 <span class="comment"> *  Return the character string used to delimit new lines in text files.</span>
<a name="l03427"></a>03427 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03428"></a>03428 <span class="comment"> *  @param path Use this path to specify either the root of the file system or a file on the file system.</span>
<a name="l03429"></a>03429 <span class="comment"> *  @returns A string used to delimit new lines. This is typically "\n" or "\r\n"</span>
<a name="l03430"></a>03430 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03431"></a>03431 <span class="comment"> */</span>
<a name="l03432"></a>03432 <span class="keyword">extern</span> cchar *<a class="code" href="group___mpr_path.html#g85a7b4f2de356310207f30d416e4b64e" title="Get the file newline character string for a given path.">mprGetPathNewline</a>(MprCtx ctx, cchar *path);
<a name="l03433"></a>03433 <span class="comment"></span>
<a name="l03434"></a>03434 <span class="comment">/**</span>
<a name="l03435"></a>03435 <span class="comment"> *  Get a portable path </span>
<a name="l03436"></a>03436 <span class="comment"> *  @description Get an equivalent absolute path that is somewhat portable. </span>
<a name="l03437"></a>03437 <span class="comment"> *      This means it will use forward slashes ("/") as the directory separator.</span>
<a name="l03438"></a>03438 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03439"></a>03439 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03440"></a>03440 <span class="comment"> *  @returns An allocated string containing the new path. Caller must free using #mprFree.</span>
<a name="l03441"></a>03441 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03442"></a>03442 <span class="comment"> */</span>
<a name="l03443"></a>03443 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g8679aa877fd97feb7173442aab53b308" title="Get a portable path.">mprGetPortablePath</a>(MprCtx ctx, cchar *path);
<a name="l03444"></a>03444 <span class="comment"></span>
<a name="l03445"></a>03445 <span class="comment">/**</span>
<a name="l03446"></a>03446 <span class="comment"> *  Get a relative path</span>
<a name="l03447"></a>03447 <span class="comment"> *  @description Get an equivalent path that is relative to the application's current working directory.</span>
<a name="l03448"></a>03448 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03449"></a>03449 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03450"></a>03450 <span class="comment"> *  @returns An allocated string containing the relative directory. Caller must free using #mprFree.</span>
<a name="l03451"></a>03451 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03452"></a>03452 <span class="comment"> */</span>
<a name="l03453"></a>03453 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g947673b01c05ec0b68cdebb4159bddee" title="Get a relative path.">mprGetRelPath</a>(MprCtx ctx, cchar *path);
<a name="l03454"></a>03454 <span class="comment"></span>
<a name="l03455"></a>03455 <span class="comment">/**</span>
<a name="l03456"></a>03456 <span class="comment"> *  Make a temporary file.</span>
<a name="l03457"></a>03457 <span class="comment"> *  @description Thread-safe way to make a unique temporary file. </span>
<a name="l03458"></a>03458 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03459"></a>03459 <span class="comment"> *  @param tmpDir Base directory in which the temp file will be allocated.</span>
<a name="l03460"></a>03460 <span class="comment"> *  @return An allocated string containing the path of the temp file.</span>
<a name="l03461"></a>03461 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03462"></a>03462 <span class="comment"> */</span>
<a name="l03463"></a>03463 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g5539f40a5da3f48b5b2db3ea90e28221" title="Make a temporary file.">mprGetTempPath</a>(MprCtx ctx, cchar *tmpDir);
<a name="l03464"></a>03464 
<a name="l03465"></a>03465 <span class="comment">/*</span>
<a name="l03466"></a>03466 <span class="comment"> *  Flags for mprGetTransformedPath</span>
<a name="l03467"></a>03467 <span class="comment"> */</span>
<a name="l03468"></a>03468 <span class="preprocessor">#define MPR_PATH_ABS            0x1     </span><span class="comment">/* Normalize to an absolute path */</span>
<a name="l03469"></a>03469 <span class="preprocessor">#define MPR_PATH_REL            0x2     </span><span class="comment">/* Normalize to an relative path */</span>
<a name="l03470"></a>03470 <span class="preprocessor">#define MPR_PATH_CYGWIN         0x4     </span><span class="comment">/* Normalize to a cygwin path */</span>
<a name="l03471"></a>03471 <span class="preprocessor">#define MPR_PATH_NATIVE_SEP     0x8     </span><span class="comment">/* Use native path separators */</span>
<a name="l03472"></a>03472 <span class="comment"></span>
<a name="l03473"></a>03473 <span class="comment">/**</span>
<a name="l03474"></a>03474 <span class="comment"> *  Transform a path</span>
<a name="l03475"></a>03475 <span class="comment"> *  @description A path is transformed by cleaning and then transforming according to the flags.</span>
<a name="l03476"></a>03476 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03477"></a>03477 <span class="comment"> *  @param path First path to compare</span>
<a name="l03478"></a>03478 <span class="comment"> *  @param flags Flags to modify the path representation.</span>
<a name="l03479"></a>03479 <span class="comment"> *  @returns A newly allocated, clean path. Caller should free via #mprFree</span>
<a name="l03480"></a>03480 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03481"></a>03481 <span class="comment"> */</span>
<a name="l03482"></a>03482 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#gadb495c2337079742752f4e8e572d975" title="Transform a path.">mprGetTransformedPath</a>(MprCtx ctx, cchar *path, <span class="keywordtype">int</span> flags);
<a name="l03483"></a>03483 <span class="comment"></span>
<a name="l03484"></a>03484 <span class="comment">/**</span>
<a name="l03485"></a>03485 <span class="comment"> *  Determine if a path is absolute</span>
<a name="l03486"></a>03486 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03487"></a>03487 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03488"></a>03488 <span class="comment"> *  @returns True if the path is absolue</span>
<a name="l03489"></a>03489 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03490"></a>03490 <span class="comment"> */</span> 
<a name="l03491"></a>03491 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_path.html#g081cac7e87fa8a3800d0cdd3112d5c08" title="Determine if a path is absolute.">mprIsAbsPath</a>(MprCtx ctx, cchar *path);
<a name="l03492"></a>03492 <span class="comment"></span>
<a name="l03493"></a>03493 <span class="comment">/**</span>
<a name="l03494"></a>03494 <span class="comment"> *  Determine if a path is relative</span>
<a name="l03495"></a>03495 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03496"></a>03496 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03497"></a>03497 <span class="comment"> *  @returns True if the path is relative</span>
<a name="l03498"></a>03498 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03499"></a>03499 <span class="comment"> */</span> 
<a name="l03500"></a>03500 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_path.html#ge2e81ff8178627822dcac584dc719326" title="Determine if a path is relative.">mprIsRelPath</a>(MprCtx ctx, cchar *path);
<a name="l03501"></a>03501 <span class="comment"></span>
<a name="l03502"></a>03502 <span class="comment">/**</span>
<a name="l03503"></a>03503 <span class="comment"> *  Join paths</span>
<a name="l03504"></a>03504 <span class="comment"> *  @description Resolve one path relative to another</span>
<a name="l03505"></a>03505 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03506"></a>03506 <span class="comment"> *  @param dir Directory path name to test use as the base/dir.</span>
<a name="l03507"></a>03507 <span class="comment"> *  @param other Other path name to resolve against path.</span>
<a name="l03508"></a>03508 <span class="comment"> *  @returns Allocated string containing the resolved path.</span>
<a name="l03509"></a>03509 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03510"></a>03510 <span class="comment"> */</span>
<a name="l03511"></a>03511 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g4d312924fd21c6cb9067857a0225782f" title="Join paths.">mprJoinPath</a>(MprCtx ctx, cchar *dir, cchar *other);
<a name="l03512"></a>03512 <span class="comment"></span>
<a name="l03513"></a>03513 <span class="comment">/**</span>
<a name="l03514"></a>03514 <span class="comment"> *  Join an extension to a path</span>
<a name="l03515"></a>03515 <span class="comment"> *  @description Add an extension to a path if it does not already have one.</span>
<a name="l03516"></a>03516 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03517"></a>03517 <span class="comment"> *  @param dir Directory path name to test use as the base/dir.</span>
<a name="l03518"></a>03518 <span class="comment"> *  @param ext Extension to add. Must have period prefix.</span>
<a name="l03519"></a>03519 <span class="comment"> *  @returns Allocated string containing the resolved path.</span>
<a name="l03520"></a>03520 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03521"></a>03521 <span class="comment"> */</span>
<a name="l03522"></a>03522 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g4ef9ac6d0d8789279fef742255d56879" title="Join an extension to a path.">mprJoinPathExt</a>(MprCtx ctx, cchar *dir, cchar *ext);
<a name="l03523"></a>03523 <span class="comment"></span>
<a name="l03524"></a>03524 <span class="comment">/**</span>
<a name="l03525"></a>03525 <span class="comment"> *  Make a directory</span>
<a name="l03526"></a>03526 <span class="comment"> *  @description Make a directory using the supplied path. Intermediate directories are created as required.</span>
<a name="l03527"></a>03527 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03528"></a>03528 <span class="comment"> *  @param path String containing the directory pathname to create.</span>
<a name="l03529"></a>03529 <span class="comment"> *  @param makeMissing If true make all required intervening directory segments.</span>
<a name="l03530"></a>03530 <span class="comment"> *  @param perms Posix style file permissions mask.</span>
<a name="l03531"></a>03531 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code is returned.</span>
<a name="l03532"></a>03532 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03533"></a>03533 <span class="comment"> */</span>
<a name="l03534"></a>03534 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g3b396266e71364659d4d0fe25c41c052" title="Make a directory.">mprMakeDir</a>(MprCtx ctx, cchar *path, <span class="keywordtype">int</span> perms, <span class="keywordtype">bool</span> makeMissing);
<a name="l03535"></a>03535 <span class="comment"></span>
<a name="l03536"></a>03536 <span class="comment">/**</span>
<a name="l03537"></a>03537 <span class="comment"> *  Normalize a path</span>
<a name="l03538"></a>03538 <span class="comment"> *  @description A path is normalized by redundant segments such as "./" and "../dir" and duplicate </span>
<a name="l03539"></a>03539 <span class="comment"> *      path separators. Path separators are mapped. Paths are not converted to absolute paths.</span>
<a name="l03540"></a>03540 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03541"></a>03541 <span class="comment"> *  @param path First path to compare</span>
<a name="l03542"></a>03542 <span class="comment"> *  @returns A newly allocated, clean path. Caller should free via #mprFree</span>
<a name="l03543"></a>03543 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03544"></a>03544 <span class="comment"> */</span>
<a name="l03545"></a>03545 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g94ae6e9571d7089105a11a38b758d808" title="Normalize a path.">mprGetNormalizedPath</a>(MprCtx ctx, cchar *path);
<a name="l03546"></a>03546 <span class="comment"></span>
<a name="l03547"></a>03547 <span class="comment">/**</span>
<a name="l03548"></a>03548 <span class="comment"> *  Map the separators in a path.</span>
<a name="l03549"></a>03549 <span class="comment"> *  @description Map the directory separators in a path to the specified separators. This is useful to change from</span>
<a name="l03550"></a>03550 <span class="comment"> *      backward to forward slashes when dealing with Windows paths.</span>
<a name="l03551"></a>03551 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03552"></a>03552 <span class="comment"> *  @param path Path name to examine</span>
<a name="l03553"></a>03553 <span class="comment"> *  @param separator Separator character to use.</span>
<a name="l03554"></a>03554 <span class="comment"> *  @returns An allocated string containing the parent directory. Caller must free using #mprFree.</span>
<a name="l03555"></a>03555 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03556"></a>03556 <span class="comment"> */</span>
<a name="l03557"></a>03557 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_path.html#g6f84759fa62171fd5ff1dae1bff70e08" title="Map the separators in a path.">mprMapSeparators</a>(MprCtx ctx, <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> separator);
<a name="l03558"></a>03558 <span class="comment"></span>
<a name="l03559"></a>03559 <span class="comment">/**</span>
<a name="l03560"></a>03560 <span class="comment"> *  Determine if a file exists for a path name and can be accessed</span>
<a name="l03561"></a>03561 <span class="comment"> *  @description Test if a file can be accessed for a given mode</span>
<a name="l03562"></a>03562 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03563"></a>03563 <span class="comment"> *  @param path Path name to test</span>
<a name="l03564"></a>03564 <span class="comment"> *  @param omode Posix style file open mode mask. See #mprOpen for the various modes.</span>
<a name="l03565"></a>03565 <span class="comment"> *  @returns True if the file exists and can be accessed</span>
<a name="l03566"></a>03566 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03567"></a>03567 <span class="comment"> */</span>
<a name="l03568"></a>03568 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_path.html#gbdd09f63c16165c91f22a479d29c6ffe" title="Determine if a file exists for a path name and can be accessed.">mprPathExists</a>(MprCtx ctx, cchar *path, <span class="keywordtype">int</span> omode);
<a name="l03569"></a>03569 <span class="comment"></span>
<a name="l03570"></a>03570 <span class="comment">/**</span>
<a name="l03571"></a>03571 <span class="comment"> *  Resolve paths</span>
<a name="l03572"></a>03572 <span class="comment"> *  @description Resolve one path relative to another. If the other path is absolute, it is returned. Otherwise</span>
<a name="l03573"></a>03573 <span class="comment"> *      it is resolved relative to the directory containing the first path.</span>
<a name="l03574"></a>03574 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03575"></a>03575 <span class="comment"> *  @param path Path name to test use as the base.</span>
<a name="l03576"></a>03576 <span class="comment"> *  @param other Other path name to resolve against path.</span>
<a name="l03577"></a>03577 <span class="comment"> *  @returns Allocated string containing the resolved path.</span>
<a name="l03578"></a>03578 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03579"></a>03579 <span class="comment"> */</span>
<a name="l03580"></a>03580 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g413a694581512471730fcc80c2b5338a" title="Resolve paths.">mprResolvePath</a>(MprCtx ctx, cchar *path, cchar *other);
<a name="l03581"></a>03581 <span class="comment"></span>
<a name="l03582"></a>03582 <span class="comment">/**</span>
<a name="l03583"></a>03583 <span class="comment"> *  Compare two paths if they are the same</span>
<a name="l03584"></a>03584 <span class="comment"> *  @description Compare two paths to see if they are equal. This normalizes the paths to absolute paths first before</span>
<a name="l03585"></a>03585 <span class="comment">        comparing. It does handle case sensitivity appropriately.</span>
<a name="l03586"></a>03586 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03587"></a>03587 <span class="comment"> *  @param path1 First path to compare</span>
<a name="l03588"></a>03588 <span class="comment"> *  @param path2 Second path to compare</span>
<a name="l03589"></a>03589 <span class="comment"> *  @returns True if the file exists and can be accessed</span>
<a name="l03590"></a>03590 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03591"></a>03591 <span class="comment"> */</span>
<a name="l03592"></a>03592 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g1fe179d2b59869522057af90f9d0e28e" title="Compare two paths if they are the same.">mprSamePath</a>(MprCtx ctx, cchar *path1, cchar *path2);
<a name="l03593"></a>03593 <span class="comment"></span>
<a name="l03594"></a>03594 <span class="comment">/**</span>
<a name="l03595"></a>03595 <span class="comment"> *  Compare two paths if they are the same for a given length.</span>
<a name="l03596"></a>03596 <span class="comment"> *  @description Compare two paths to see if they are equal. This normalizes the paths to absolute paths first before</span>
<a name="l03597"></a>03597 <span class="comment">        comparing. It does handle case sensitivity appropriately. The len parameter </span>
<a name="l03598"></a>03598 <span class="comment"> *      if non-zero, specifies how many characters of the paths to compare.</span>
<a name="l03599"></a>03599 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03600"></a>03600 <span class="comment"> *  @param path1 First path to compare</span>
<a name="l03601"></a>03601 <span class="comment"> *  @param path2 Second path to compare</span>
<a name="l03602"></a>03602 <span class="comment"> *  @param len How many characters to compare.</span>
<a name="l03603"></a>03603 <span class="comment"> *  @returns True if the file exists and can be accessed</span>
<a name="l03604"></a>03604 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03605"></a>03605 <span class="comment"> */</span>
<a name="l03606"></a>03606 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g00858c33bad20e8a653f74078fcc4a6e" title="Compare two paths if they are the same for a given length.">mprSamePathCount</a>(MprCtx ctx, cchar *path1, cchar *path2, <span class="keywordtype">int</span> len);
<a name="l03607"></a>03607 
<a name="l03608"></a>03608 <span class="comment">/*</span>
<a name="l03609"></a>03609 <span class="comment"> *  Flags for mprSearchForFile</span>
<a name="l03610"></a>03610 <span class="comment"> */</span>
<a name="l03611"></a>03611 <span class="preprocessor">#define MPR_SEARCH_EXE      0x1         </span><span class="comment">/* Search for an executable */</span>
<a name="l03612"></a>03612 
<a name="l03613"></a>03613 <span class="comment">/*</span>
<a name="l03614"></a>03614 <span class="comment"> *  Search path separator</span>
<a name="l03615"></a>03615 <span class="comment"> */</span>
<a name="l03616"></a>03616 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l03617"></a>03617 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SEARCH_SEP      ";"</span>
<a name="l03618"></a>03618 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SEARCH_SEP_CHAR ';'</span>
<a name="l03619"></a>03619 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l03620"></a>03620 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SEARCH_SEP      ":"</span>
<a name="l03621"></a>03621 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_SEARCH_SEP_CHAR ':'</span>
<a name="l03622"></a>03622 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03623"></a>03623 <span class="preprocessor"></span><span class="comment"></span>
<a name="l03624"></a>03624 <span class="comment">/**</span>
<a name="l03625"></a>03625 <span class="comment"> *  Search for a path</span>
<a name="l03626"></a>03626 <span class="comment"> *  @description Search for a file using a given set of search directories</span>
<a name="l03627"></a>03627 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03628"></a>03628 <span class="comment"> *  @param path Path name to locate. Must be an existing file or directory.</span>
<a name="l03629"></a>03629 <span class="comment"> *  @param flags Flags.</span>
<a name="l03630"></a>03630 <span class="comment"> *  @param search Variable number of directories to search.</span>
<a name="l03631"></a>03631 <span class="comment"> *  @returns Allocated string containing the full path name of the located file.</span>
<a name="l03632"></a>03632 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03633"></a>03633 <span class="comment"> */</span>
<a name="l03634"></a>03634 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#g158aef4d8a9c0162832198421198f6e8" title="Search for a path.">mprSearchPath</a>(MprCtx ctx, cchar *path, <span class="keywordtype">int</span> flags, cchar *search, ...);
<a name="l03635"></a>03635 <span class="comment"></span>
<a name="l03636"></a>03636 <span class="comment">/**</span>
<a name="l03637"></a>03637 <span class="comment"> *  Truncate a path</span>
<a name="l03638"></a>03638 <span class="comment"> *  @description Truncate a file to a given size</span>
<a name="l03639"></a>03639 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03640"></a>03640 <span class="comment"> *  @param path First path to compare</span>
<a name="l03641"></a>03641 <span class="comment"> *  @param size New maximum size for the file.</span>
<a name="l03642"></a>03642 <span class="comment"> *  @returns Zero if successful.</span>
<a name="l03643"></a>03643 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03644"></a>03644 <span class="comment"> */</span>
<a name="l03645"></a>03645 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_path.html#g5d652358240a8e968114cfa718b420ab" title="Truncate a path.">mprTruncatePath</a>(MprCtx ctx, cchar *path, <span class="keywordtype">int</span> size);
<a name="l03646"></a>03646 <span class="comment"></span>
<a name="l03647"></a>03647 <span class="comment">/**</span>
<a name="l03648"></a>03648 <span class="comment"> *  Trim an extension from a path</span>
<a name="l03649"></a>03649 <span class="comment"> *  @description Trim a file extension (".ext") from a path name.</span>
<a name="l03650"></a>03650 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03651"></a>03651 <span class="comment"> *  @param path First path to compare</span>
<a name="l03652"></a>03652 <span class="comment"> *  @returns An allocated string with the trimmed path.</span>
<a name="l03653"></a>03653 <span class="comment"> *  @ingroup MprPath</span>
<a name="l03654"></a>03654 <span class="comment"> */</span>
<a name="l03655"></a>03655 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_path.html#gb8e93fa1d44e924d6bb6845c86d5607d" title="Trim an extension from a path.">mprTrimPathExtension</a>(MprCtx ctx, cchar *path);
<a name="l03656"></a>03656 
<a name="l03657"></a>03657 
<a name="l03658"></a>03658 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprOsService {
<a name="l03659"></a>03659     <span class="keywordtype">int</span>             dummy;
<a name="l03660"></a>03660 } MprOsService;
<a name="l03661"></a>03661 
<a name="l03662"></a>03662 <span class="keyword">extern</span> MprOsService *mprCreateOsService(MprCtx ctx);
<a name="l03663"></a>03663 <span class="keyword">extern</span> <span class="keywordtype">int</span>          mprStartOsService(MprOsService *os);
<a name="l03664"></a>03664 <span class="keyword">extern</span> <span class="keywordtype">void</span>         mprStopOsService(MprOsService *os);
<a name="l03665"></a>03665 
<a name="l03666"></a>03666 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprModuleService {
<a name="l03667"></a>03667     MprList         *modules;
<a name="l03668"></a>03668     <span class="keywordtype">char</span>            *searchPath;
<a name="l03669"></a>03669 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l03670"></a>03670 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *mutex;
<a name="l03671"></a>03671 <span class="preprocessor">#endif</span>
<a name="l03672"></a>03672 <span class="preprocessor"></span>} MprModuleService;
<a name="l03673"></a>03673 
<a name="l03674"></a>03674 
<a name="l03675"></a>03675 <span class="keyword">extern</span> MprModuleService *mprCreateModuleService(MprCtx ctx);
<a name="l03676"></a>03676 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprStartModuleService(MprModuleService *os);
<a name="l03677"></a>03677 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprStopModuleService(MprModuleService *os);
<a name="l03678"></a>03678 <span class="comment"></span>
<a name="l03679"></a>03679 <span class="comment">/**</span>
<a name="l03680"></a>03680 <span class="comment"> *  Module start/stop point function signature</span>
<a name="l03681"></a>03681 <span class="comment"> *  @param mp Module object reference returned from #mprCreateModule</span>
<a name="l03682"></a>03682 <span class="comment"> *  @returns zero if successful, otherwise return a negative MPR error code.</span>
<a name="l03683"></a>03683 <span class="comment"> */</span> 
<a name="l03684"></a><a class="code" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb">03684</a> <span class="keyword">typedef</span> int (*<a class="code" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb" title="Module start/stop point function signature.">MprModuleProc</a>)(<span class="keyword">struct </span>MprModule *mp);
<a name="l03685"></a>03685 <span class="comment"></span>
<a name="l03686"></a>03686 <span class="comment">/**</span>
<a name="l03687"></a>03687 <span class="comment"> *  Loadable Module Service</span>
<a name="l03688"></a>03688 <span class="comment"> *  @description The MPR provides services to load and unload shared libraries.</span>
<a name="l03689"></a>03689 <span class="comment"> *  @see MprModule, mprGetModuleSearchPath, mprSetModuleSearchPath, mprLoadModule, mprUnloadModule, </span>
<a name="l03690"></a>03690 <span class="comment"> *      mprCreateModule, mprLookupModule, MprModuleProc</span>
<a name="l03691"></a>03691 <span class="comment"> *  @stability Evolving.</span>
<a name="l03692"></a>03692 <span class="comment"> *  @defgroup MprModule MprModule</span>
<a name="l03693"></a>03693 <span class="comment"> */</span>
<a name="l03694"></a>03694 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprModule {
<a name="l03695"></a>03695     <span class="keywordtype">char</span>            *name;              <span class="comment">/**&lt; Unique module name */</span>
<a name="l03696"></a>03696     <span class="keywordtype">void</span>            *moduleData;        <span class="comment">/**&lt; Module specific data */</span>
<a name="l03697"></a>03697     <span class="keywordtype">void</span>            *handle;            <span class="comment">/**&lt; O/S shared library load handle */</span>
<a name="l03698"></a>03698     <a class="code" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb" title="Module start/stop point function signature.">MprModuleProc</a>   start;              <span class="comment">/**&lt; Start the module service */</span>
<a name="l03699"></a>03699     <a class="code" href="mpr_8h.html#1d9d70fd98eb69a8c870f2202bee22eb" title="Module start/stop point function signature.">MprModuleProc</a>   stop;               <span class="comment">/**&lt; Stop the module service */</span>
<a name="l03700"></a>03700 } MprModule;
<a name="l03701"></a>03701 <span class="comment"></span>
<a name="l03702"></a>03702 <span class="comment">/**</span>
<a name="l03703"></a>03703 <span class="comment"> *  Loadable module entry point signature. </span>
<a name="l03704"></a>03704 <span class="comment"> *  @description Loadable modules can have an entry point that is invoked automatically when a module is loaded. </span>
<a name="l03705"></a>03705 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03706"></a>03706 <span class="comment"> *  @param data Data passed to mprCreateModule</span>
<a name="l03707"></a>03707 <span class="comment"> *  @return a new MprModule structure for the module. Return NULL if the module can't be initialized.</span>
<a name="l03708"></a>03708 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03709"></a>03709 <span class="comment"> */</span>
<a name="l03710"></a><a class="code" href="group___mpr_module.html#g12f3bd6503c42b00ef185eb5a7b3073f">03710</a> <span class="keyword">typedef</span> int (*<a class="code" href="group___mpr_module.html#g12f3bd6503c42b00ef185eb5a7b3073f" title="Loadable module entry point signature.">MprModuleEntry</a>)(MprCtx ctx, <span class="keywordtype">void</span> *data);
<a name="l03711"></a>03711 <span class="comment"></span>
<a name="l03712"></a>03712 <span class="comment">/**</span>
<a name="l03713"></a>03713 <span class="comment"> *  Get the module search path</span>
<a name="l03714"></a>03714 <span class="comment"> *  @description Get the directory search path used by the MPR when loading dynamic modules. This is a colon separated (or </span>
<a name="l03715"></a>03715 <span class="comment"> *      semicolon on Windows) set of directories.</span>
<a name="l03716"></a>03716 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03717"></a>03717 <span class="comment"> *  @returns The module search path. Caller must not free.</span>
<a name="l03718"></a>03718 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03719"></a>03719 <span class="comment"> */</span>
<a name="l03720"></a>03720 <span class="keyword">extern</span> cchar *<a class="code" href="group___mpr_module.html#g33859b7b158056a95d73f106f76fe7fb" title="Get the module search path.">mprGetModuleSearchPath</a>(MprCtx ctx);
<a name="l03721"></a>03721 <span class="comment"></span>
<a name="l03722"></a>03722 <span class="comment">/**</span>
<a name="l03723"></a>03723 <span class="comment"> *  Set the module search path</span>
<a name="l03724"></a>03724 <span class="comment"> *  @description Set the directory search path used by the MPR when loading dynamic modules. This path string must</span>
<a name="l03725"></a>03725 <span class="comment"> *      should be a colon separated (or semicolon on Windows) set of directories. </span>
<a name="l03726"></a>03726 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03727"></a>03727 <span class="comment"> *  @param searchPath Colon separated set of directories</span>
<a name="l03728"></a>03728 <span class="comment"> *  @returns The module search path. Caller must not free.</span>
<a name="l03729"></a>03729 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03730"></a>03730 <span class="comment"> */</span>
<a name="l03731"></a>03731 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_module.html#g166fe35db17d76f46a260c4ecf72c438" title="Set the module search path.">mprSetModuleSearchPath</a>(MprCtx ctx, <span class="keywordtype">char</span> *searchPath);
<a name="l03732"></a>03732 <span class="comment"></span>
<a name="l03733"></a>03733 <span class="comment">/**</span>
<a name="l03734"></a>03734 <span class="comment"> *  Create a module</span>
<a name="l03735"></a>03735 <span class="comment"> *  @description This call will create a module object for a loadable module. This should be invoked by the </span>
<a name="l03736"></a>03736 <span class="comment"> *      module itself in its module entry point to register itself with the MPR.</span>
<a name="l03737"></a>03737 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03738"></a>03738 <span class="comment"> *  @param name Name of the module</span>
<a name="l03739"></a>03739 <span class="comment"> *  @param data to associate with this module</span>
<a name="l03740"></a>03740 <span class="comment"> *  @returns A module object for this module</span>
<a name="l03741"></a>03741 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03742"></a>03742 <span class="comment"> */</span>
<a name="l03743"></a>03743 <span class="keyword">extern</span> MprModule *<a class="code" href="group___mpr_module.html#g63bd240ada3d4cb53ead7b4404fd5014" title="Create a module.">mprCreateModule</a>(MprCtx ctx, cchar *name, <span class="keywordtype">void</span> *data);
<a name="l03744"></a>03744 <span class="comment"></span>
<a name="l03745"></a>03745 <span class="comment">/**</span>
<a name="l03746"></a>03746 <span class="comment"> *  Load a module</span>
<a name="l03747"></a>03747 <span class="comment"> *  @description Load a module into the MPR. This will load a dynamic shared object (shared library) and call the</span>
<a name="l03748"></a>03748 <span class="comment"> *      modules entry point. If the module has already been loaded, it this call will do nothing and will just</span>
<a name="l03749"></a>03749 <span class="comment"> *      return the already defined module object. </span>
<a name="l03750"></a>03750 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03751"></a>03751 <span class="comment"> *  @param name Name of the module to load. The module will be searched using the defined module search path </span>
<a name="l03752"></a>03752 <span class="comment"> *      (see #mprSetModuleSearchPath). The filename may or may not include a platform specific shared library extension such</span>
<a name="l03753"></a>03753 <span class="comment"> *      as .dll, .so or .dylib. By omitting the library extension, code can portably load shared libraries.</span>
<a name="l03754"></a>03754 <span class="comment"> *  @param entryPoint Name of function to invoke after loading the module.</span>
<a name="l03755"></a>03755 <span class="comment"> *  @param data Arbitrary data pointer. This will be defined in MprModule.data and passed into the module initialization</span>
<a name="l03756"></a>03756 <span class="comment"> *      entry point.</span>
<a name="l03757"></a>03757 <span class="comment"> *  @returns A module object for this module created in the module entry point by calling #mprCreateModule</span>
<a name="l03758"></a>03758 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03759"></a>03759 <span class="comment"> */</span>
<a name="l03760"></a>03760 <span class="keyword">extern</span> MprModule *<a class="code" href="group___mpr_module.html#g62c9cd99f99d97a0ee2cecfe6bc4cd06" title="Load a module.">mprLoadModule</a>(MprCtx ctx, cchar *name, cchar *entryPoint, <span class="keywordtype">void</span> *data);
<a name="l03761"></a>03761 <span class="comment"></span>
<a name="l03762"></a>03762 <span class="comment">/**</span>
<a name="l03763"></a>03763 <span class="comment"> *  Search for a module on the current module path</span>
<a name="l03764"></a>03764 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03765"></a>03765 <span class="comment"> *  @param module Name of the module to locate.</span>
<a name="l03766"></a>03766 <span class="comment"> *  @param path Pointer to a string that will receive the module path. Caller should free.</span>
<a name="l03767"></a>03767 <span class="comment"> *  @returns 0 if the module was found and path set to the location of the module.</span>
<a name="l03768"></a>03768 <span class="comment"> */</span>
<a name="l03769"></a>03769 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#e1063b22696a3419f15470bfc8f4d68a" title="Search for a module on the current module path.">mprSearchForModule</a>(MprCtx ctx, cchar *module, <span class="keywordtype">char</span> **path);
<a name="l03770"></a>03770 <span class="comment"></span>
<a name="l03771"></a>03771 <span class="comment">/**</span>
<a name="l03772"></a>03772 <span class="comment"> *  Lookup a module</span>
<a name="l03773"></a>03773 <span class="comment"> *  @description Lookup a module by name and return the module object.</span>
<a name="l03774"></a>03774 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l03775"></a>03775 <span class="comment"> *  @param name Name of the module specified to #mprCreateModule.</span>
<a name="l03776"></a>03776 <span class="comment"> *  @returns A module object for this module created in the module entry point by calling #mprCreateModule</span>
<a name="l03777"></a>03777 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03778"></a>03778 <span class="comment"> */</span>
<a name="l03779"></a>03779 <span class="keyword">extern</span> MprModule *<a class="code" href="group___mpr_module.html#g3ffc2650baf7a3b10490450ea5defb48" title="Lookup a module.">mprLookupModule</a>(MprCtx ctx, cchar *name);
<a name="l03780"></a>03780 <span class="comment"></span>
<a name="l03781"></a>03781 <span class="comment">/**</span>
<a name="l03782"></a>03782 <span class="comment"> *  Unload a module</span>
<a name="l03783"></a>03783 <span class="comment"> *  @description Unload a module from the MPR. This will unload a dynamic shared object (shared library). This routine</span>
<a name="l03784"></a>03784 <span class="comment"> *      is not fully supported by the MPR and is often fraught with issues. A module must usually be completely inactive </span>
<a name="l03785"></a>03785 <span class="comment"> *      with no allocated memory when it is unloaded.</span>
<a name="l03786"></a>03786 <span class="comment"> *  @param mp Module object returned via #mprLookupModule</span>
<a name="l03787"></a>03787 <span class="comment"> *  @ingroup MprModule</span>
<a name="l03788"></a>03788 <span class="comment"> */</span>
<a name="l03789"></a>03789 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_module.html#g7850e66f8a93866bbf3c149a65f33172" title="Unload a module.">mprUnloadModule</a>(MprModule *mp);
<a name="l03790"></a>03790 
<a name="l03791"></a>03791 <span class="comment">/*</span>
<a name="l03792"></a>03792 <span class="comment"> *  Event flags</span>
<a name="l03793"></a>03793 <span class="comment"> */</span>
<a name="l03794"></a><a class="code" href="mpr_8h.html#207b6b4c4dd69cefc5d48e0898677ff1">03794</a> <span class="preprocessor">#define MPR_EVENT_CONTINUOUS    0x1     </span><span class="comment">/**&lt; Auto reschedule the event */</span>
<a name="l03795"></a>03795 <span class="preprocessor">#define MPR_EVENT_HAS_TIMER     0x2     </span><span class="comment">/* Event has a timer event created for it already */</span>
<a name="l03796"></a>03796 <span class="comment"></span>
<a name="l03797"></a>03797 <span class="comment">/**</span>
<a name="l03798"></a>03798 <span class="comment"> *  Event callback function</span>
<a name="l03799"></a>03799 <span class="comment"> *  @return Return non-zero if the dispatcher is deleted. Otherwise return 0</span>
<a name="l03800"></a>03800 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03801"></a>03801 <span class="comment"> */</span>
<a name="l03802"></a><a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b">03802</a> <span class="keyword">typedef</span> int (*<a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a>)(<span class="keywordtype">void</span> *data, <span class="keyword">struct </span>MprEvent *event);
<a name="l03803"></a>03803 <span class="comment"></span>
<a name="l03804"></a>03804 <span class="comment">/**</span>
<a name="l03805"></a>03805 <span class="comment"> *  Event object</span>
<a name="l03806"></a>03806 <span class="comment"> *  @description The MPR provides a powerful priority based eventing mechanism. Events are described by MprEvent objects</span>
<a name="l03807"></a>03807 <span class="comment"> *      which are created and queued via #mprCreateEvent. Each event may have a priority and may be one-shot or </span>
<a name="l03808"></a>03808 <span class="comment"> *      be continuously rescheduled according to a specified period. The event subsystem provides the basis for </span>
<a name="l03809"></a>03809 <span class="comment"> *      callback timers. </span>
<a name="l03810"></a>03810 <span class="comment"> *  @see MprEvent, </span>
<a name="l03811"></a>03811 <span class="comment"> *      mprCreateEvent, mprInitEvent, mprQueueEvent, mprCreateTimerEvent, mprRescheduleEvent, mprStopContinuousEvent, </span>
<a name="l03812"></a>03812 <span class="comment"> *      mprRestartContinuousEvent, MprEventProc, mprCreateDispatcherService, mprCreateDispatcher, mprEnableDispatcher,</span>
<a name="l03813"></a>03813 <span class="comment"> *      mprServiceEvents, mprPumpEvents</span>
<a name="l03814"></a>03814 <span class="comment"> *  @defgroup MprEvent MprEvent</span>
<a name="l03815"></a>03815 <span class="comment"> */</span>
<a name="l03816"></a>03816 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprEvent {
<a name="l03817"></a>03817     cchar               *name;          <span class="comment">/**&lt; Debug name of the event */</span>
<a name="l03818"></a>03818     <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a>        proc;           <span class="comment">/**&lt; Callback procedure */</span>
<a name="l03819"></a>03819     MprTime             timestamp;      <span class="comment">/**&lt; When was the event created */</span>
<a name="l03820"></a>03820     <span class="keywordtype">int</span>                 period;         <span class="comment">/**&lt; Reschedule period */</span>
<a name="l03821"></a>03821     <span class="keywordtype">int</span>                 flags;          <span class="comment">/**&lt; Event flags */</span>
<a name="l03822"></a>03822     MprTime             due;            <span class="comment">/**&lt; When is the event due */</span>
<a name="l03823"></a>03823     <span class="keywordtype">void</span>                *data;          <span class="comment">/**&lt; Event private data */</span>
<a name="l03824"></a>03824     <span class="keywordtype">int</span>                 fd;             <span class="comment">/**&lt; File descriptor if an I/O event */</span>
<a name="l03825"></a>03825     <span class="keywordtype">int</span>                 mask;           <span class="comment">/**&lt; I/O mask of events */</span>
<a name="l03826"></a>03826     <span class="keyword">struct </span>MprEvent     *next;          <span class="comment">/**&lt; Next event linkage */</span>
<a name="l03827"></a>03827     <span class="keyword">struct </span>MprEvent     *prev;          <span class="comment">/**&lt; Previous event linkage */</span>
<a name="l03828"></a>03828     <span class="keyword">struct </span>MprDispatcher *dispatcher;   <span class="comment">/**&lt; Event dispatcher service */</span>
<a name="l03829"></a>03829 } MprEvent;
<a name="l03830"></a>03830 
<a name="l03831"></a>03831 <span class="comment">/*</span>
<a name="l03832"></a>03832 <span class="comment"> *  Event Dispatcher</span>
<a name="l03833"></a>03833 <span class="comment"> */</span>
<a name="l03834"></a>03834 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprDispatcher {
<a name="l03835"></a>03835     cchar           *name;              <span class="comment">/**&lt; Dispatcher name / purpose */</span>
<a name="l03836"></a>03836     MprEvent        eventQ;             <span class="comment">/**&lt; Event queue */</span>
<a name="l03837"></a>03837     MprEvent        timerEvent;         <span class="comment">/**&lt; Timer event to transfer to readyQ */</span>
<a name="l03838"></a>03838     MprTime         lastEventDue;       <span class="comment">/**&lt; When the last event on this dispatcher is due */</span>
<a name="l03839"></a>03839     <span class="keywordtype">int</span>             enabled;            <span class="comment">/**&lt; Dispatcher enabled to run events */</span>
<a name="l03840"></a>03840     <span class="keyword">struct </span>MprDispatcher *next;         <span class="comment">/**&lt; Next dispatcher linkage */</span>
<a name="l03841"></a>03841     <span class="keyword">struct </span>MprDispatcher *prev;         <span class="comment">/**&lt; Previous dispatcher linkage */</span>
<a name="l03842"></a>03842     <span class="keyword">struct </span>MprDispatcher *parent;       <span class="comment">/**&lt; Queue pointer */</span>
<a name="l03843"></a>03843     <span class="keyword">struct </span>MprDispatcherService *service;
<a name="l03844"></a>03844 } MprDispatcher;
<a name="l03845"></a>03845 
<a name="l03846"></a>03846 
<a name="l03847"></a>03847 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprDispatcherService {
<a name="l03848"></a>03848     MprTime         now;                <span class="comment">/**&lt; Current notion of time for the dispatcher service */</span>
<a name="l03849"></a>03849     MprDispatcher   runQ;               <span class="comment">/**&lt; Queue of running dispatchers */</span>
<a name="l03850"></a>03850     MprDispatcher   readyQ;             <span class="comment">/**&lt; Queue of dispatchers with events ready to run */</span>
<a name="l03851"></a>03851     MprDispatcher   idleQ;              <span class="comment">/**&lt; Queue of idle dispatchers */</span>
<a name="l03852"></a>03852     MprDispatcher   *timerDispatcher;   <span class="comment">/**&lt; Queue of timer events */</span>
<a name="l03853"></a>03853     MprOsThread     serviceThread;      <span class="comment">/**&lt; Thread running the dispatcher service */</span>
<a name="l03854"></a>03854     MprList         *waiters;           <span class="comment">/**&lt; List of those waiting for event notification */</span>
<a name="l03855"></a>03855     MprTime         willAwake;          <span class="comment">/**&lt; Latest time the dispatcher service will next awaken */</span>
<a name="l03856"></a>03856     <span class="keywordtype">int</span>             waiting;            <span class="comment">/**&lt; Waiting for I/O (sleeping) */</span>
<a name="l03857"></a>03857 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l03858"></a>03858 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *mutex;             <span class="comment">/**&lt; Multi-thread sync */</span>
<a name="l03859"></a>03859 <span class="preprocessor">#endif</span>
<a name="l03860"></a>03860 <span class="preprocessor"></span>} MprDispatcherService;
<a name="l03861"></a>03861 <span class="comment"></span>
<a name="l03862"></a>03862 <span class="comment">/**</span>
<a name="l03863"></a>03863 <span class="comment"> *  Create a new event dispatcher</span>
<a name="l03864"></a>03864 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l03865"></a>03865 <span class="comment"> *  @param name Useful name for debugging</span>
<a name="l03866"></a>03866 <span class="comment"> *  @param enable If true, enable the dispatcher</span>
<a name="l03867"></a>03867 <span class="comment"> *  @returns a Dispatcher object that can manage events and be used with mprCreateEvent</span>
<a name="l03868"></a>03868 <span class="comment"> */</span>
<a name="l03869"></a>03869 <span class="keyword">extern</span> MprDispatcher *<a class="code" href="mpr_8h.html#39e6373ded494a2d3154004e58a53caa" title="Create a new event dispatcher.">mprCreateDispatcher</a>(MprCtx ctx, cchar *name, <span class="keywordtype">int</span> enable);
<a name="l03870"></a>03870 <span class="comment"></span>
<a name="l03871"></a>03871 <span class="comment">/**</span>
<a name="l03872"></a>03872 <span class="comment"> *  Get the MPR primary dispatcher</span>
<a name="l03873"></a>03873 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l03874"></a>03874 <span class="comment"> *  @returns the MPR dispatcher object</span>
<a name="l03875"></a>03875 <span class="comment"> */</span>
<a name="l03876"></a>03876 <span class="keyword">extern</span> MprDispatcher *<a class="code" href="mpr_8h.html#a3492a2cff32689b04b0989a834d7bca" title="Get the MPR primary dispatcher.">mprGetDispatcher</a>(MprCtx ctx);
<a name="l03877"></a>03877 <span class="comment"></span>
<a name="l03878"></a>03878 <span class="comment">/**</span>
<a name="l03879"></a>03879 <span class="comment"> *  Wakeup the dispatcher. </span>
<a name="l03880"></a>03880 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l03881"></a>03881 <span class="comment"> */</span>
<a name="l03882"></a>03882 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l03883"></a>03883 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#ffed14ffe657703bf2577f91e424d6f6" title="Wakeup the dispatcher.">mprWakeDispatcherService</a>(MprCtx ctx);
<a name="l03884"></a>03884 <span class="preprocessor">#else</span>
<a name="l03885"></a>03885 <span class="preprocessor"></span><span class="preprocessor">#define mprWakeDispatcherService(ctx)</span>
<a name="l03886"></a>03886 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03887"></a>03887 <span class="preprocessor"></span><span class="comment"></span>
<a name="l03888"></a>03888 <span class="comment">/**</span>
<a name="l03889"></a>03889 <span class="comment"> *  Enable a dispatcher to service events. The mprCreateDispatcher routiner creates dispatchers in the disabled state.</span>
<a name="l03890"></a>03890 <span class="comment"> *  Use mprEnableDispatcher to enable them to begin servicing events.</span>
<a name="l03891"></a>03891 <span class="comment"> *  @param dispatcher Dispatcher to enable</span>
<a name="l03892"></a>03892 <span class="comment"> */</span>
<a name="l03893"></a>03893 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#b9239642f6f3418d97c779c410a9aa91" title="Enable a dispatcher to service events.">mprEnableDispatcher</a>(MprDispatcher *dispatcher);
<a name="l03894"></a>03894 
<a name="l03895"></a>03895 <span class="comment">/*</span>
<a name="l03896"></a>03896 <span class="comment"> *  ServiceEvents parameters</span>
<a name="l03897"></a>03897 <span class="comment"> */</span>
<a name="l03898"></a><a class="code" href="mpr_8h.html#c6d5205a6c355e6e3c5cb78db9b57a7f">03898</a> <span class="preprocessor">#define MPR_SERVICE_ONE_THING   0x4         </span><span class="comment">/**&lt; Wait for one event or one I/O */</span>
<a name="l03899"></a>03899 <span class="comment"></span>
<a name="l03900"></a>03900 <span class="comment">/**</span>
<a name="l03901"></a>03901 <span class="comment"> *  Service events</span>
<a name="l03902"></a>03902 <span class="comment"> *  @description Service all dispatchers. This should only be called by one thread in the application. It must not be</span>
<a name="l03903"></a>03903 <span class="comment"> *      called by worker threads. This call will block for the given delay until an event is ready to be</span>
<a name="l03904"></a>03904 <span class="comment"> *      serviced. Flags may modify the calls behavior.</span>
<a name="l03905"></a>03905 <span class="comment"> *  @param ctx Memory context object.</span>
<a name="l03906"></a>03906 <span class="comment"> *  @param delay Time in milliseconds to block until an event occurs.</span>
<a name="l03907"></a>03907 <span class="comment"> *  @param flags If set to MPR_SERVICE_ONE_THING, this call will service at most one event. Otherwise set to zero.</span>
<a name="l03908"></a>03908 <span class="comment"> *  @returns An approximate count of the number of events serviced</span>
<a name="l03909"></a>03909 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03910"></a>03910 <span class="comment"> */</span>
<a name="l03911"></a>03911 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_event.html#gd10813ca9e8ff44df3a8116171d44246" title="Service events.">mprServiceEvents</a>(MprCtx ctx, <span class="keywordtype">int</span> delay, <span class="keywordtype">int</span> flags);
<a name="l03912"></a>03912 
<a name="l03913"></a>03913 <span class="comment">//  MOB -- fix doc</span><span class="comment"></span>
<a name="l03914"></a>03914 <span class="comment">/**</span>
<a name="l03915"></a>03915 <span class="comment"> *  Pump events</span>
<a name="l03916"></a>03916 <span class="comment"> *  @description Service all dispatchers and pump events. This routine may be called by any thread at any time. It will</span>
<a name="l03917"></a>03917 <span class="comment"> *  block for the given delay until an event is ready to be serviced. Flags may modify the calls behavior.</span>
<a name="l03918"></a>03918 <span class="comment"> *  @param ctx Memory context object</span>
<a name="l03919"></a>03919 <span class="comment"> *  @param delay Time in milliseconds to block until an event occurs.</span>
<a name="l03920"></a>03920 <span class="comment"> *  @param flags If set to MPR_SERVICE_ONE_THING, this call will service at most one event. Otherwise set to zero.</span>
<a name="l03921"></a>03921 <span class="comment"> *  @return An approximate count of the number of events executed</span>
<a name="l03922"></a>03922 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03923"></a>03923 <span class="comment"> */</span>
<a name="l03924"></a>03924 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_event.html#gba03b8d6ddac9b5e4dce96bc470e5af7" title="Pump events.">mprPumpEvents</a>(MprCtx ctx, <span class="keywordtype">int</span> delay, <span class="keywordtype">int</span> flags);
<a name="l03925"></a>03925 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprDispatchEvents(MprDispatcher *dispatcher, <span class="keywordtype">bool</span> reschedule);
<a name="l03926"></a>03926 <span class="comment"></span>
<a name="l03927"></a>03927 <span class="comment">/**</span>
<a name="l03928"></a>03928 <span class="comment"> *  Create a new event</span>
<a name="l03929"></a>03929 <span class="comment"> *  @description Create a new event for service</span>
<a name="l03930"></a>03930 <span class="comment"> *  @param dispatcher Dispatcher object created via mprCreateDispatcher</span>
<a name="l03931"></a>03931 <span class="comment"> *  @param name Debug name of the event</span>
<a name="l03932"></a>03932 <span class="comment"> *  @param period Time in milliseconds used by continuous events between firing of the event.</span>
<a name="l03933"></a>03933 <span class="comment"> *  @param proc Function to invoke when the event is run</span>
<a name="l03934"></a>03934 <span class="comment"> *  @param data Data to associate with the event and stored in event-&gt;data.</span>
<a name="l03935"></a>03935 <span class="comment"> *  @param flags Flags to modify the behavior of the event. Valid values are: MPR_EVENT_CONTINUOUS to create an </span>
<a name="l03936"></a>03936 <span class="comment"> *      event which will be automatically rescheduled accoring to the specified period.</span>
<a name="l03937"></a>03937 <span class="comment"> *  @return Returns the event object if successful.</span>
<a name="l03938"></a>03938 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03939"></a>03939 <span class="comment"> */</span>
<a name="l03940"></a>03940 <span class="keyword">extern</span> MprEvent *<a class="code" href="group___mpr_event.html#gf292a0f7982192dba8e5f7535d24377d" title="Create a new event.">mprCreateEvent</a>(MprDispatcher *dispatcher, cchar *name, <span class="keywordtype">int</span> period, <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, <span class="keywordtype">void</span> *data, 
<a name="l03941"></a>03941     <span class="keywordtype">int</span> flags);
<a name="l03942"></a>03942 
<a name="l03943"></a>03943 <span class="comment">/* Internal */</span>
<a name="l03944"></a>03944 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprRelayEvent(MprDispatcher *dispatcher, <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, <span class="keywordtype">void</span> *data, MprEvent *event);
<a name="l03945"></a>03945 <span class="comment"></span>
<a name="l03946"></a>03946 <span class="comment">/**</span>
<a name="l03947"></a>03947 <span class="comment"> *  Queue a new event for service. This is typically used if mprInitEvent is used to statically initialize an</span>
<a name="l03948"></a>03948 <span class="comment"> *  event. It is not used often as mprCreateEvent will create and queue the event.</span>
<a name="l03949"></a>03949 <span class="comment"> *  @description Queue an event for service</span>
<a name="l03950"></a>03950 <span class="comment"> *  @param dispatcher Dispatcher object created via mprCreateDispatcher</span>
<a name="l03951"></a>03951 <span class="comment"> *  @param event Event object to queue</span>
<a name="l03952"></a>03952 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03953"></a>03953 <span class="comment"> */</span>
<a name="l03954"></a>03954 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#g0a9fa25c6efe71b9f18314f79335fe2f" title="Queue a new event for service.">mprQueueEvent</a>(MprDispatcher *dispatcher, MprEvent *event);
<a name="l03955"></a>03955 <span class="comment"></span>
<a name="l03956"></a>03956 <span class="comment">/**</span>
<a name="l03957"></a>03957 <span class="comment"> *  Initialize an event</span>
<a name="l03958"></a>03958 <span class="comment"> *  @description Statically initialize an event.</span>
<a name="l03959"></a>03959 <span class="comment"> *  @param dispatcher Dispatcher object created via mprCreateDispatcher</span>
<a name="l03960"></a>03960 <span class="comment"> *  @param event Event structure to initialize</span>
<a name="l03961"></a>03961 <span class="comment"> *  @param name Debug name for the event. Should be static.</span>
<a name="l03962"></a>03962 <span class="comment"> *  @param period Time in milliseconds used by continuous events between firing of the event.</span>
<a name="l03963"></a>03963 <span class="comment"> *  @param proc Function to invoke when the event is run</span>
<a name="l03964"></a>03964 <span class="comment"> *  @param data Data to associate with the event and stored in event-&gt;data.</span>
<a name="l03965"></a>03965 <span class="comment"> *  @param flags Flags to modify the behavior of the event. Valid values are: MPR_EVENT_CONTINUOUS to create an </span>
<a name="l03966"></a>03966 <span class="comment"> *      event which will be automatically rescheduled accoring to the specified period.</span>
<a name="l03967"></a>03967 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03968"></a>03968 <span class="comment"> */</span>
<a name="l03969"></a>03969 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#gd1638be85f9f4424a91c7fff288a4f74" title="Initialize an event.">mprInitEvent</a>(MprDispatcher *dispatcher, MprEvent *event, cchar *name, <span class="keywordtype">int</span> period, <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, 
<a name="l03970"></a>03970     <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> flags);
<a name="l03971"></a>03971 <span class="comment"></span>
<a name="l03972"></a>03972 <span class="comment">/**</span>
<a name="l03973"></a>03973 <span class="comment"> *  Remove an event</span>
<a name="l03974"></a>03974 <span class="comment"> *  @description Remove a queued event. This is useful to remove continuous events from the event queue.</span>
<a name="l03975"></a>03975 <span class="comment"> *  @param event Event object returned from #mprCreateEvent</span>
<a name="l03976"></a>03976 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03977"></a>03977 <span class="comment"> */</span>
<a name="l03978"></a>03978 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#g9163bc8e37a8ff05c0c957cfcc86e02e" title="Remove an event.">mprRemoveEvent</a>(MprEvent *event);
<a name="l03979"></a>03979 <span class="comment"></span>
<a name="l03980"></a>03980 <span class="comment">/**</span>
<a name="l03981"></a>03981 <span class="comment"> *  Stop an event</span>
<a name="l03982"></a>03982 <span class="comment"> *  @description Stop a continuous event and remove from the queue. The event object is not freed, but simply removed</span>
<a name="l03983"></a>03983 <span class="comment"> *      from the event queue.</span>
<a name="l03984"></a>03984 <span class="comment"> *  @param event Event object returned from #mprCreateEvent</span>
<a name="l03985"></a>03985 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03986"></a>03986 <span class="comment"> */</span>
<a name="l03987"></a>03987 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#g1f2c85a20242ec0c1e4830ccd25c7bb7" title="Stop an event.">mprStopContinuousEvent</a>(MprEvent *event);
<a name="l03988"></a>03988 <span class="comment"></span>
<a name="l03989"></a>03989 <span class="comment">/**</span>
<a name="l03990"></a>03990 <span class="comment"> *  Restart an event</span>
<a name="l03991"></a>03991 <span class="comment"> *  @description Restart a continuous event after it has been stopped via #mprStopContinuousEvent. This call will </span>
<a name="l03992"></a>03992 <span class="comment"> *      add the event to the event queue and it will run after the configured event period has expired.</span>
<a name="l03993"></a>03993 <span class="comment"> *  @param event Event object returned from #mprCreateEvent</span>
<a name="l03994"></a>03994 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l03995"></a>03995 <span class="comment"> */</span>
<a name="l03996"></a>03996 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#g6fa51ab06c56baaad50f1b4df7efc1d4" title="Restart an event.">mprRestartContinuousEvent</a>(MprEvent *event);
<a name="l03997"></a>03997 <span class="comment"></span>
<a name="l03998"></a>03998 <span class="comment">/**</span>
<a name="l03999"></a>03999 <span class="comment"> *  Create a timer event</span>
<a name="l04000"></a>04000 <span class="comment"> *  @description Create and queue a timer event for service. This is a convenience wrapper to create continuous</span>
<a name="l04001"></a>04001 <span class="comment"> *      events over the #mprCreateEvent call.</span>
<a name="l04002"></a>04002 <span class="comment"> *  @param dispatcher Dispatcher object created via mprCreateDispatcher</span>
<a name="l04003"></a>04003 <span class="comment"> *  @param name Debug name of the event</span>
<a name="l04004"></a>04004 <span class="comment"> *  @param proc Function to invoke when the event is run</span>
<a name="l04005"></a>04005 <span class="comment"> *  @param period Time in milliseconds used by continuous events between firing of the event.</span>
<a name="l04006"></a>04006 <span class="comment"> *  @param data Data to associate with the event and stored in event-&gt;data.</span>
<a name="l04007"></a>04007 <span class="comment"> *  @param flags Not used.</span>
<a name="l04008"></a>04008 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l04009"></a>04009 <span class="comment"> */</span>
<a name="l04010"></a>04010 <span class="keyword">extern</span> MprEvent *<a class="code" href="group___mpr_event.html#g67402fd2c25d36deed940433da8350d3" title="Create a timer event.">mprCreateTimerEvent</a>(MprDispatcher *dispatcher, cchar *name, <span class="keywordtype">int</span> period, <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, <span class="keywordtype">void</span> *data, 
<a name="l04011"></a>04011     <span class="keywordtype">int</span> flags);
<a name="l04012"></a>04012 <span class="comment"></span>
<a name="l04013"></a>04013 <span class="comment">/**</span>
<a name="l04014"></a>04014 <span class="comment"> *  Reschedule an event</span>
<a name="l04015"></a>04015 <span class="comment"> *  @description Reschedule a continuous event by modifying its period.</span>
<a name="l04016"></a>04016 <span class="comment"> *  @param event Event object returned from #mprCreateEvent</span>
<a name="l04017"></a>04017 <span class="comment"> *  @param period Time in milliseconds used by continuous events between firing of the event.</span>
<a name="l04018"></a>04018 <span class="comment"> *  @ingroup MprEvent</span>
<a name="l04019"></a>04019 <span class="comment"> */</span>
<a name="l04020"></a>04020 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_event.html#gf33d646f5cdb5e2e798b22e1b941e79b" title="Reschedule an event.">mprRescheduleEvent</a>(MprEvent *event, <span class="keywordtype">int</span> period);
<a name="l04021"></a>04021 
<a name="l04022"></a>04022 <span class="comment">/* Internal API */</span>
<a name="l04023"></a>04023 <span class="keyword">extern</span> MprDispatcherService *mprCreateDispatcherService(MprCtx ctx);
<a name="l04024"></a>04024 <span class="keyword">extern</span> MprEvent *mprGetNextEvent(MprDispatcher *dispatcher);
<a name="l04025"></a>04025 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprInitEventQ(MprEvent *q);
<a name="l04026"></a>04026 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprScheduleDispatcher(MprDispatcher *dispatcher, <span class="keywordtype">int</span> period);
<a name="l04027"></a>04027 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprQueueTimerEvent(MprDispatcher *dispatcher, MprEvent *event);
<a name="l04028"></a>04028 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprQueueDispatcher(MprDispatcher *prior, MprDispatcher *dispatcher);
<a name="l04029"></a>04029 
<a name="l04030"></a>04030 <span class="preprocessor">#if BLD_FEATURE_XML</span>
<a name="l04031"></a>04031 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l04032"></a>04032 <span class="comment"> *  XML parser states. The states that are passed to the user handler have "U" appended to the comment.</span>
<a name="l04033"></a>04033 <span class="comment"> *  The error states (ERR and EOF) must be negative.</span>
<a name="l04034"></a>04034 <span class="comment"> */</span>
<a name="l04035"></a>04035 <span class="preprocessor">#define MPR_XML_ERR                 -1      </span><span class="comment">/* Error */</span>
<a name="l04036"></a>04036 <span class="preprocessor">#define MPR_XML_EOF                 -2      </span><span class="comment">/* End of input */</span>
<a name="l04037"></a>04037 <span class="preprocessor">#define MPR_XML_BEGIN               1       </span><span class="comment">/* Before next tag               */</span>
<a name="l04038"></a>04038 <span class="preprocessor">#define MPR_XML_AFTER_LS            2       </span><span class="comment">/* Seen "&lt;"                      */</span>
<a name="l04039"></a>04039 <span class="preprocessor">#define MPR_XML_COMMENT             3       </span><span class="comment">/* Seen "&lt;!--" (usr)        U    */</span>
<a name="l04040"></a>04040 <span class="preprocessor">#define MPR_XML_NEW_ELT             4       </span><span class="comment">/* Seen "&lt;tag" (usr)        U    */</span>
<a name="l04041"></a>04041 <span class="preprocessor">#define MPR_XML_ATT_NAME            5       </span><span class="comment">/* Seen "&lt;tag att"               */</span>
<a name="l04042"></a>04042 <span class="preprocessor">#define MPR_XML_ATT_EQ              6       </span><span class="comment">/* Seen "&lt;tag att" =             */</span>
<a name="l04043"></a>04043 <span class="preprocessor">#define MPR_XML_NEW_ATT             7       </span><span class="comment">/* Seen "&lt;tag att = "val"   U    */</span>
<a name="l04044"></a>04044 <span class="preprocessor">#define MPR_XML_SOLO_ELT_DEFINED    8       </span><span class="comment">/* Seen "&lt;tag../&gt;"          U    */</span>
<a name="l04045"></a>04045 <span class="preprocessor">#define MPR_XML_ELT_DEFINED         9       </span><span class="comment">/* Seen "&lt;tag...&gt;"          U    */</span>
<a name="l04046"></a>04046 <span class="preprocessor">#define MPR_XML_ELT_DATA            10      </span><span class="comment">/* Seen "&lt;tag&gt;....&lt;"        U    */</span>
<a name="l04047"></a>04047 <span class="preprocessor">#define MPR_XML_END_ELT             11      </span><span class="comment">/* Seen "&lt;tag&gt;....&lt;/tag&gt;"   U    */</span>
<a name="l04048"></a>04048 <span class="preprocessor">#define MPR_XML_PI                  12      </span><span class="comment">/* Seen "&lt;?processingInst"  U    */</span>
<a name="l04049"></a>04049 <span class="preprocessor">#define MPR_XML_CDATA               13      </span><span class="comment">/* Seen "&lt;![CDATA["         U    */</span>
<a name="l04050"></a>04050 
<a name="l04051"></a>04051 <span class="comment">/*</span>
<a name="l04052"></a>04052 <span class="comment"> *  Lex tokens</span>
<a name="l04053"></a>04053 <span class="comment"> */</span>
<a name="l04054"></a>04054 <span class="keyword">typedef</span> <span class="keyword">enum</span> MprXmlToken {
<a name="l04055"></a>04055     MPR_XMLTOK_ERR,
<a name="l04056"></a>04056     MPR_XMLTOK_TOO_BIG,                     <span class="comment">/* Token is too big */</span>
<a name="l04057"></a>04057     MPR_XMLTOK_CDATA,
<a name="l04058"></a>04058     MPR_XMLTOK_COMMENT,
<a name="l04059"></a>04059     MPR_XMLTOK_INSTRUCTIONS,
<a name="l04060"></a>04060     MPR_XMLTOK_LS,                          <span class="comment">/* "&lt;" -- Opening a tag */</span>
<a name="l04061"></a>04061     MPR_XMLTOK_LS_SLASH,                    <span class="comment">/* "&lt;/" -- Closing a tag */</span>
<a name="l04062"></a>04062     MPR_XMLTOK_GR,                          <span class="comment">/* "&gt;" -- End of an open tag */</span>
<a name="l04063"></a>04063     MPR_XMLTOK_SLASH_GR,                    <span class="comment">/* "/&gt;" -- End of a solo tag */</span>
<a name="l04064"></a>04064     MPR_XMLTOK_TEXT,
<a name="l04065"></a>04065     MPR_XMLTOK_EQ,
<a name="l04066"></a>04066     MPR_XMLTOK_EOF,
<a name="l04067"></a>04067     MPR_XMLTOK_SPACE,
<a name="l04068"></a>04068 } MprXmlToken;
<a name="l04069"></a>04069 
<a name="l04070"></a>04070 <span class="keyword">typedef</span> int (*MprXmlHandler)(<span class="keyword">struct </span>MprXml *xp, <span class="keywordtype">int</span> state, cchar *tagName, cchar* attName, cchar* value);
<a name="l04071"></a>04071 <span class="keyword">typedef</span> int (*MprXmlInputStream)(<span class="keyword">struct </span>MprXml *xp, <span class="keywordtype">void</span> *arg, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> size);
<a name="l04072"></a>04072 
<a name="l04073"></a>04073 <span class="comment">/*</span>
<a name="l04074"></a>04074 <span class="comment"> *  Per XML session structure</span>
<a name="l04075"></a>04075 <span class="comment"> */</span>
<a name="l04076"></a>04076 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprXml {
<a name="l04077"></a>04077     MprXmlHandler       handler;            <span class="comment">/* Callback function */</span>
<a name="l04078"></a>04078     MprXmlInputStream   readFn;             <span class="comment">/* Read data function */</span>
<a name="l04079"></a>04079     MprBuf              *inBuf;             <span class="comment">/* Input data queue */</span>
<a name="l04080"></a>04080     MprBuf              *tokBuf;            <span class="comment">/* Parsed token buffer */</span>
<a name="l04081"></a>04081     <span class="keywordtype">int</span>                 quoteChar;          <span class="comment">/* XdbAtt quote char */</span>
<a name="l04082"></a>04082     <span class="keywordtype">int</span>                 lineNumber;         <span class="comment">/* Current line no for debug */</span>
<a name="l04083"></a>04083     <span class="keywordtype">void</span>                *parseArg;          <span class="comment">/* Arg passed to mprXmlParse() */</span>
<a name="l04084"></a>04084     <span class="keywordtype">void</span>                *inputArg;          <span class="comment">/* Arg for mprXmlSetInputStream() */</span>
<a name="l04085"></a>04085     <span class="keywordtype">char</span>                *errMsg;            <span class="comment">/* Error message text */</span>
<a name="l04086"></a>04086 } MprXml;
<a name="l04087"></a>04087 
<a name="l04088"></a>04088 <span class="keyword">extern</span> MprXml   *mprXmlOpen(MprCtx ctx, <span class="keywordtype">int</span> initialSize, <span class="keywordtype">int</span> maxSize);
<a name="l04089"></a>04089 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprXmlSetParserHandler(MprXml *xp, MprXmlHandler h);
<a name="l04090"></a>04090 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprXmlSetInputStream(MprXml *xp, MprXmlInputStream s, <span class="keywordtype">void</span> *arg);
<a name="l04091"></a>04091 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprXmlParse(MprXml *xp);
<a name="l04092"></a>04092 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprXmlSetParseArg(MprXml *xp, <span class="keywordtype">void</span> *parseArg);
<a name="l04093"></a>04093 <span class="keyword">extern</span> <span class="keywordtype">void</span>     *mprXmlGetParseArg(MprXml *xp);
<a name="l04094"></a>04094 <span class="keyword">extern</span> cchar    *mprXmlGetErrorMsg(MprXml *xp);
<a name="l04095"></a>04095 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprXmlGetLineNumber(MprXml *xp);
<a name="l04096"></a>04096 
<a name="l04097"></a>04097 <span class="preprocessor">#endif </span><span class="comment">/* BLD_FEATURE_XML */</span>
<a name="l04098"></a>04098 
<a name="l04099"></a>04099 <span class="comment"></span>
<a name="l04100"></a>04100 <span class="comment">/**</span>
<a name="l04101"></a>04101 <span class="comment"> *  Condition variable for single and multi-thread synchronization. Condition variables can be used to coordinate </span>
<a name="l04102"></a>04102 <span class="comment"> *  activities. These variables are level triggered in that a condition can be signalled prior to another thread </span>
<a name="l04103"></a>04103 <span class="comment"> *  waiting. Condition variables can be used when single threaded but and will call mprServiceDispatcher to pump events</span>
<a name="l04104"></a>04104 <span class="comment"> *  until another callback invokes mprWaitForCond</span>
<a name="l04105"></a>04105 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04106"></a>04106 <span class="comment"> */</span>
<a name="l04107"></a><a class="code" href="struct_mpr_cond.html">04107</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> {
<a name="l04108"></a>04108 <span class="preprocessor">    #if BLD_FEATURE_MULTITHREAD</span>
<a name="l04109"></a>04109 <span class="preprocessor"></span><span class="preprocessor">        #if BLD_UNIX_LIKE</span>
<a name="l04110"></a><a class="code" href="struct_mpr_cond.html#0e6b1e38a4ba7a567b0e884aa66ff6eb">04110</a> <span class="preprocessor"></span>            pthread_cond_t <a class="code" href="struct_mpr_cond.html#0e6b1e38a4ba7a567b0e884aa66ff6eb" title="Unix pthreads condition variable.">cv</a>;      <span class="comment">/**&lt; Unix pthreads condition variable */</span>
<a name="l04111"></a>04111 <span class="preprocessor">        #elif BLD_WIN_LIKE</span>
<a name="l04112"></a>04112 <span class="preprocessor"></span>            HANDLE <a class="code" href="struct_mpr_cond.html#0e6b1e38a4ba7a567b0e884aa66ff6eb" title="Unix pthreads condition variable.">cv</a>;              <span class="comment">/* Windows event handle */</span>
<a name="l04113"></a>04113 <span class="preprocessor">        #elif VXWORKS</span>
<a name="l04114"></a>04114 <span class="preprocessor"></span>            SEM_ID <a class="code" href="struct_mpr_cond.html#0e6b1e38a4ba7a567b0e884aa66ff6eb" title="Unix pthreads condition variable.">cv</a>;              <span class="comment">/* Condition variable */</span>
<a name="l04115"></a>04115 <span class="preprocessor">        #else</span>
<a name="l04116"></a>04116 <span class="preprocessor"></span>            error(<span class="stringliteral">"Unsupported OS"</span>);
<a name="l04117"></a>04117 <span class="preprocessor">        #endif</span>
<a name="l04118"></a><a class="code" href="struct_mpr_cond.html#325e0b35b99be809f98283f414d05334">04118</a> <span class="preprocessor"></span>            <span class="keyword">struct </span><a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *<a class="code" href="struct_mpr_cond.html#325e0b35b99be809f98283f414d05334" title="Thread synchronization mutex.">mutex</a>; <span class="comment">/**&lt; Thread synchronization mutex */</span>
<a name="l04119"></a>04119 <span class="preprocessor">    #endif</span>
<a name="l04120"></a><a class="code" href="struct_mpr_cond.html#b0e7de436c89ae67052b0b59cf0d0948">04120</a> <span class="preprocessor"></span>    <span class="keyword">volatile</span> <span class="keywordtype">int</span> <a class="code" href="struct_mpr_cond.html#b0e7de436c89ae67052b0b59cf0d0948" title="Value of the condition.">triggered</a>;         <span class="comment">/**&lt; Value of the condition */</span>
<a name="l04121"></a>04121 } <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>;
<a name="l04122"></a>04122 
<a name="l04123"></a>04123 <span class="comment"></span>
<a name="l04124"></a>04124 <span class="comment">/**</span>
<a name="l04125"></a>04125 <span class="comment"> *  Create a condition lock variable.</span>
<a name="l04126"></a>04126 <span class="comment"> *  @description This call creates a condition variable object that can be used in #mprWaitForCond and #mprSignalCond calls. </span>
<a name="l04127"></a>04127 <span class="comment"> *      Use #mprFree to destroy the condition variable.</span>
<a name="l04128"></a>04128 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04129"></a>04129 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04130"></a>04130 <span class="comment"> */</span>
<a name="l04131"></a>04131 <span class="keyword">extern</span> <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> *<a class="code" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a>(MprCtx ctx);
<a name="l04132"></a>04132 <span class="comment"></span>
<a name="l04133"></a>04133 <span class="comment">/**</span>
<a name="l04134"></a>04134 <span class="comment"> *  Reset a condition variable. This sets the condition variable to the unsignalled condition.</span>
<a name="l04135"></a>04135 <span class="comment"> *  @param cond Condition variable object created via #mprCreateCond</span>
<a name="l04136"></a>04136 <span class="comment"> */</span>
<a name="l04137"></a>04137 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#3db47bdecb58c2c52197d625377cf71b" title="Reset a condition variable.">mprResetCond</a>(<a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> *cond);
<a name="l04138"></a>04138 <span class="comment"></span>
<a name="l04139"></a>04139 <span class="comment">/**</span>
<a name="l04140"></a>04140 <span class="comment"> *  Wait for a condition lock variable.</span>
<a name="l04141"></a>04141 <span class="comment"> *  @description Wait for a condition lock variable to be signaled. If the condition is signaled before the timeout</span>
<a name="l04142"></a>04142 <span class="comment"> *      expires this call will reset the condition variable and return. This way, it automatically resets the variable</span>
<a name="l04143"></a>04143 <span class="comment"> *      for future waiters.</span>
<a name="l04144"></a>04144 <span class="comment"> *  @param cond Condition variable object created via #mprCreateCond</span>
<a name="l04145"></a>04145 <span class="comment"> *  @param timeout Time in milliseconds to wait for the condition variable to be signaled.</span>
<a name="l04146"></a>04146 <span class="comment"> *  @return Zero if the event was signalled. Returns &lt; 0 for a timeout.</span>
<a name="l04147"></a>04147 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04148"></a>04148 <span class="comment"> */</span>
<a name="l04149"></a>04149 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5" title="Wait for a condition lock variable.">mprWaitForCond</a>(<a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> *cond, <span class="keywordtype">int</span> timeout);
<a name="l04150"></a>04150 <span class="comment"></span>
<a name="l04151"></a>04151 <span class="comment">/**</span>
<a name="l04152"></a>04152 <span class="comment"> *  Wait for a condition lock variable and pump events while waiting.</span>
<a name="l04153"></a>04153 <span class="comment"> *  @description Wait for a condition lock variable to be signaled. If the condition is signaled before the timeout</span>
<a name="l04154"></a>04154 <span class="comment"> *      expires this call will reset the condition variable and return. This way, it automatically resets the variable</span>
<a name="l04155"></a>04155 <span class="comment"> *      for future waiters.</span>
<a name="l04156"></a>04156 <span class="comment"> *  @param cond Condition variable object created via #mprCreateCond</span>
<a name="l04157"></a>04157 <span class="comment"> *  @param timeout Time in milliseconds to wait for the condition variable to be signaled.</span>
<a name="l04158"></a>04158 <span class="comment"> *  @return Zero if the event was signalled. Returns &lt; 0 for a timeout.</span>
<a name="l04159"></a>04159 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04160"></a>04160 <span class="comment"> */</span>
<a name="l04161"></a>04161 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_synch.html#g4ce11896445416406d85d4d7a18bac7e" title="Wait for a condition lock variable and pump events while waiting.">mprWaitForCondWithService</a>(<a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> *cond, <span class="keywordtype">int</span> timeout);
<a name="l04162"></a>04162 <span class="comment"></span>
<a name="l04163"></a>04163 <span class="comment">/**</span>
<a name="l04164"></a>04164 <span class="comment"> *  Signal a condition lock variable.</span>
<a name="l04165"></a>04165 <span class="comment">*   @description Signal a condition variable and set it to the \a triggered status. Existing or future callers of</span>
<a name="l04166"></a>04166 <span class="comment">*       #mprWaitForCond will be awakened.</span>
<a name="l04167"></a>04167 <span class="comment"> *  @param cond Condition variable object created via #mprCreateCond</span>
<a name="l04168"></a>04168 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04169"></a>04169 <span class="comment"> */</span>
<a name="l04170"></a>04170 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b" title="Signal a condition lock variable.">mprSignalCond</a>(<a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a> *cond);
<a name="l04171"></a>04171 
<a name="l04172"></a>04172 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l04173"></a>04173 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l04174"></a>04174 <span class="comment"> *  Multithreaded Synchronization Services</span>
<a name="l04175"></a>04175 <span class="comment"> *  @see MprMutex, mprCreateStaticLock, mprFree, mprLock, mprTryLock, mprUnlock, mprGlobalLock, mprGlobalUnlock, </span>
<a name="l04176"></a>04176 <span class="comment"> *      MprSpin, mprCreateSpinLock, MprCond, mprCreateCond, mprWaitForCond, mprSignalCond, mprFree</span>
<a name="l04177"></a>04177 <span class="comment"> *  @stability Evolving.</span>
<a name="l04178"></a>04178 <span class="comment"> *  @defgroup MprSynch MprSynch</span>
<a name="l04179"></a>04179 <span class="comment"> */</span>
<a name="l04180"></a>04180 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprSynch { <span class="keywordtype">int</span> dummy; } MprSynch;
<a name="l04181"></a>04181 <span class="comment"></span>
<a name="l04182"></a>04182 <span class="comment">/**</span>
<a name="l04183"></a>04183 <span class="comment"> *  Multithreading lock control structure</span>
<a name="l04184"></a>04184 <span class="comment"> *  @description MprMutex is used for multithread locking in multithreaded applications.</span>
<a name="l04185"></a>04185 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04186"></a>04186 <span class="comment"> */</span>
<a name="l04187"></a><a class="code" href="struct_mpr_mutex.html">04187</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> {
<a name="l04188"></a>04188 <span class="preprocessor">    #if BLD_WIN_LIKE</span>
<a name="l04189"></a><a class="code" href="struct_mpr_mutex.html#35a083e861b4665838b97e896360d977">04189</a> <span class="preprocessor"></span>        CRITICAL_SECTION <a class="code" href="struct_mpr_mutex.html#35a083e861b4665838b97e896360d977" title="Internal mutex critical section.">cs</a>;            <span class="comment">/**&lt; Internal mutex critical section */</span>
<a name="l04190"></a>04190 <span class="preprocessor">    #elif VXWORKS</span>
<a name="l04191"></a>04191 <span class="preprocessor"></span>        SEM_ID      <a class="code" href="struct_mpr_mutex.html#35a083e861b4665838b97e896360d977" title="Internal mutex critical section.">cs</a>;
<a name="l04192"></a>04192 <span class="preprocessor">    #elif BLD_UNIX_LIKE</span>
<a name="l04193"></a>04193 <span class="preprocessor"></span>        pthread_mutex_t  <a class="code" href="struct_mpr_mutex.html#35a083e861b4665838b97e896360d977" title="Internal mutex critical section.">cs</a>;
<a name="l04194"></a>04194 <span class="preprocessor">    #else</span>
<a name="l04195"></a>04195 <span class="preprocessor"></span>        error(<span class="stringliteral">"Unsupported OS"</span>);
<a name="l04196"></a>04196 <span class="preprocessor">    #endif</span>
<a name="l04197"></a>04197 <span class="preprocessor"></span>} <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>;
<a name="l04198"></a>04198 
<a name="l04199"></a>04199 <span class="comment"></span>
<a name="l04200"></a>04200 <span class="comment">/**</span>
<a name="l04201"></a>04201 <span class="comment"> *  Multithreading spin lock control structure</span>
<a name="l04202"></a>04202 <span class="comment"> *  @description    MprSpin is used for multithread locking in multithreaded applications.</span>
<a name="l04203"></a>04203 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04204"></a>04204 <span class="comment"> */</span>
<a name="l04205"></a><a class="code" href="struct_mpr_spin.html">04205</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> {
<a name="l04206"></a>04206 <span class="preprocessor">    #if USE_MPR_LOCK</span>
<a name="l04207"></a>04207 <span class="preprocessor"></span>        <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>            <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;
<a name="l04208"></a>04208 <span class="preprocessor">    #elif BLD_WIN_LIKE</span>
<a name="l04209"></a><a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3">04209</a> <span class="preprocessor"></span>        CRITICAL_SECTION    <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;            <span class="comment">/**&lt; Internal mutex critical section */</span>
<a name="l04210"></a>04210 <span class="preprocessor">    #elif VXWORKS</span>
<a name="l04211"></a>04211 <span class="preprocessor"></span>        SEM_ID              <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;
<a name="l04212"></a>04212 <span class="preprocessor">    #elif MACOSX</span>
<a name="l04213"></a>04213 <span class="preprocessor"></span>        OSSpinLock          <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;
<a name="l04214"></a>04214 <span class="preprocessor">    #elif BLD_UNIX_LIKE &amp;&amp; BLD_HAS_SPINLOCK</span>
<a name="l04215"></a>04215 <span class="preprocessor"></span>        pthread_spinlock_t  <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;
<a name="l04216"></a>04216 <span class="preprocessor">    #elif BLD_UNIX_LIKE</span>
<a name="l04217"></a>04217 <span class="preprocessor"></span>        pthread_mutex_t     <a class="code" href="struct_mpr_spin.html#2c64ee0b71bc7bfdcd19d9c72e6cb7e3" title="Internal mutex critical section.">cs</a>;
<a name="l04218"></a>04218 <span class="preprocessor">    #else</span>
<a name="l04219"></a>04219 <span class="preprocessor"></span>        error(<span class="stringliteral">"Unsupported OS"</span>);
<a name="l04220"></a>04220 <span class="preprocessor">    #endif</span>
<a name="l04221"></a>04221 <span class="preprocessor"></span><span class="preprocessor">    #if BLD_DEBUG</span>
<a name="l04222"></a>04222 <span class="preprocessor"></span>        MprOsThread         owner;
<a name="l04223"></a>04223 <span class="preprocessor">    #endif</span>
<a name="l04224"></a>04224 <span class="preprocessor"></span>} <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a>;
<a name="l04225"></a>04225 
<a name="l04226"></a>04226 
<a name="l04227"></a>04227 <span class="preprocessor">#define lock(arg) mprLock(arg-&gt;mutex)</span>
<a name="l04228"></a>04228 <span class="preprocessor"></span><span class="preprocessor">#define unlock(arg) mprUnlock(arg-&gt;mutex)</span>
<a name="l04229"></a>04229 <span class="preprocessor"></span><span class="preprocessor">#define spinlock(arg) mprSpinLock(arg-&gt;spin)</span>
<a name="l04230"></a>04230 <span class="preprocessor"></span><span class="preprocessor">#define spinunlock(arg) mprSpinUnlock(arg-&gt;spin)</span>
<a name="l04231"></a>04231 <span class="preprocessor"></span><span class="comment"></span>
<a name="l04232"></a>04232 <span class="comment">/**</span>
<a name="l04233"></a>04233 <span class="comment"> *  Create a Mutex lock object.</span>
<a name="l04234"></a>04234 <span class="comment"> *  @description This call creates a Mutex lock object that can be used in #mprLock, #mprTryLock and #mprUnlock calls. </span>
<a name="l04235"></a>04235 <span class="comment"> *      Use #mprFree to destroy the lock.</span>
<a name="l04236"></a>04236 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04237"></a>04237 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04238"></a>04238 <span class="comment"> */</span>
<a name="l04239"></a>04239 <span class="keyword">extern</span> <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *<a class="code" href="group___mpr_synch.html#g825387252381219bd94edfa9c60855fa" title="Create a Mutex lock object.">mprCreateLock</a>(MprCtx ctx);
<a name="l04240"></a>04240 <span class="comment"></span>
<a name="l04241"></a>04241 <span class="comment">/**</span>
<a name="l04242"></a>04242 <span class="comment"> *  Initialize a statically allocated Mutex lock object.</span>
<a name="l04243"></a>04243 <span class="comment"> *  @description This call initialized a Mutex lock object without allocation. The object can then be used used </span>
<a name="l04244"></a>04244 <span class="comment"> *      in #mprLock, #mprTryLock and #mprUnlock calls.</span>
<a name="l04245"></a>04245 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04246"></a>04246 <span class="comment"> *  @param mutex Reference to an MprMutex structure to initialize</span>
<a name="l04247"></a>04247 <span class="comment"> *  @returns A reference to the supplied mutex. Returns null on errors.</span>
<a name="l04248"></a>04248 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04249"></a>04249 <span class="comment"> */</span>
<a name="l04250"></a>04250 <span class="keyword">extern</span> <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *<a class="code" href="group___mpr_synch.html#ge5ac7172314ec00d74bc8a5b61ee98fa" title="Initialize a statically allocated Mutex lock object.">mprInitLock</a>(MprCtx ctx, <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *mutex);
<a name="l04251"></a>04251 <span class="comment"></span>
<a name="l04252"></a>04252 <span class="comment">/**</span>
<a name="l04253"></a>04253 <span class="comment"> *  Attempt to lock access.</span>
<a name="l04254"></a>04254 <span class="comment"> *  @description This call attempts to assert a lock on the given \a lock mutex so that other threads calling </span>
<a name="l04255"></a>04255 <span class="comment"> *      mprLock or mprTryLock will block until the current thread calls mprUnlock.</span>
<a name="l04256"></a>04256 <span class="comment"> *  @returns Returns zero if the successful in locking the mutex. Returns a negative MPR error code if unsuccessful.</span>
<a name="l04257"></a>04257 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04258"></a>04258 <span class="comment"> */</span>
<a name="l04259"></a>04259 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d" title="Attempt to lock access.">mprTryLock</a>(<a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *lock);
<a name="l04260"></a>04260 <span class="comment"></span>
<a name="l04261"></a>04261 <span class="comment">/**</span>
<a name="l04262"></a>04262 <span class="comment"> *  Create a spin lock lock object.</span>
<a name="l04263"></a>04263 <span class="comment"> *  @description This call creates a spinlock object that can be used in #mprSpinLock, and #mprSpinUnlock calls. Spin locks</span>
<a name="l04264"></a>04264 <span class="comment"> *      using MprSpin are much faster than MprMutex based locks on some systems.</span>
<a name="l04265"></a>04265 <span class="comment"> *      Use #mprFree to destroy the lock.</span>
<a name="l04266"></a>04266 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04267"></a>04267 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04268"></a>04268 <span class="comment"> */</span>
<a name="l04269"></a>04269 <span class="keyword">extern</span> <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *<a class="code" href="group___mpr_synch.html#ge63f87a8d093d294bd1ce6747cbb42ec" title="Create a spin lock lock object.">mprCreateSpinLock</a>(MprCtx ctx);
<a name="l04270"></a>04270 <span class="comment"></span>
<a name="l04271"></a>04271 <span class="comment">/**</span>
<a name="l04272"></a>04272 <span class="comment"> *  Initialize a statically allocated spinlock object.</span>
<a name="l04273"></a>04273 <span class="comment"> *  @description This call initialized a spinlock lock object without allocation. The object can then be used used </span>
<a name="l04274"></a>04274 <span class="comment"> *      in #mprSpinLock and #mprSpinUnlock calls.</span>
<a name="l04275"></a>04275 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04276"></a>04276 <span class="comment"> *  @param lock Reference to a static #MprSpin  object.</span>
<a name="l04277"></a>04277 <span class="comment"> *  @returns A reference to the MprSpin object. Returns null on errors.</span>
<a name="l04278"></a>04278 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04279"></a>04279 <span class="comment"> */</span>
<a name="l04280"></a>04280 <span class="keyword">extern</span> <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *<a class="code" href="group___mpr_synch.html#gd0e8debf5fc06d66c839ef8979d8e4c9" title="Initialize a statically allocated spinlock object.">mprInitSpinLock</a>(MprCtx ctx, <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *lock);
<a name="l04281"></a>04281 <span class="comment"></span>
<a name="l04282"></a>04282 <span class="comment">/**</span>
<a name="l04283"></a>04283 <span class="comment"> *  Attempt to lock access on a spin lock</span>
<a name="l04284"></a>04284 <span class="comment"> *  @description This call attempts to assert a lock on the given \a spin lock so that other threads calling </span>
<a name="l04285"></a>04285 <span class="comment"> *      mprSpinLock or mprTrySpinLock will block until the current thread calls mprSpinUnlock.</span>
<a name="l04286"></a>04286 <span class="comment"> *  @returns Returns zero if the successful in locking the spinlock. Returns a negative MPR error code if unsuccessful.</span>
<a name="l04287"></a>04287 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04288"></a>04288 <span class="comment"> */</span>
<a name="l04289"></a>04289 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_synch.html#gc257b932fcc7140852e6830640d2301b" title="Attempt to lock access on a spin lock.">mprTrySpinLock</a>(<a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *lock);
<a name="l04290"></a>04290 
<a name="l04291"></a>04291 <span class="comment">/*</span>
<a name="l04292"></a>04292 <span class="comment"> *  For maximum performance, use the spin lock/unlock routines macros</span>
<a name="l04293"></a>04293 <span class="comment"> */</span>
<a name="l04294"></a>04294 <span class="preprocessor">#if !BLD_DEBUG</span>
<a name="l04295"></a>04295 <span class="preprocessor"></span><span class="preprocessor">#define BLD_USE_LOCK_MACROS 1</span>
<a name="l04296"></a>04296 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04297"></a>04297 <span class="preprocessor"></span><span class="preprocessor">#if BLD_USE_LOCK_MACROS &amp;&amp; !DOXYGEN</span>
<a name="l04298"></a>04298 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l04299"></a>04299 <span class="comment">     *  Spin lock macros</span>
<a name="l04300"></a>04300 <span class="comment">     */</span>
<a name="l04301"></a>04301 <span class="preprocessor">    #if MACOSX</span>
<a name="l04302"></a>04302 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinLock(lock)   OSSpinLockLock(&amp;((lock)-&gt;cs))</span>
<a name="l04303"></a>04303 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinUnlock(lock) OSSpinLockUnlock(&amp;((lock)-&gt;cs))</span>
<a name="l04304"></a>04304 <span class="preprocessor"></span><span class="preprocessor">    #elif BLD_UNIX_LIKE &amp;&amp; BLD_HAS_SPINLOCK</span>
<a name="l04305"></a>04305 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinLock(lock)   pthread_spin_lock(&amp;((lock)-&gt;cs))</span>
<a name="l04306"></a>04306 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinUnlock(lock) pthread_spin_unlock(&amp;((lock)-&gt;cs))</span>
<a name="l04307"></a>04307 <span class="preprocessor"></span><span class="preprocessor">    #elif BLD_UNIX_LIKE</span>
<a name="l04308"></a>04308 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinLock(lock)   pthread_mutex_lock(&amp;((lock)-&gt;cs))</span>
<a name="l04309"></a>04309 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinUnlock(lock) pthread_mutex_unlock(&amp;((lock)-&gt;cs))</span>
<a name="l04310"></a>04310 <span class="preprocessor"></span><span class="preprocessor">    #elif BLD_WIN_LIKE</span>
<a name="l04311"></a>04311 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinLock(lock)   EnterCriticalSection(&amp;((lock)-&gt;cs))</span>
<a name="l04312"></a>04312 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinUnlock(lock) LeaveCriticalSection(&amp;((lock)-&gt;cs))</span>
<a name="l04313"></a>04313 <span class="preprocessor"></span><span class="preprocessor">    #elif VXWORKS</span>
<a name="l04314"></a>04314 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinLock(lock)   semTake((lock)-&gt;cs, WAIT_FOREVER)</span>
<a name="l04315"></a>04315 <span class="preprocessor"></span><span class="preprocessor">        #define mprSpinUnlock(lock) semGive((lock)-&gt;cs)</span>
<a name="l04316"></a>04316 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l04317"></a>04317 <span class="preprocessor"></span>
<a name="l04318"></a>04318     <span class="comment">/*</span>
<a name="l04319"></a>04319 <span class="comment">     *  Lock macros</span>
<a name="l04320"></a>04320 <span class="comment">     */</span>
<a name="l04321"></a>04321 <span class="preprocessor">    #if BLD_UNIX_LIKE</span>
<a name="l04322"></a>04322 <span class="preprocessor"></span><span class="preprocessor">        #define mprLock(lock)       pthread_mutex_lock(&amp;((lock)-&gt;cs))</span>
<a name="l04323"></a>04323 <span class="preprocessor"></span><span class="preprocessor">        #define mprUnlock(lock)     pthread_mutex_unlock(&amp;((lock)-&gt;cs))</span>
<a name="l04324"></a>04324 <span class="preprocessor"></span><span class="preprocessor">    #elif BLD_WIN_LIKE</span>
<a name="l04325"></a>04325 <span class="preprocessor"></span><span class="preprocessor">        #define mprUnlock(lock)     LeaveCriticalSection(&amp;((lock)-&gt;cs))</span>
<a name="l04326"></a>04326 <span class="preprocessor"></span><span class="preprocessor">        #define mprLock(lock)       EnterCriticalSection(&amp;((lock)-&gt;cs))</span>
<a name="l04327"></a>04327 <span class="preprocessor"></span><span class="preprocessor">    #elif VXWORKS</span>
<a name="l04328"></a>04328 <span class="preprocessor"></span><span class="preprocessor">        #define mprUnlock(lock)     semGive((lock)-&gt;cs)</span>
<a name="l04329"></a>04329 <span class="preprocessor"></span><span class="preprocessor">        #define mprLock(lock)       semTake((lock)-&gt;cs, WAIT_FOREVER)</span>
<a name="l04330"></a>04330 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l04331"></a>04331 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l04332"></a>04332 <span class="preprocessor"></span><span class="comment"></span>
<a name="l04333"></a>04333 <span class="comment">    /**</span>
<a name="l04334"></a>04334 <span class="comment">     *  Lock access.</span>
<a name="l04335"></a>04335 <span class="comment">     *  @description This call asserts a lock on the given \a lock mutex so that other threads calling mprLock will </span>
<a name="l04336"></a>04336 <span class="comment">     *      block until the current thread calls mprUnlock.</span>
<a name="l04337"></a>04337 <span class="comment">     *  @ingroup MprSynch</span>
<a name="l04338"></a>04338 <span class="comment">     */</span>
<a name="l04339"></a>04339     <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede" title="Lock access.">mprLock</a>(<a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *lock);
<a name="l04340"></a>04340 <span class="comment"></span>
<a name="l04341"></a>04341 <span class="comment">    /**</span>
<a name="l04342"></a>04342 <span class="comment">     *  Unlock a mutex.</span>
<a name="l04343"></a>04343 <span class="comment">     *  @description This call unlocks a mutex previously locked via mprLock or mprTryLock.</span>
<a name="l04344"></a>04344 <span class="comment">     *  @ingroup MprSynch</span>
<a name="l04345"></a>04345 <span class="comment">     */</span>
<a name="l04346"></a>04346     <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad" title="Unlock a mutex.">mprUnlock</a>(<a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> *lock);
<a name="l04347"></a>04347 <span class="comment"></span>
<a name="l04348"></a>04348 <span class="comment">    /**</span>
<a name="l04349"></a>04349 <span class="comment">     *  Lock a spinlock.</span>
<a name="l04350"></a>04350 <span class="comment">     *  @description This call asserts a lock on the given \a spinlock so that other threads calling mprSpinLock will</span>
<a name="l04351"></a>04351 <span class="comment">     *      block until the curren thread calls mprSpinUnlock.</span>
<a name="l04352"></a>04352 <span class="comment">     *  @ingroup MprSynch</span>
<a name="l04353"></a>04353 <span class="comment">     */</span>
<a name="l04354"></a>04354     <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795" title="Lock a spinlock.">mprSpinLock</a>(<a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *lock);
<a name="l04355"></a>04355 <span class="comment"></span>
<a name="l04356"></a>04356 <span class="comment">    /**</span>
<a name="l04357"></a>04357 <span class="comment">     *  Unlock a spinlock.</span>
<a name="l04358"></a>04358 <span class="comment">     *  @description This call unlocks a spinlock previously locked via mprSpinLock or mprTrySpinLock.</span>
<a name="l04359"></a>04359 <span class="comment">     *  @ingroup MprSynch</span>
<a name="l04360"></a>04360 <span class="comment">     */</span>
<a name="l04361"></a>04361     <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e" title="Unlock a spinlock.">mprSpinUnlock</a>(<a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> *lock);
<a name="l04362"></a>04362 <span class="preprocessor">#endif</span>
<a name="l04363"></a>04363 <span class="preprocessor"></span><span class="comment"></span>
<a name="l04364"></a>04364 <span class="comment">/**</span>
<a name="l04365"></a>04365 <span class="comment"> *  Globally lock the application.</span>
<a name="l04366"></a>04366 <span class="comment"> *  @description This call asserts the application global lock so that other threads calling mprGlobalLock will </span>
<a name="l04367"></a>04367 <span class="comment"> *      block until the current thread calls mprGlobalUnlock.</span>
<a name="l04368"></a>04368 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04369"></a>04369 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04370"></a>04370 <span class="comment"> */</span>
<a name="l04371"></a>04371 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#g934273252bb4202c8adeb9d8841769a4" title="Globally lock the application.">mprGlobalLock</a>(MprCtx ctx);
<a name="l04372"></a>04372 <span class="comment"></span>
<a name="l04373"></a>04373 <span class="comment">/**</span>
<a name="l04374"></a>04374 <span class="comment"> *  Unlock the global mutex.</span>
<a name="l04375"></a>04375 <span class="comment"> *  @description This call unlocks the global mutex previously locked via mprGlobalLock.</span>
<a name="l04376"></a>04376 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04377"></a>04377 <span class="comment"> *  @ingroup MprSynch</span>
<a name="l04378"></a>04378 <span class="comment"> */</span>
<a name="l04379"></a>04379 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_synch.html#g9af03d596ad19cd7974d85d82a8c27ca" title="Unlock the global mutex.">mprGlobalUnlock</a>(MprCtx ctx);
<a name="l04380"></a>04380 
<a name="l04381"></a>04381 <span class="comment">/*</span>
<a name="l04382"></a>04382 <span class="comment"> *  Thread service</span>
<a name="l04383"></a>04383 <span class="comment"> */</span>
<a name="l04384"></a>04384 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprThreadService {
<a name="l04385"></a>04385     MprList         *threads;           <span class="comment">/* List of all threads */</span>
<a name="l04386"></a>04386     <span class="keyword">struct </span>MprThread *mainThread;       <span class="comment">/* Main application Mpr thread id */</span>
<a name="l04387"></a>04387     <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;             <span class="comment">/* Multi-thread sync */</span>
<a name="l04388"></a>04388     <span class="keywordtype">int</span>             stackSize;          <span class="comment">/* Default thread stack size */</span>
<a name="l04389"></a>04389 } MprThreadService;
<a name="l04390"></a>04390 
<a name="l04391"></a>04391 
<a name="l04392"></a>04392 <span class="keyword">typedef</span> void (*MprThreadProc)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span>MprThread *tp);
<a name="l04393"></a>04393 
<a name="l04394"></a>04394 <span class="keyword">extern</span> MprThreadService *mprCreateThreadService(<span class="keyword">struct</span> Mpr *mpr);
<a name="l04395"></a>04395 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprStartThreadService(MprThreadService *ts);
<a name="l04396"></a>04396 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprStopThreadService(MprThreadService *ts, <span class="keywordtype">int</span> timeout);
<a name="l04397"></a>04397 <span class="comment"></span>
<a name="l04398"></a>04398 <span class="comment">/**</span>
<a name="l04399"></a>04399 <span class="comment"> *  Thread Service. </span>
<a name="l04400"></a>04400 <span class="comment"> *  @description The MPR provides a cross-platform thread abstraction above O/S native threads. It supports </span>
<a name="l04401"></a>04401 <span class="comment"> *      arbitrary thread creation, thread priorities, thread management and thread local storage. By using these</span>
<a name="l04402"></a>04402 <span class="comment"> *      thread primitives with the locking and synchronization primitives offered by #MprMutex, #MprSpin and </span>
<a name="l04403"></a>04403 <span class="comment"> *      #MprCond - you can create cross platform multi-threaded applications.</span>
<a name="l04404"></a>04404 <span class="comment"> *  @stability Evolving</span>
<a name="l04405"></a>04405 <span class="comment"> *  @see MprThread, mprCreateThread, mprStartThread, mprGetThreadName, mprGetThreadPriority, </span>
<a name="l04406"></a>04406 <span class="comment"> *      mprSetThreadPriority, mprGetCurrentThread, mprGetCurrentOsThread, mprSetThreadPriority, </span>
<a name="l04407"></a>04407 <span class="comment"> *      mprSetThreadData, mprGetThreadData, mprCreateThreadLocal</span>
<a name="l04408"></a>04408 <span class="comment"> *  @defgroup MprThread MprThread</span>
<a name="l04409"></a>04409 <span class="comment"> */</span>
<a name="l04410"></a>04410 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprThread {
<a name="l04411"></a>04411     MprOsThread     osThread;           <span class="comment">/**&lt; O/S thread id */</span>
<a name="l04412"></a>04412 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l04413"></a>04413 <span class="preprocessor"></span>    handle          threadHandle;       <span class="comment">/**&lt; Threads OS handle for WIN */</span>
<a name="l04414"></a>04414 <span class="preprocessor">#endif</span>
<a name="l04415"></a>04415 <span class="preprocessor"></span>    MprThreadProc   entry;              <span class="comment">/**&lt; Users thread entry point */</span>
<a name="l04416"></a>04416     <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;             <span class="comment">/**&lt; Multi-thread locking */</span>
<a name="l04417"></a>04417     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *cond;              <span class="comment">/**&lt; Multi-thread synchronization */</span>
<a name="l04418"></a>04418     MprDispatcher   *dispatcher;        <span class="comment">/**&lt; Dispatcher associated with this thread */</span>
<a name="l04419"></a>04419     <span class="keywordtype">void</span>            *data;              <span class="comment">/**&lt; Data argument */</span>
<a name="l04420"></a>04420     <span class="keywordtype">char</span>            *name;              <span class="comment">/**&lt; Name of thead for trace */</span>
<a name="l04421"></a>04421     ulong           pid;                <span class="comment">/**&lt; Owning process id */</span>
<a name="l04422"></a>04422     <span class="keywordtype">int</span>             priority;           <span class="comment">/**&lt; Current priority */</span>
<a name="l04423"></a>04423     <span class="keywordtype">int</span>             stackSize;          <span class="comment">/**&lt; Only VxWorks implements */</span>
<a name="l04424"></a>04424     <span class="keywordtype">int</span>             isMain;             <span class="comment">/**&lt; Is the main thread */</span>
<a name="l04425"></a>04425 } MprThread;
<a name="l04426"></a>04426 
<a name="l04427"></a>04427 <span class="comment"></span>
<a name="l04428"></a>04428 <span class="comment">/**</span>
<a name="l04429"></a>04429 <span class="comment"> *  Thread local data storage</span>
<a name="l04430"></a>04430 <span class="comment"> */</span>
<a name="l04431"></a><a class="code" href="struct_mpr_thread_local.html">04431</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a> {
<a name="l04432"></a>04432 <span class="preprocessor">#if BLD_UNIX_LIKE</span>
<a name="l04433"></a><a class="code" href="struct_mpr_thread_local.html#76226f0ba0cb5d4d37a438947493a39f">04433</a> <span class="preprocessor"></span>    pthread_key_t   <a class="code" href="struct_mpr_thread_local.html#76226f0ba0cb5d4d37a438947493a39f" title="Data key.">key</a>;                <span class="comment">/**&lt; Data key */</span>
<a name="l04434"></a>04434 <span class="preprocessor">#elif BLD_WIN_LIKE</span>
<a name="l04435"></a>04435 <span class="preprocessor"></span>    DWORD           <a class="code" href="struct_mpr_thread_local.html#76226f0ba0cb5d4d37a438947493a39f" title="Data key.">key</a>;
<a name="l04436"></a>04436 <span class="preprocessor">#else</span>
<a name="l04437"></a>04437 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             dummy;              <span class="comment">/**&lt; Prevents asserts in memory allocation */</span>
<a name="l04438"></a>04438 <span class="preprocessor">#endif</span>
<a name="l04439"></a>04439 <span class="preprocessor"></span>} <a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a>;
<a name="l04440"></a>04440 
<a name="l04441"></a>04441 <span class="comment"></span>
<a name="l04442"></a>04442 <span class="comment">/**</span>
<a name="l04443"></a>04443 <span class="comment"> *  Create a new thread</span>
<a name="l04444"></a>04444 <span class="comment"> *  @description MPR threads are usually real O/S threads and can be used with the various locking services (#MprMutex,</span>
<a name="l04445"></a>04445 <span class="comment"> *      #MprCond, #MprSpin) to enable scalable multithreaded applications.</span>
<a name="l04446"></a>04446 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04447"></a>04447 <span class="comment"> *  @param name Unique name to give the thread</span>
<a name="l04448"></a>04448 <span class="comment"> *  @param proc Entry point function for the thread. #mprStartThread will invoke this function to start the thread</span>
<a name="l04449"></a>04449 <span class="comment"> *  @param data Thread private data stored in MprThread.data</span>
<a name="l04450"></a>04450 <span class="comment"> *  @param stackSize Stack size to use for the thread. On VM based systems, increasing this value, does not </span>
<a name="l04451"></a>04451 <span class="comment"> *      necessarily incurr a real memory (working-set) increase. Set to zero for a default stack size.</span>
<a name="l04452"></a>04452 <span class="comment"> *  @returns A MprThread object</span>
<a name="l04453"></a>04453 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04454"></a>04454 <span class="comment"> */</span>
<a name="l04455"></a>04455 <span class="keyword">extern</span> MprThread *<a class="code" href="group___mpr_thread.html#g026dcaf0b9eb162486103a9b99632939" title="Create a new thread.">mprCreateThread</a>(MprCtx ctx, cchar *name, MprThreadProc proc, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> stackSize);
<a name="l04456"></a>04456 <span class="comment"></span>
<a name="l04457"></a>04457 <span class="comment">/**</span>
<a name="l04458"></a>04458 <span class="comment"> *  Start a thread</span>
<a name="l04459"></a>04459 <span class="comment"> *  @description Start a thread previously created via #mprCreateThread. The thread will begin at the entry function </span>
<a name="l04460"></a>04460 <span class="comment"> *      defined in #mprCreateThread.</span>
<a name="l04461"></a>04461 <span class="comment"> *  @param thread Thread object returned from #mprCreateThread</span>
<a name="l04462"></a>04462 <span class="comment"> *  @return Returns zero if successful, otherwise a negative MPR error code.</span>
<a name="l04463"></a>04463 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04464"></a>04464 <span class="comment"> */</span>
<a name="l04465"></a>04465 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_thread.html#g35c53df918c2f52e2e1f6961e35ee8d1" title="Start a thread.">mprStartThread</a>(MprThread *thread);
<a name="l04466"></a>04466 <span class="comment"></span>
<a name="l04467"></a>04467 <span class="comment">/**</span>
<a name="l04468"></a>04468 <span class="comment"> *  Get the thread name.</span>
<a name="l04469"></a>04469 <span class="comment"> *  @description MPR threads are usually real O/S threads and can be used with the various locking services (#MprMutex,</span>
<a name="l04470"></a>04470 <span class="comment"> *      #MprCond, #MprSpin) to enable scalable multithreaded applications.</span>
<a name="l04471"></a>04471 <span class="comment"> *  @param thread Thread object returned from #mprCreateThread</span>
<a name="l04472"></a>04472 <span class="comment"> *  @return Returns a string name for the thread. Caller must not free.</span>
<a name="l04473"></a>04473 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04474"></a>04474 <span class="comment"> */</span>
<a name="l04475"></a>04475 <span class="keyword">extern</span> cchar *<a class="code" href="group___mpr_thread.html#gc98816057bf8f47f8d15131e68ae12f7" title="Get the thread name.">mprGetThreadName</a>(MprThread *thread);
<a name="l04476"></a>04476 <span class="comment"></span>
<a name="l04477"></a>04477 <span class="comment">/**</span>
<a name="l04478"></a>04478 <span class="comment"> *  Get the thread priroity</span>
<a name="l04479"></a>04479 <span class="comment"> *  @description Get the current priority for the specified thread.</span>
<a name="l04480"></a>04480 <span class="comment"> *  @param thread Thread object returned by #mprCreateThread</span>
<a name="l04481"></a>04481 <span class="comment"> *  @returns An integer MPR thread priority between 0 and 100 inclusive.</span>
<a name="l04482"></a>04482 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04483"></a>04483 <span class="comment"> */</span>
<a name="l04484"></a>04484 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_thread.html#g0edd7ee5a80c5566dbcd079293280b1a" title="Get the thread priroity.">mprGetThreadPriority</a>(MprThread *thread);
<a name="l04485"></a>04485 <span class="comment"></span>
<a name="l04486"></a>04486 <span class="comment">/**</span>
<a name="l04487"></a>04487 <span class="comment"> *  Set the thread priroity</span>
<a name="l04488"></a>04488 <span class="comment"> *  @description Set the current priority for the specified thread.</span>
<a name="l04489"></a>04489 <span class="comment"> *  @param thread Thread object returned by #mprCreateThread</span>
<a name="l04490"></a>04490 <span class="comment"> *  @param priority Priority to associate with the thread. Mpr thread priorities are are integer values between 0 </span>
<a name="l04491"></a>04491 <span class="comment"> *      and 100 inclusive with 50 being a normal priority. The MPR maps these priorities in a linear fashion onto </span>
<a name="l04492"></a>04492 <span class="comment"> *      native O/S priorites. Useful constants are: </span>
<a name="l04493"></a>04493 <span class="comment"> *      @li MPR_LOW_PRIORITY</span>
<a name="l04494"></a>04494 <span class="comment"> *      @li MPR_NORMAL_PRIORITY</span>
<a name="l04495"></a>04495 <span class="comment"> *      @li MPR_HIGH_PRIORITY</span>
<a name="l04496"></a>04496 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04497"></a>04497 <span class="comment"> */</span>
<a name="l04498"></a>04498 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_thread.html#g60bd7071428f6043d834c48ee8914560" title="Set the thread priroity.">mprSetThreadPriority</a>(MprThread *thread, <span class="keywordtype">int</span> priority);
<a name="l04499"></a>04499 <span class="comment"></span>
<a name="l04500"></a>04500 <span class="comment">/**</span>
<a name="l04501"></a>04501 <span class="comment"> *  Get the currently executing thread.</span>
<a name="l04502"></a>04502 <span class="comment"> *  @description Get the thread object for the currently executing O/S thread.</span>
<a name="l04503"></a>04503 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l04504"></a>04504 <span class="comment"> *  @return Returns a thread object representing the current O/S thread.</span>
<a name="l04505"></a>04505 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04506"></a>04506 <span class="comment"> */</span>
<a name="l04507"></a>04507 <span class="keyword">extern</span> MprThread *<a class="code" href="group___mpr_thread.html#gf7be9fb3ab99388b3e83093a78a74265" title="Get the currently executing thread.">mprGetCurrentThread</a>(MprCtx ctx);
<a name="l04508"></a>04508 <span class="comment"></span>
<a name="l04509"></a>04509 <span class="comment">/**</span>
<a name="l04510"></a>04510 <span class="comment"> *  Get the O/S thread</span>
<a name="l04511"></a>04511 <span class="comment"> *  @description Get the O/S thread ID for the currently executing thread.</span>
<a name="l04512"></a>04512 <span class="comment"> *  @return Returns a platform specific O/S thread ID. On Unix, this is a pthread reference. On other systems it is</span>
<a name="l04513"></a>04513 <span class="comment"> *      a thread integer value.</span>
<a name="l04514"></a>04514 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04515"></a>04515 <span class="comment"> */</span>
<a name="l04516"></a>04516 <span class="keyword">extern</span> MprOsThread <a class="code" href="group___mpr_thread.html#ga499ec9a691d9b74753edeac24afbcdc" title="Get the O/S thread.">mprGetCurrentOsThread</a>();
<a name="l04517"></a>04517 <span class="comment"></span>
<a name="l04518"></a>04518 <span class="comment">/**</span>
<a name="l04519"></a>04519 <span class="comment"> *  Set the thread priroity for the current thread.</span>
<a name="l04520"></a>04520 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l04521"></a>04521 <span class="comment"> *  @description Set the current priority for the specified thread.</span>
<a name="l04522"></a>04522 <span class="comment"> *  @param priority Priority to associate with the thread. Mpr thread priorities are are integer values between 0 </span>
<a name="l04523"></a>04523 <span class="comment"> *      and 100 inclusive with 50 being a normal priority. The MPR maps these priorities in a linear fashion onto </span>
<a name="l04524"></a>04524 <span class="comment"> *      native O/S priorites. Useful constants are: </span>
<a name="l04525"></a>04525 <span class="comment"> *      @li MPR_LOW_PRIORITY</span>
<a name="l04526"></a>04526 <span class="comment"> *      @li MPR_NORMAL_PRIORITY</span>
<a name="l04527"></a>04527 <span class="comment"> *      @li MPR_HIGH_PRIORITY</span>
<a name="l04528"></a>04528 <span class="comment"> *  @ingroup MprThread</span>
<a name="l04529"></a>04529 <span class="comment"> */</span>
<a name="l04530"></a>04530 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_thread.html#ga809ed728aec623d30af5c895d3bd5c3" title="Set the thread priroity for the current thread.">mprSetCurrentThreadPriority</a>(MprCtx ctx, <span class="keywordtype">int</span> priority);
<a name="l04531"></a>04531 
<a name="l04532"></a>04532 <span class="comment">/*</span>
<a name="l04533"></a>04533 <span class="comment"> *  Somewhat internal APIs</span>
<a name="l04534"></a>04534 <span class="comment"> */</span>
<a name="l04535"></a>04535 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprMapMprPriorityToOs(<span class="keywordtype">int</span> mprPriority);
<a name="l04536"></a>04536 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprMapOsPriorityToMpr(<span class="keywordtype">int</span> nativePriority);
<a name="l04537"></a>04537 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetThreadStackSize(MprCtx ctx, <span class="keywordtype">int</span> size);
<a name="l04538"></a>04538 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprSetThreadData(<a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a> *tls, <span class="keywordtype">void</span> *value);
<a name="l04539"></a>04539 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mprGetThreadData(<a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a> *tls);
<a name="l04540"></a>04540 <span class="keyword">extern</span> <a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a> *mprCreateThreadLocal(MprCtx ctx);
<a name="l04541"></a>04541 
<a name="l04542"></a>04542 <span class="preprocessor">#else </span><span class="comment">/* !BLD_FEATURE_MULTITHREAD */</span>
<a name="l04543"></a>04543 
<a name="l04544"></a>04544 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a> {
<a name="l04545"></a>04545     <span class="keywordtype">int</span>             dummy;
<a name="l04546"></a>04546 } <a class="code" href="struct_mpr_thread_local.html" title="Thread local data storage.">MprThreadLocal</a>;
<a name="l04547"></a>04547 <span class="keyword">typedef</span> <span class="keywordtype">void</span> *MprThread;
<a name="l04548"></a>04548 
<a name="l04549"></a>04549 <span class="preprocessor">#define mprInitThreads(ctx, mpr)</span>
<a name="l04550"></a>04550 <span class="preprocessor"></span><span class="preprocessor">#define mprTermThreads(mpr)</span>
<a name="l04551"></a>04551 <span class="preprocessor"></span><span class="preprocessor">#define mprCreateLock(ctx)</span>
<a name="l04552"></a>04552 <span class="preprocessor"></span><span class="preprocessor">#define mprLock(lock)</span>
<a name="l04553"></a>04553 <span class="preprocessor"></span><span class="preprocessor">#define mprTryLock(lock) ((void*) 1)</span>
<a name="l04554"></a>04554 <span class="preprocessor"></span><span class="preprocessor">#define mprUnlock(lock)</span>
<a name="l04555"></a>04555 <span class="preprocessor"></span><span class="preprocessor">#define mprCreateSpinLock(ctx)</span>
<a name="l04556"></a>04556 <span class="preprocessor"></span><span class="preprocessor">#define mprSpinLock(lock)</span>
<a name="l04557"></a>04557 <span class="preprocessor"></span><span class="preprocessor">#define mprTrySpinLock(lock)</span>
<a name="l04558"></a>04558 <span class="preprocessor"></span><span class="preprocessor">#define mprSpinUnlock(lock)</span>
<a name="l04559"></a>04559 <span class="preprocessor"></span><span class="preprocessor">#define mprGlobalLock(mpr)</span>
<a name="l04560"></a>04560 <span class="preprocessor"></span><span class="preprocessor">#define mprGlobalUnlock(mpr)</span>
<a name="l04561"></a>04561 <span class="preprocessor"></span><span class="preprocessor">#define mprSetThreadData(tls, value)</span>
<a name="l04562"></a>04562 <span class="preprocessor"></span><span class="preprocessor">#define mprGetThreadData(tls) NULL</span>
<a name="l04563"></a>04563 <span class="preprocessor"></span><span class="preprocessor">#define mprCreateThreadLocal(ejs) ((void*) 1)</span>
<a name="l04564"></a>04564 <span class="preprocessor"></span><span class="preprocessor">#define mprGetCurrentOsThread(ctx) ((void*) 1)</span>
<a name="l04565"></a>04565 <span class="preprocessor"></span><span class="preprocessor">#define lock(arg) </span>
<a name="l04566"></a>04566 <span class="preprocessor"></span><span class="preprocessor">#define unlock(arg) </span>
<a name="l04567"></a>04567 <span class="preprocessor"></span><span class="preprocessor">#define spinlock(arg) </span>
<a name="l04568"></a>04568 <span class="preprocessor"></span><span class="preprocessor">#define spinunlock(arg) </span>
<a name="l04569"></a>04569 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* BLD_FEATURE_MULTITHREAD */</span>
<a name="l04570"></a>04570 <span class="comment"></span>
<a name="l04571"></a>04571 <span class="comment">/**</span>
<a name="l04572"></a>04572 <span class="comment"> *  Return the name of the current thread</span>
<a name="l04573"></a>04573 <span class="comment"> *  @returns a static thread name. Caller must not free</span>
<a name="l04574"></a>04574 <span class="comment"> */</span>
<a name="l04575"></a>04575 <span class="keyword">extern</span> cchar *<a class="code" href="mpr_8h.html#09693a2d0138d474b5825bdc4d742fcc" title="Return the name of the current thread.">mprGetCurrentThreadName</a>(MprCtx ctx);
<a name="l04576"></a>04576 
<a name="l04577"></a>04577 <span class="comment">/*</span>
<a name="l04578"></a>04578 <span class="comment"> *  Magic number to identify blocks. Only used in debug mode.</span>
<a name="l04579"></a>04579 <span class="comment"> */</span>
<a name="l04580"></a>04580 <span class="preprocessor">#define MPR_ALLOC_MAGIC     0xe814ecab</span>
<a name="l04581"></a>04581 <span class="preprocessor"></span><span class="comment"></span>
<a name="l04582"></a>04582 <span class="comment">/**</span>
<a name="l04583"></a>04583 <span class="comment"> *  Memory allocation error callback. Notifiers are called if mprSetNotifier has been called on a context and a </span>
<a name="l04584"></a>04584 <span class="comment"> *  memory allocation fails. All notifiers up the parent context chain are called in order.</span>
<a name="l04585"></a>04585 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l04586"></a>04586 <span class="comment"> *  @param size Size of memory allocation request that failed</span>
<a name="l04587"></a>04587 <span class="comment"> *  @param total Total memory allocations so far</span>
<a name="l04588"></a>04588 <span class="comment"> *  @param granted Set to true if the request was actually granted, but the application is now exceeding its redline</span>
<a name="l04589"></a>04589 <span class="comment"> *      memory limit.</span>
<a name="l04590"></a>04590 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04591"></a>04591 <span class="comment"> */</span>
<a name="l04592"></a><a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">04592</a> <span class="keyword">typedef</span> void (*<a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a>)(MprCtx ctx, int64 size, int64 total, <span class="keywordtype">bool</span> granted);
<a name="l04593"></a>04593 <span class="comment"></span>
<a name="l04594"></a>04594 <span class="comment">/**</span>
<a name="l04595"></a>04595 <span class="comment"> *  Mpr memory block destructors prototype</span>
<a name="l04596"></a>04596 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l04597"></a>04597 <span class="comment"> *  @return Return zero if the memory was actually freed. Return non-zero to prevent the memory being freed.</span>
<a name="l04598"></a>04598 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04599"></a>04599 <span class="comment"> */</span>
<a name="l04600"></a><a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">04600</a> <span class="keyword">typedef</span> int (*<a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a>)(MprCtx ctx);
<a name="l04601"></a>04601 
<a name="l04602"></a>04602 <span class="preprocessor">#if BLD_DEBUG</span>
<a name="l04603"></a>04603 <span class="preprocessor"></span><span class="preprocessor">    #define BLD_FEATURE_MEMORY_DEBUG    1   </span><span class="comment">/* Enable memory debug assist. Fill blocks, verifies block integrity. */</span>
<a name="l04604"></a>04604 <span class="preprocessor">    #define BLD_FEATURE_MEMORY_STATS    1   </span><span class="comment">/* Include memory stats routines */</span>
<a name="l04605"></a>04605 <span class="preprocessor">#else</span>
<a name="l04606"></a>04606 <span class="preprocessor"></span><span class="preprocessor">    #define BLD_FEATURE_MEMORY_STATS    1</span>
<a name="l04607"></a>04607 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04608"></a>04608 <span class="preprocessor"></span>
<a name="l04609"></a>04609 <span class="comment">/*</span>
<a name="l04610"></a>04610 <span class="comment"> *  MprBlk flags</span>
<a name="l04611"></a>04611 <span class="comment"> */</span>
<a name="l04612"></a>04612 <span class="preprocessor">#define MPR_ALLOC_HAS_DESTRUCTOR    0x1     </span><span class="comment">/* Block has a destructor to be called when freed */</span>
<a name="l04613"></a>04613 <span class="preprocessor">#define MPR_ALLOC_HAS_ERROR         0x2     </span><span class="comment">/* Memory context has had allocation errors */</span>
<a name="l04614"></a>04614 <span class="preprocessor">#define MPR_ALLOC_IS_HEAP           0x4     </span><span class="comment">/* Block is a heap context */</span>
<a name="l04615"></a>04615 <span class="preprocessor">#define MPR_ALLOC_FROM_MALLOC       0x8     </span><span class="comment">/* Block allocated from a malloc heap */</span>
<a name="l04616"></a>04616 <span class="preprocessor">#define MPR_ALLOC_BIGGEST           0x0FFFFFFF </span><span class="comment">/* Largest block that can be allocated */</span>
<a name="l04617"></a>04617 
<a name="l04618"></a>04618 <span class="comment">/*</span>
<a name="l04619"></a>04619 <span class="comment"> *  Align blocks on 8 byte boundaries.</span>
<a name="l04620"></a>04620 <span class="comment"> */</span>
<a name="l04621"></a>04621 <span class="preprocessor">#define MPR_ALLOC_ALIGN(x)  (((x) + 7 ) &amp; ~7)</span>
<a name="l04622"></a>04622 <span class="preprocessor"></span><span class="preprocessor">#define MPR_PAGE_ALIGN(x, pagesize) (((x) + (pagesize) - 1) &amp; ~(pagesize - 1))</span>
<a name="l04623"></a>04623 <span class="preprocessor"></span>
<a name="l04624"></a>04624 <span class="comment"></span>
<a name="l04625"></a>04625 <span class="comment">/**</span>
<a name="l04626"></a>04626 <span class="comment"> *  Memory Allocation Block Header.</span>
<a name="l04627"></a>04627 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04628"></a>04628 <span class="comment"> */</span>
<a name="l04629"></a><a class="code" href="struct_mpr_blk.html">04629</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> {
<a name="l04630"></a>04630 <span class="preprocessor">#if BLD_DEBUG</span>
<a name="l04631"></a>04631 <span class="preprocessor"></span>    <span class="keywordtype">char</span>            *name;                  <span class="comment">/* Debug Name */</span>
<a name="l04632"></a>04632 <span class="preprocessor">#endif</span>
<a name="l04633"></a>04633 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>   *parent;                <span class="comment">/* Parent block */</span>
<a name="l04634"></a>04634     <span class="keyword">struct </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>   *children;              <span class="comment">/* First child block. Flags stored in low order bits. */</span>
<a name="l04635"></a>04635     <span class="keyword">struct </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>   *next;                  <span class="comment">/* Next sibling */</span>
<a name="l04636"></a>04636     <span class="keyword">struct </span><a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>   *prev;                  <span class="comment">/* Prior sibling */</span>
<a name="l04637"></a>04637     uint            size: 28;               <span class="comment">/* Size of the block (not counting header) */</span>
<a name="l04638"></a>04638     uint            flags: 4;               <span class="comment">/* Flags */</span>
<a name="l04639"></a>04639 <span class="preprocessor">#if BLD_FEATURE_MEMORY_DEBUG</span>
<a name="l04640"></a>04640 <span class="preprocessor"></span>    uint            magic;                  <span class="comment">/* Unique signature */</span>
<a name="l04641"></a>04641 <span class="preprocessor">#endif</span>
<a name="l04642"></a>04642 <span class="preprocessor"></span>} <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>;
<a name="l04643"></a>04643 
<a name="l04644"></a>04644 <span class="preprocessor">#define MPR_ALLOC_HDR_SIZE      (MPR_ALLOC_ALIGN(sizeof(struct MprBlk)))</span>
<a name="l04645"></a>04645 <span class="preprocessor"></span><span class="preprocessor">#define MPR_GET_BLK(ptr)        ((MprBlk*) (((char*) (ptr)) - MPR_ALLOC_HDR_SIZE))</span>
<a name="l04646"></a>04646 <span class="preprocessor"></span><span class="preprocessor">#define MPR_GET_PTR(bp)         ((void*) (((char*) (bp)) + MPR_ALLOC_HDR_SIZE))</span>
<a name="l04647"></a>04647 <span class="preprocessor"></span><span class="preprocessor">#define MPR_GET_BLK_SIZE(bp)    ((bp)-&gt;size)</span>
<a name="l04648"></a>04648 <span class="preprocessor"></span><span class="preprocessor">#define MPR_SET_SIZE(bp, len)   ((bp)-&gt;size = (len))</span>
<a name="l04649"></a>04649 <span class="preprocessor"></span><span class="preprocessor">#define mprGetBlockSize(ptr)    ((ptr) ? (MPR_GET_BLK_SIZE(MPR_GET_BLK(ptr)) - MPR_ALLOC_HDR_SIZE): 0)</span>
<a name="l04650"></a>04650 <span class="preprocessor"></span><span class="preprocessor">#define MPR_HEAP_OVERHEAD       (MPR_ALLOC_HDR_SIZE + MPR_ALLOC_ALIGN(sizeof(MprRegion) + sizeof(MprHeap) + \</span>
<a name="l04651"></a>04651 <span class="preprocessor">                                  sizeof(MprDestructor)))</span>
<a name="l04652"></a>04652 <span class="preprocessor"></span><span class="preprocessor">#define mprGetFirstChild(ctx)   (void*) (MPR_GET_BLK(ctx)-&gt;children)</span>
<a name="l04653"></a>04653 <span class="preprocessor"></span>
<a name="l04654"></a>04654 <span class="comment">/*</span>
<a name="l04655"></a>04655 <span class="comment"> *  Region of memory. Regions are used to describe chunks of memory used by Heaps.</span>
<a name="l04656"></a>04656 <span class="comment"> */</span>
<a name="l04657"></a>04657 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprRegion {
<a name="l04658"></a>04658     <span class="keyword">struct </span>MprRegion *next;                 <span class="comment">/* Next region in chain */</span>
<a name="l04659"></a>04659     <span class="keywordtype">char</span>            *memory;                <span class="comment">/* Region memory data */</span>
<a name="l04660"></a>04660     <span class="keywordtype">char</span>            *nextMem;               <span class="comment">/* Pointer to next free byte in memory */</span>
<a name="l04661"></a>04661     <span class="keywordtype">int</span>             vmSize;                 <span class="comment">/* Size of virtual memory containing the region struct plus region memory */</span>
<a name="l04662"></a>04662     <span class="keywordtype">int</span>             size;                   <span class="comment">/* Original size of region */</span>
<a name="l04663"></a>04663 } MprRegion;
<a name="l04664"></a>04664 
<a name="l04665"></a>04665 <span class="comment">/*</span>
<a name="l04666"></a>04666 <span class="comment"> *  Heap flags</span>
<a name="l04667"></a>04667 <span class="comment"> */</span>
<a name="l04668"></a>04668 <span class="preprocessor">#define MPR_ALLOC_PAGE_HEAP     0x1         </span><span class="comment">/* Page based heap. Used for allocating arenas and slabs */</span>
<a name="l04669"></a>04669 <span class="preprocessor">#define MPR_ALLOC_ARENA_HEAP    0x2         </span><span class="comment">/* Heap is an arena. All allocations are done from one or more regions */</span>
<a name="l04670"></a>04670 <span class="preprocessor">#define MPR_ALLOC_SLAB_HEAP     0x4         </span><span class="comment">/* Heap is a slab. Constant sized objects use slab heaps */</span>
<a name="l04671"></a>04671 <span class="preprocessor">#define MPR_ALLOC_MALLOC_HEAP   0x8         </span><span class="comment">/* Heap is a standard malloc heap */</span>
<a name="l04672"></a>04672 <span class="preprocessor">#define MPR_ALLOC_FREE_CHILDREN 0x10        </span><span class="comment">/* Heap must be accessed in a thread safe fashion */</span>
<a name="l04673"></a>04673 <span class="preprocessor">#define MPR_ALLOC_THREAD_SAFE   0x20        </span><span class="comment">/* Heap must be accessed in a thread safe fashion */</span>
<a name="l04674"></a>04674 
<a name="l04675"></a>04675 <span class="comment">/*</span>
<a name="l04676"></a>04676 <span class="comment"> *  The heap context supports arena and slab based allocations. Layout of allocated heap blocks:</span>
<a name="l04677"></a>04677 <span class="comment"> *      HDR</span>
<a name="l04678"></a>04678 <span class="comment"> *      MprHeap</span>
<a name="l04679"></a>04679 <span class="comment"> *      MprRegion</span>
<a name="l04680"></a>04680 <span class="comment"> *      Heap Data</span>
<a name="l04681"></a>04681 <span class="comment"> *      Destructor</span>
<a name="l04682"></a>04682 <span class="comment"> */</span>
<a name="l04683"></a>04683 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprHeap {
<a name="l04684"></a>04684     cchar           *name;                  <span class="comment">/* Debugging name of the heap */</span>
<a name="l04685"></a>04685     <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a>   destructor;             <span class="comment">/* Heap destructor routine */</span>
<a name="l04686"></a>04686     MprRegion       *region;                <span class="comment">/* Current region of memory for allocation */</span>
<a name="l04687"></a>04687     MprRegion       *depleted;              <span class="comment">/* Depleted regions. All useful memory has been allocated */</span>
<a name="l04688"></a>04688     <span class="keywordtype">int</span>             flags;                  <span class="comment">/* Heap flags */</span>
<a name="l04689"></a>04689     <span class="comment">/*</span>
<a name="l04690"></a>04690 <span class="comment">     *  Slab allocation object information and free list</span>
<a name="l04691"></a>04691 <span class="comment">     */</span>
<a name="l04692"></a>04692     <span class="keywordtype">int</span>             objSize;                <span class="comment">/* Size of each heap object */</span>
<a name="l04693"></a>04693     <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a>          *freeList;              <span class="comment">/* Linked list of free objects */</span>
<a name="l04694"></a>04694     <span class="comment">/*</span>
<a name="l04695"></a>04695 <span class="comment">     *  Stats</span>
<a name="l04696"></a>04696 <span class="comment">     */</span>
<a name="l04697"></a>04697     <span class="keywordtype">int</span>            allocBytes;              <span class="comment">/* Number of bytes allocated for this heap */</span>
<a name="l04698"></a>04698     <span class="keywordtype">int</span>            peakAllocBytes;          <span class="comment">/* Peak allocated (max allocBytes) */</span>
<a name="l04699"></a>04699     <span class="keywordtype">int</span>            allocBlocks;             <span class="comment">/* Number of alloced blocks for this heap */</span>
<a name="l04700"></a>04700     <span class="keywordtype">int</span>            peakAllocBlocks;         <span class="comment">/* Peak allocated blocks */</span>
<a name="l04701"></a>04701     <span class="keywordtype">int</span>            totalAllocCalls;         <span class="comment">/* Total count of allocation calls */</span>
<a name="l04702"></a>04702     <span class="keywordtype">int</span>            freeListCount;           <span class="comment">/* Count of objects on freeList */</span>
<a name="l04703"></a>04703     <span class="keywordtype">int</span>            peakFreeListCount;       <span class="comment">/* Peak count of blocks on the free list */</span>
<a name="l04704"></a>04704     <span class="keywordtype">int</span>            reuseCount;              <span class="comment">/* Count of allocations from the freelist */</span>
<a name="l04705"></a>04705     <span class="keywordtype">int</span>            reservedBytes;           <span class="comment">/* Virtual allocations for page heaps */</span>
<a name="l04706"></a>04706 
<a name="l04707"></a>04707     <a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a> notifier;              <span class="comment">/* Memory allocation failure callback */</span>
<a name="l04708"></a>04708     MprCtx         notifierCtx;             <span class="comment">/* Memory block context for the notifier */</span>
<a name="l04709"></a>04709 
<a name="l04710"></a>04710 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l04711"></a>04711 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a>         spin;
<a name="l04712"></a>04712 <span class="preprocessor">#endif</span>
<a name="l04713"></a>04713 <span class="preprocessor"></span>} MprHeap;
<a name="l04714"></a>04714 
<a name="l04715"></a>04715 
<a name="l04716"></a>04716 <span class="comment">/*</span>
<a name="l04717"></a>04717 <span class="comment"> *  Memory allocation control</span>
<a name="l04718"></a>04718 <span class="comment"> */</span>
<a name="l04719"></a>04719 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprAlloc {
<a name="l04720"></a>04720     MprHeap         pageHeap;               <span class="comment">/* Page based heap for Arena allocations */</span>
<a name="l04721"></a>04721     <span class="keywordtype">int</span>             inAllocException;       <span class="comment">/* Recursive protect */</span>
<a name="l04722"></a>04722     uint            pageSize;               <span class="comment">/* System page size */</span>
<a name="l04723"></a>04723     uint            errors;                 <span class="comment">/* Allocation errors */</span>
<a name="l04724"></a>04724     uint            numCpu;                 <span class="comment">/* Number of CPUs */</span>
<a name="l04725"></a>04725     int64           bytesAllocated;         <span class="comment">/* Bytes currently allocated */</span>
<a name="l04726"></a>04726     int64           peakAllocated;          <span class="comment">/* Peak bytes allocated */</span>
<a name="l04727"></a>04727     int64           peakStack;              <span class="comment">/* Peak stack usage */</span>
<a name="l04728"></a>04728     int64           redLine;                <span class="comment">/* Warn if allocation exceeds this level */</span>
<a name="l04729"></a>04729     int64           maxMemory;              <span class="comment">/* Max memory to allocate */</span>
<a name="l04730"></a>04730     int64           rss;                    <span class="comment">/* OS calculated resident stack size in bytes */</span>
<a name="l04731"></a>04731     int64           ram;                    <span class="comment">/* System RAM size in bytes */</span>
<a name="l04732"></a>04732     int64           user;                   <span class="comment">/* System user RAM size in bytes (excludes kernel) */</span>
<a name="l04733"></a>04733     <span class="keywordtype">void</span>            *stackStart;            <span class="comment">/* Start of app stack */</span>
<a name="l04734"></a>04734 } MprAlloc;
<a name="l04735"></a>04735 
<a name="l04736"></a>04736 <span class="preprocessor">#if BLD_WIN_LIKE || VXWORKS</span>
<a name="l04737"></a>04737 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_READ        0x1</span>
<a name="l04738"></a>04738 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_WRITE       0x2</span>
<a name="l04739"></a>04739 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_EXECUTE     0x4</span>
<a name="l04740"></a>04740 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l04741"></a>04741 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_READ        PROT_READ</span>
<a name="l04742"></a>04742 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_WRITE       PROT_WRITE</span>
<a name="l04743"></a>04743 <span class="preprocessor"></span><span class="preprocessor">    #define MPR_MAP_EXECUTE     PROT_EXEC</span>
<a name="l04744"></a>04744 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04745"></a>04745 <span class="preprocessor"></span>
<a name="l04746"></a>04746 <span class="keyword">extern</span> <span class="keyword">struct </span>Mpr *mprCreateAllocService(<a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a> cback, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04747"></a>04747 <span class="comment"></span>
<a name="l04748"></a>04748 <span class="comment">/**</span>
<a name="l04749"></a>04749 <span class="comment"> *  Allocate a memory arena</span>
<a name="l04750"></a>04750 <span class="comment"> *  @description Memory arenas are virtual allocations. When subsequent allocations are done via mprAlloc, the memory</span>
<a name="l04751"></a>04751 <span class="comment"> *      will be pinned. On systems without virtual memory, the memory is physically allocated at the time of this call.</span>
<a name="l04752"></a>04752 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04753"></a>04753 <span class="comment"> *  @param name Name to give the arena. Name must be persistent.</span>
<a name="l04754"></a>04754 <span class="comment"> *  @param arenaSize Size of the virtual arena.</span>
<a name="l04755"></a>04755 <span class="comment"> *  @param threadSafe If true, allocations for memory from the arena will be thread safe. Allocations are faster if</span>
<a name="l04756"></a>04756 <span class="comment"> *      threadSafe is false.</span>
<a name="l04757"></a>04757 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04758"></a>04758 <span class="comment"> *  @return Returns a pointer to the reserved arena.</span>
<a name="l04759"></a>04759 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04760"></a>04760 <span class="comment"> */</span>
<a name="l04761"></a>04761 <span class="keyword">extern</span> MprHeap *<a class="code" href="group___mpr_mem.html#g1817af523c1a6f663c792c74190c7ae4" title="Allocate a memory arena.">mprAllocArena</a>(MprCtx ctx, cchar *name, uint arenaSize, <span class="keywordtype">bool</span> threadSafe, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04762"></a>04762 <span class="comment"></span>
<a name="l04763"></a>04763 <span class="comment">/**</span>
<a name="l04764"></a>04764 <span class="comment"> *  Allocate a memory heap</span>
<a name="l04765"></a>04765 <span class="comment"> *  @description Memory heaps map onto the standard system malloc() system.</span>
<a name="l04766"></a>04766 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04767"></a>04767 <span class="comment"> *  @param name Name to give the heap. Name must be persistent.</span>
<a name="l04768"></a>04768 <span class="comment"> *  @param heapSize Size of the memory heap.</span>
<a name="l04769"></a>04769 <span class="comment"> *  @param threadSafe If true, allocations for memory from the heap will be thread safe. Allocations are faster if</span>
<a name="l04770"></a>04770 <span class="comment"> *      threadSafe is false.</span>
<a name="l04771"></a>04771 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04772"></a>04772 <span class="comment"> *  @return Returns a pointer to the reserved heap.</span>
<a name="l04773"></a>04773 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04774"></a>04774 <span class="comment"> */</span>
<a name="l04775"></a>04775 <span class="keyword">extern</span> MprHeap *<a class="code" href="group___mpr_mem.html#g81a5827a39d536c462e9ed1145b50248" title="Allocate a memory heap.">mprAllocHeap</a>(MprCtx ctx, cchar *name, uint heapSize, <span class="keywordtype">bool</span> threadSafe, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04776"></a>04776 <span class="comment"></span>
<a name="l04777"></a>04777 <span class="comment">/**</span>
<a name="l04778"></a>04778 <span class="comment"> *  Allocate a memory slab heap</span>
<a name="l04779"></a>04779 <span class="comment"> *  @description Memory slab heaps are heaps for constant sized object allocations.</span>
<a name="l04780"></a>04780 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04781"></a>04781 <span class="comment"> *  @param name Name to give the heap. Name must be persistent.</span>
<a name="l04782"></a>04782 <span class="comment"> *  @param objSize Size of the virtual heap.</span>
<a name="l04783"></a>04783 <span class="comment"> *  @param count Count of objects in slab</span>
<a name="l04784"></a>04784 <span class="comment"> *  @param threadSafe If true, allocations for memory from the heap will be thread safe. Allocations are faster if</span>
<a name="l04785"></a>04785 <span class="comment"> *      threadSafe is false.</span>
<a name="l04786"></a>04786 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04787"></a>04787 <span class="comment"> *  @return Returns a pointer to the reserved heap.</span>
<a name="l04788"></a>04788 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04789"></a>04789 <span class="comment"> */</span>
<a name="l04790"></a>04790 <span class="keyword">extern</span> MprHeap  *<a class="code" href="group___mpr_mem.html#gb4a28f8d8793b16758bef0cb22acc299" title="Allocate a memory slab heap.">mprAllocSlab</a>(MprCtx ctx, cchar *name, uint objSize, uint count, <span class="keywordtype">bool</span> threadSafe, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04791"></a>04791 <span class="comment"></span>
<a name="l04792"></a>04792 <span class="comment">/**</span>
<a name="l04793"></a>04793 <span class="comment"> *  Define a notifier callback</span>
<a name="l04794"></a>04794 <span class="comment"> *  @description A notifier callback will be invoked for memory allocation errors for the given memory context.</span>
<a name="l04795"></a>04795 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04796"></a>04796 <span class="comment"> *  @param cback Notifier callback function</span>
<a name="l04797"></a>04797 <span class="comment"> */</span>
<a name="l04798"></a>04798 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#468c8ed0890483fb12b7630afcfc72d5" title="Define a notifier callback.">mprSetAllocCallback</a>(MprCtx ctx, <a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a> cback);
<a name="l04799"></a>04799 <span class="comment"></span>
<a name="l04800"></a>04800 <span class="comment">/**</span>
<a name="l04801"></a>04801 <span class="comment"> *  Initialize a block of memory</span>
<a name="l04802"></a>04802 <span class="comment"> *  @description This call initializes a static block of memory so it can be used as a memory context for subseqent</span>
<a name="l04803"></a>04803 <span class="comment"> *      allocations.</span>
<a name="l04804"></a>04804 <span class="comment"> *  @param ptr Pointer to the memory block</span>
<a name="l04805"></a>04805 <span class="comment"> *  @param size Size of the memory block</span>
<a name="l04806"></a>04806 <span class="comment"> */</span>
<a name="l04807"></a>04807 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#b136a423c6fa64f6b9c3b05576ed07ba" title="Initialize a block of memory.">mprInitBlock</a>(<span class="keywordtype">void</span> *ptr, uint size);
<a name="l04808"></a>04808 
<a name="l04809"></a>04809 <span class="preprocessor">#if DOXYGEN</span>
<a name="l04810"></a>04810 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *Type;
<a name="l04811"></a>04811 <span class="comment"></span>
<a name="l04812"></a>04812 <span class="comment">/**</span>
<a name="l04813"></a>04813 <span class="comment"> *  Allocate a block of memory</span>
<a name="l04814"></a>04814 <span class="comment"> *  @description Allocates a block of memory using the supplied memory context \a ctx as the parent. #mprAlloc </span>
<a name="l04815"></a>04815 <span class="comment"> *      manages a tree structure of memory blocks. Freeing a block via mprFree will release the allocated block</span>
<a name="l04816"></a>04816 <span class="comment"> *      and all child blocks.</span>
<a name="l04817"></a>04817 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04818"></a>04818 <span class="comment"> *  @param size Size of the memory block to allocate.</span>
<a name="l04819"></a>04819 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04820"></a>04820 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04821"></a>04821 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04822"></a>04822 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04823"></a>04823 <span class="comment"> */</span>
<a name="l04824"></a>04824 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec" title="Allocate a block of memory.">mprAlloc</a>(MprCtx ctx, uint size);
<a name="l04825"></a>04825 
<a name="l04826"></a>04826 <span class="comment">/* Internal */</span>
<a name="l04827"></a>04827 <span class="keyword">extern</span> <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> *mprAllocBlock(MprHeap *heap, <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> *parent, uint size);
<a name="l04828"></a>04828 <span class="comment"></span>
<a name="l04829"></a>04829 <span class="comment">/**</span>
<a name="l04830"></a>04830 <span class="comment"> *  Allocate an object block of memory</span>
<a name="l04831"></a>04831 <span class="comment"> *  @description Allocates a block of memory using the supplied memory context \a ctx as the parent. #mprAllocWithDestructor</span>
<a name="l04832"></a>04832 <span class="comment"> *      associates a destructor function with an object. This function will be invoked when the object is freed. </span>
<a name="l04833"></a>04833 <span class="comment"> *      Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated </span>
<a name="l04834"></a>04834 <span class="comment"> *      block and all child blocks.</span>
<a name="l04835"></a>04835 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04836"></a>04836 <span class="comment"> *  @param size Size of the memory block to allocate.</span>
<a name="l04837"></a>04837 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04838"></a>04838 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04839"></a>04839 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04840"></a>04840 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04841"></a>04841 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04842"></a>04842 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04843"></a>04843 <span class="comment"> */</span>
<a name="l04844"></a>04844 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def" title="Allocate an object block of memory.">mprAllocWithDestructor</a>(MprCtx ctx, uint size, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04845"></a>04845 <span class="comment"></span>
<a name="l04846"></a>04846 <span class="comment">/**</span>
<a name="l04847"></a>04847 <span class="comment"> *  Allocate an object block of memory and zero it.</span>
<a name="l04848"></a>04848 <span class="comment"> *  @description Allocates a zeroed block of memory using the supplied memory context \a ctx as the parent. </span>
<a name="l04849"></a>04849 <span class="comment">        #mprAllocWithDestructor associates a destructor function with an object. This function will be invoked when the </span>
<a name="l04850"></a>04850 <span class="comment">        object is freed. Freeing a block will first call the destructor and if that returns zero, mprFree will release the </span>
<a name="l04851"></a>04851 <span class="comment">        allocated block and all child blocks.</span>
<a name="l04852"></a>04852 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04853"></a>04853 <span class="comment"> *  @param size Size of the memory block to allocate.</span>
<a name="l04854"></a>04854 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04855"></a>04855 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04856"></a>04856 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04857"></a>04857 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04858"></a>04858 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04859"></a>04859 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04860"></a>04860 <span class="comment"> */</span>
<a name="l04861"></a>04861 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g9765c5e6c3653ed716df99f1eb883fd3" title="Allocate an object block of memory and zero it.">mprAllocWithDestructorZeroed</a>(MprCtx ctx, uint size, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l04862"></a>04862 <span class="comment"></span>
<a name="l04863"></a>04863 <span class="comment">/**</span>
<a name="l04864"></a>04864 <span class="comment"> *  Allocate a zeroed block of memory</span>
<a name="l04865"></a>04865 <span class="comment"> *  @description Allocates a zeroed block of memory using the supplied memory context \a ctx as the parent. #mprAlloc </span>
<a name="l04866"></a>04866 <span class="comment"> *      manages a tree structure of memory blocks. Freeing a block via mprFree will release the allocated block</span>
<a name="l04867"></a>04867 <span class="comment"> *      and all child blocks.</span>
<a name="l04868"></a>04868 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04869"></a>04869 <span class="comment"> *  @param size Size of the memory block to allocate.</span>
<a name="l04870"></a>04870 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04871"></a>04871 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04872"></a>04872 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04873"></a>04873 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04874"></a>04874 <span class="comment"> */</span>
<a name="l04875"></a>04875 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#gb6e0fd9b58e841c28bb49ec2ab37072d" title="Allocate a zeroed block of memory.">mprAllocZeroed</a>(MprCtx ctx, uint size);
<a name="l04876"></a>04876 <span class="comment"></span>
<a name="l04877"></a>04877 <span class="comment">/**</span>
<a name="l04878"></a>04878 <span class="comment"> *  Reallocate a block</span>
<a name="l04879"></a>04879 <span class="comment"> *  @description Reallocates a block increasing its size. If the specified size is less than the current block size,</span>
<a name="l04880"></a>04880 <span class="comment"> *      the call will ignore the request and simply return the existing block.</span>
<a name="l04881"></a>04881 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04882"></a>04882 <span class="comment"> *  @param ptr Memory to reallocate. If NULL, call malloc.</span>
<a name="l04883"></a>04883 <span class="comment"> *  @param size New size of the required memory block.</span>
<a name="l04884"></a>04884 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04885"></a>04885 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04886"></a>04886 <span class="comment"> *  @remarks Do not mix calls to realloc and mprRealloc.</span>
<a name="l04887"></a>04887 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04888"></a>04888 <span class="comment"> */</span>
<a name="l04889"></a>04889 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g3fa0c34d79f33c76f6d6813f0774b8b4" title="Reallocate a block.">mprRealloc</a>(MprCtx ctx, <span class="keywordtype">void</span> *ptr, uint size);
<a name="l04890"></a>04890 <span class="comment"></span>
<a name="l04891"></a>04891 <span class="comment">/**</span>
<a name="l04892"></a>04892 <span class="comment"> *  Allocate an object of a given type</span>
<a name="l04893"></a>04893 <span class="comment"> *  @description Allocates a block of memory large enough to hold an instance of the specified type. This uses the </span>
<a name="l04894"></a>04894 <span class="comment"> *      supplied memory context \a ctx as the parent. This is implemented as a macro</span>
<a name="l04895"></a>04895 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04896"></a>04896 <span class="comment"> *  @param type Type of the object to allocate</span>
<a name="l04897"></a>04897 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04898"></a>04898 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04899"></a>04899 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04900"></a>04900 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04901"></a>04901 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04902"></a>04902 <span class="comment"> */</span>
<a name="l04903"></a><a class="code" href="group___mpr_mem.html#g95dfa054deaafadfbfdb740f0d7d97c3">04903</a> <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g95dfa054deaafadfbfdb740f0d7d97c3" title="Allocate an object of a given type.">mprAllocObj</a>(MprCtx ctx, Type type) { <span class="keywordflow">return</span> 0; }
<a name="l04904"></a>04904 <span class="comment"></span>
<a name="l04905"></a>04905 <span class="comment">/**</span>
<a name="l04906"></a>04906 <span class="comment"> *  Allocate a zeroed object of a given type</span>
<a name="l04907"></a>04907 <span class="comment"> *  @description Allocates a zeroed block of memory large enough to hold an instance of the specified type. This uses the </span>
<a name="l04908"></a>04908 <span class="comment"> *      supplied memory context \a ctx as the parent. This is implemented as a macro</span>
<a name="l04909"></a>04909 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04910"></a>04910 <span class="comment"> *  @param type Type of the object to allocate</span>
<a name="l04911"></a>04911 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04912"></a>04912 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04913"></a>04913 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04914"></a>04914 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04915"></a>04915 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04916"></a>04916 <span class="comment"> */</span>
<a name="l04917"></a><a class="code" href="group___mpr_mem.html#g4681a304da368211a957c3d7f40c107e">04917</a> <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#g4681a304da368211a957c3d7f40c107e" title="Allocate a zeroed object of a given type.">mprAllocObjZeroed</a>(MprCtx ctx, Type type) { <span class="keywordflow">return</span> 0; }
<a name="l04918"></a>04918 <span class="comment"></span>
<a name="l04919"></a>04919 <span class="comment">/**</span>
<a name="l04920"></a>04920 <span class="comment"> *  Allocate an object of a given type with a destructor</span>
<a name="l04921"></a>04921 <span class="comment"> *  @description Allocates a block of memory large enough to hold an instance of the specified type with a destructor. </span>
<a name="l04922"></a>04922 <span class="comment"> *      This uses the supplied memory context \a ctx as the parent. This is implemented as a macro.</span>
<a name="l04923"></a>04923 <span class="comment"> *      this call associates a destructor function with an object. This function will be invoked when the object is freed. </span>
<a name="l04924"></a>04924 <span class="comment"> *      Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated </span>
<a name="l04925"></a>04925 <span class="comment"> *      block and all child blocks.</span>
<a name="l04926"></a>04926 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04927"></a>04927 <span class="comment"> *  @param type Type of the object to allocate</span>
<a name="l04928"></a>04928 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04929"></a>04929 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04930"></a>04930 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04931"></a>04931 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04932"></a>04932 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04933"></a>04933 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04934"></a>04934 <span class="comment"> */</span>
<a name="l04935"></a>04935 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#gb61e0804fdc8e8398bacd18e06ed0b2e" title="Allocate an object of a given type with a destructor.">mprAllocObjWithDestructor</a>(MprCtx ctx, Type type, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor)
<a name="l04936"></a>04936 
<a name="l04937"></a>04937 <span class="comment">/**</span>
<a name="l04938"></a>04938 <span class="comment"> *  Allocate a zeroed object of a given type with a destructor</span>
<a name="l04939"></a>04939 <span class="comment"> *  @description Allocates a zeroed block of memory large enough to hold an instance of the specified type with a </span>
<a name="l04940"></a>04940 <span class="comment"> *      destructor. This uses the supplied memory context \a ctx as the parent. This is implemented as a macro.</span>
<a name="l04941"></a>04941 <span class="comment"> *      this call associates a destructor function with an object. This function will be invoked when the object is freed. </span>
<a name="l04942"></a>04942 <span class="comment"> *      Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated </span>
<a name="l04943"></a>04943 <span class="comment"> *      block and all child blocks.</span>
<a name="l04944"></a>04944 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04945"></a>04945 <span class="comment"> *  @param type Type of the object to allocate</span>
<a name="l04946"></a>04946 <span class="comment"> *  @param destructor Destructor function to invoke when the allocation is freed via #mprFree.</span>
<a name="l04947"></a>04947 <span class="comment"> *  @return Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler </span>
<a name="l04948"></a>04948 <span class="comment"> *      specified via mprCreate will be called to allow global recovery.</span>
<a name="l04949"></a>04949 <span class="comment"> *  @remarks Do not mix calls to malloc and mprAlloc.</span>
<a name="l04950"></a>04950 <span class="comment"> *  @stability Prototype. This function names are highly likely to be refactored.</span>
<a name="l04951"></a>04951 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04952"></a>04952 <span class="comment"> */</span>
<a name="l04953"></a>04953 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mprAllocObjWithDestructorZeroed(MprCtx ctx, Type type, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor) { <span class="keywordflow">return</span> 0;}
<a name="l04954"></a>04954 <span class="comment"></span>
<a name="l04955"></a>04955 <span class="comment">/**</span>
<a name="l04956"></a>04956 <span class="comment"> *  Duplicate a block of memory.</span>
<a name="l04957"></a>04957 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04958"></a>04958 <span class="comment"> *  @description Copy a block of memory into a newly allocated block.</span>
<a name="l04959"></a>04959 <span class="comment"> *  @param ptr Pointer to the block to duplicate.</span>
<a name="l04960"></a>04960 <span class="comment"> *  @param size Size of the block to copy.</span>
<a name="l04961"></a>04961 <span class="comment"> *  @return Returns an allocated block. Caller must free via #mprFree.</span>
<a name="l04962"></a>04962 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04963"></a>04963 <span class="comment"> */</span>
<a name="l04964"></a>04964 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mprMemdup(MprCtx ctx, cvoid *ptr, uint size);
<a name="l04965"></a>04965 <span class="comment"></span>
<a name="l04966"></a>04966 <span class="comment">/**</span>
<a name="l04967"></a>04967 <span class="comment"> *  Duplicate a string.</span>
<a name="l04968"></a>04968 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04969"></a>04969 <span class="comment"> *  @description Copy a string into a newly allocated block. The new block will be sized to the maximum of the </span>
<a name="l04970"></a>04970 <span class="comment"> *      length of the existing string (plus a null) and the requested size.</span>
<a name="l04971"></a>04971 <span class="comment"> *  @param str Pointer to the block to duplicate.</span>
<a name="l04972"></a>04972 <span class="comment"> *  @param size Requested minimum size of the allocated block holding the duplicated string.</span>
<a name="l04973"></a>04973 <span class="comment"> *  @return Returns an allocated block. Caller must free via #mprFree.</span>
<a name="l04974"></a>04974 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04975"></a>04975 <span class="comment"> */</span>
<a name="l04976"></a>04976 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_mem.html#g857ed05b61f4112d319fe75545d0a081" title="Duplicate a string.">mprStrndup</a>(MprCtx ctx, cchar *str, uint size);
<a name="l04977"></a>04977 <span class="comment"></span>
<a name="l04978"></a>04978 <span class="comment">/**</span>
<a name="l04979"></a>04979 <span class="comment"> *  Safe replacement for strdup</span>
<a name="l04980"></a>04980 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l04981"></a>04981 <span class="comment"> *  @description mprStrdup() should be used as a replacement for \b strdup wherever possible. It allows the </span>
<a name="l04982"></a>04982 <span class="comment"> *      strdup to be copied to be NULL, in which case it will allocate an empty string. </span>
<a name="l04983"></a>04983 <span class="comment"> *  @param str Pointer to string to duplicate. If \b str is NULL, allocate a new string containing only a </span>
<a name="l04984"></a>04984 <span class="comment"> *      trailing NULL character.</span>
<a name="l04985"></a>04985 <span class="comment"> *  @return Returns an allocated string including trailing null.</span>
<a name="l04986"></a>04986 <span class="comment"> *  @remarks Memory allocated via mprStrdup() must be freed via mprFree().</span>
<a name="l04987"></a>04987 <span class="comment"> *  @ingroup MprMem</span>
<a name="l04988"></a>04988 <span class="comment"> */</span>
<a name="l04989"></a>04989 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86" title="Safe replacement for strdup.">mprStrdup</a>(MprCtx ctx, cchar *str);
<a name="l04990"></a>04990 
<a name="l04991"></a>04991 <span class="preprocessor">#else </span><span class="comment">/* !DOXYGEN */</span>
<a name="l04992"></a>04992 
<a name="l04993"></a>04993 
<a name="l04994"></a>04994 <span class="preprocessor">#if BLD_DEBUG</span>
<a name="l04995"></a>04995 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l04996"></a>04996 <span class="comment"> *  Set a static debug name for the memory object</span>
<a name="l04997"></a>04997 <span class="comment"> *  @param ptr The memory object</span>
<a name="l04998"></a>04998 <span class="comment"> *  @param name Static memory name. Must be persistant.</span>
<a name="l04999"></a>04999 <span class="comment"> *  @returns the memory object so this call can be chained.</span>
<a name="l05000"></a>05000 <span class="comment"> */</span>
<a name="l05001"></a>05001 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mprSetName(<span class="keywordtype">void</span> *ptr, cchar *name);
<a name="l05002"></a>05002 <span class="comment"></span>
<a name="l05003"></a>05003 <span class="comment">/**</span>
<a name="l05004"></a>05004 <span class="comment"> *  Set a dynamic debug name for the memory object</span>
<a name="l05005"></a>05005 <span class="comment"> *  @param ptr The memory object</span>
<a name="l05006"></a>05006 <span class="comment"> *  @param name Memory name. This call will duplicate the name so the name may be transient.</span>
<a name="l05007"></a>05007 <span class="comment"> *  @returns the memory object so this call can be chained.</span>
<a name="l05008"></a>05008 <span class="comment"> */</span>
<a name="l05009"></a>05009 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mprSetDynamicName(<span class="keywordtype">void</span> *ptr, cchar *name);
<a name="l05010"></a>05010 
<a name="l05011"></a>05011 <span class="comment">/*</span>
<a name="l05012"></a>05012 <span class="comment"> *  Get the debug memory name for a memory object</span>
<a name="l05013"></a>05013 <span class="comment"> *  @returns the debug name</span>
<a name="l05014"></a>05014 <span class="comment"> */</span>
<a name="l05015"></a>05015 <span class="keyword">extern</span> cchar *mprGetName(<span class="keywordtype">void</span> *ptr);
<a name="l05016"></a>05016 <span class="preprocessor">#else</span>
<a name="l05017"></a>05017 <span class="preprocessor"></span><span class="preprocessor">#define mprSetName(ptr, name) ptr</span>
<a name="l05018"></a>05018 <span class="preprocessor"></span><span class="preprocessor">#define mprSetDynamicName(ptr, name) ptr</span>
<a name="l05019"></a>05019 <span class="preprocessor"></span><span class="preprocessor">#define mprGetName(ptr) ""</span>
<a name="l05020"></a>05020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l05021"></a>05021 <span class="preprocessor"></span>
<a name="l05022"></a>05022 <span class="comment">/*</span>
<a name="l05023"></a>05023 <span class="comment"> *  Internal memory allocation routines</span>
<a name="l05024"></a>05024 <span class="comment"> */</span>
<a name="l05025"></a>05025 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprAlloc(MprCtx ctx, uint size);
<a name="l05026"></a>05026 <span class="keyword">extern</span> <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> *_mprAllocBlock(MprHeap *heap, <a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> *parent, uint size);
<a name="l05027"></a>05027 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprAllocWithDestructor(MprCtx ctx, uint size, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l05028"></a>05028 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprAllocWithDestructorZeroed(MprCtx ctx, uint size, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l05029"></a>05029 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprAllocZeroed(MprCtx ctx, uint size);
<a name="l05030"></a>05030 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprRealloc(MprCtx ctx, <span class="keywordtype">void</span> *ptr, uint size);
<a name="l05031"></a>05031 <span class="keyword">extern</span> <span class="keywordtype">void</span> *_mprMemdup(MprCtx ctx, cvoid *ptr, uint size);
<a name="l05032"></a>05032 <span class="keyword">extern</span> <span class="keywordtype">char</span> *_mprStrndup(MprCtx ctx, cchar *str, uint size);
<a name="l05033"></a>05033 <span class="keyword">extern</span> <span class="keywordtype">char</span> *_mprStrdup(MprCtx ctx, cchar *str);
<a name="l05034"></a>05034 
<a name="l05035"></a>05035 <span class="comment">/*</span>
<a name="l05036"></a>05036 <span class="comment"> *  Macros for typed based allocations</span>
<a name="l05037"></a>05037 <span class="comment"> */</span>
<a name="l05038"></a>05038 <span class="preprocessor">#define mprAllocObj(ctx, type) \</span>
<a name="l05039"></a>05039 <span class="preprocessor">    ((type*) mprSetName(_mprAlloc(ctx, sizeof(type)), MPR_LOC))</span>
<a name="l05040"></a>05040 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocObjZeroed(ctx, type) \</span>
<a name="l05041"></a>05041 <span class="preprocessor">    ((type*) mprSetName(_mprAllocZeroed(ctx, sizeof(type)), MPR_LOC))</span>
<a name="l05042"></a>05042 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocObjWithDestructor(ctx, type, destructor) \</span>
<a name="l05043"></a>05043 <span class="preprocessor">    ((type*) mprSetName(_mprAllocWithDestructor(ctx, sizeof(type), (MprDestructor) destructor), MPR_LOC))</span>
<a name="l05044"></a>05044 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocObjWithDestructorZeroed(ctx, type, destructor) \</span>
<a name="l05045"></a>05045 <span class="preprocessor">    ((type*) mprSetName(_mprAllocWithDestructorZeroed(ctx, sizeof(type), (MprDestructor) destructor), MPR_LOC))</span>
<a name="l05046"></a>05046 <span class="preprocessor"></span>
<a name="l05047"></a>05047 <span class="preprocessor">#define mprAlloc(ctx, size) \</span>
<a name="l05048"></a>05048 <span class="preprocessor">    mprSetName(_mprAlloc(ctx, size), MPR_LOC)</span>
<a name="l05049"></a>05049 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocBlock(heap, parent, size) \</span>
<a name="l05050"></a>05050 <span class="preprocessor">    mprSetName(_mprAllocBlock(heap, parent, size), MPR_LOC)</span>
<a name="l05051"></a>05051 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocWithDestructor(ctx, size, destructor) \</span>
<a name="l05052"></a>05052 <span class="preprocessor">    mprSetName(_mprAllocWithDestructor(ctx, size, destructor), MPR_LOC)</span>
<a name="l05053"></a>05053 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocWithDestructorZeroed(ctx, size, destructor) \</span>
<a name="l05054"></a>05054 <span class="preprocessor">    mprSetName(_mprAllocWithDestructorZeroed(ctx, size, destructor), MPR_LOC)</span>
<a name="l05055"></a>05055 <span class="preprocessor"></span><span class="preprocessor">#define mprAllocZeroed(ctx, size) \</span>
<a name="l05056"></a>05056 <span class="preprocessor">    mprSetName(_mprAllocZeroed(ctx, size), MPR_LOC)</span>
<a name="l05057"></a>05057 <span class="preprocessor"></span><span class="preprocessor">#define mprRealloc(ctx, ptr, size) \</span>
<a name="l05058"></a>05058 <span class="preprocessor">    mprSetName(_mprRealloc(ctx, ptr, size), MPR_LOC)</span>
<a name="l05059"></a>05059 <span class="preprocessor"></span><span class="preprocessor">#define mprMemdup(ctx, ptr, size) \</span>
<a name="l05060"></a>05060 <span class="preprocessor">    mprSetName(_mprMemdup(ctx, ptr, size), MPR_LOC)</span>
<a name="l05061"></a>05061 <span class="preprocessor"></span><span class="preprocessor">#define mprStrndup(ctx, str, size) \</span>
<a name="l05062"></a>05062 <span class="preprocessor">    mprSetName(_mprStrndup(ctx, str, size), MPR_LOC)</span>
<a name="l05063"></a>05063 <span class="preprocessor"></span><span class="preprocessor">#define mprStrdup(ctx, str) \</span>
<a name="l05064"></a>05064 <span class="preprocessor">    mprSetName(_mprStrdup(ctx, str), MPR_LOC)</span>
<a name="l05065"></a>05065 <span class="preprocessor"></span>
<a name="l05066"></a>05066 <span class="keyword">extern</span> MprHeap *mprGetHeap(<a class="code" href="struct_mpr_blk.html" title="Memory Allocation Block Header.">MprBlk</a> *bp);
<a name="l05067"></a>05067 <span class="preprocessor">#endif</span>
<a name="l05068"></a>05068 <span class="preprocessor"></span><span class="comment"></span>
<a name="l05069"></a>05069 <span class="comment">/**</span>
<a name="l05070"></a>05070 <span class="comment"> *  Format a string into an allocated buffer.</span>
<a name="l05071"></a>05071 <span class="comment"> *  @description This call will dynamically allocate a buffer up to the specified maximum size and will format the </span>
<a name="l05072"></a>05072 <span class="comment"> *      supplied arguments into the buffer.  A trailing null will always be appended. The call returns</span>
<a name="l05073"></a>05073 <span class="comment"> *      the size of the allocated string excluding the null.</span>
<a name="l05074"></a>05074 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05075"></a>05075 <span class="comment"> *  @param maxSize Maximum size to allocate for the buffer including the trailing null.</span>
<a name="l05076"></a>05076 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l05077"></a>05077 <span class="comment"> *  @return Returns the number of characters in the string.</span>
<a name="l05078"></a>05078 <span class="comment"> *  @ingroup MprString</span>
<a name="l05079"></a>05079 <span class="comment"> */</span>
<a name="l05080"></a>05080 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#47b6a089018e38316476e97b49bb8d82" title="Format a string into an allocated buffer.">mprAsprintf</a>(MprCtx ctx, <span class="keywordtype">int</span> maxSize, cchar *fmt, ...);
<a name="l05081"></a>05081 <span class="comment"></span>
<a name="l05082"></a>05082 <span class="comment">/**</span>
<a name="l05083"></a>05083 <span class="comment"> *  Allocate a buffer of sufficient length to hold the formatted string.</span>
<a name="l05084"></a>05084 <span class="comment"> *  @description This call will dynamically allocate a buffer up to the specified maximum size and will format </span>
<a name="l05085"></a>05085 <span class="comment"> *      the supplied arguments into the buffer. A trailing null will always be appended. The call returns</span>
<a name="l05086"></a>05086 <span class="comment"> *      the size of the allocated string excluding the null.</span>
<a name="l05087"></a>05087 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05088"></a>05088 <span class="comment"> *  @param maxSize Maximum size to allocate for the buffer including the trailing null.</span>
<a name="l05089"></a>05089 <span class="comment"> *  @param fmt Printf style format string</span>
<a name="l05090"></a>05090 <span class="comment"> *  @param arg Varargs argument obtained from va_start.</span>
<a name="l05091"></a>05091 <span class="comment"> *  @return Returns the number of characters in the string.</span>
<a name="l05092"></a>05092 <span class="comment"> *  @ingroup MprString</span>
<a name="l05093"></a>05093 <span class="comment"> */</span>
<a name="l05094"></a>05094 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#bd8e3ce747235f08bf1fca492a653f9b" title="Allocate a buffer of sufficient length to hold the formatted string.">mprVasprintf</a>(MprCtx ctx, <span class="keywordtype">int</span> maxSize, cchar *fmt, va_list arg);
<a name="l05095"></a>05095 <span class="comment"></span>
<a name="l05096"></a>05096 <span class="comment">/**</span>
<a name="l05097"></a>05097 <span class="comment"> *  Append strings to an existing string and reallocate as required.</span>
<a name="l05098"></a>05098 <span class="comment"> *  @description Append a list of strings to an existing string. The list of strings is terminated by a </span>
<a name="l05099"></a>05099 <span class="comment"> *      null argument. The call returns the size of the allocated block. </span>
<a name="l05100"></a>05100 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05101"></a>05101 <span class="comment"> *  @param max Maximum size of the result string.</span>
<a name="l05102"></a>05102 <span class="comment"> *  @param buf Existing string to reallocate. May be null.</span>
<a name="l05103"></a>05103 <span class="comment"> *  @param src Variable list of strings to append. The final string argument must be null.</span>
<a name="l05104"></a>05104 <span class="comment"> *  @return An allocated result string. Caller must free.</span>
<a name="l05105"></a>05105 <span class="comment"> *  @ingroup MprString</span>
<a name="l05106"></a>05106 <span class="comment"> */</span>
<a name="l05107"></a>05107 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#2493bcee3c3b7f8351e16c731dd401f6" title="Append strings to an existing string and reallocate as required.">mprReallocStrcat</a>(MprCtx ctx, <span class="keywordtype">int</span> max, <span class="keywordtype">char</span> *buf, cchar *src, ...);
<a name="l05108"></a>05108 <span class="comment"></span>
<a name="l05109"></a>05109 <span class="comment">/**</span>
<a name="l05110"></a>05110 <span class="comment"> *  Free a block of memory.</span>
<a name="l05111"></a>05111 <span class="comment"> *  @description mprFree should be used to free memory allocated by mprAlloc, or mprRealloc. This call will ignore</span>
<a name="l05112"></a>05112 <span class="comment"> *      calls to free a null pointer, thus it is an acceptable idiom to free a pointer without testing its value for null.</span>
<a name="l05113"></a>05113 <span class="comment"> *      When mprFree is called it will first invoke any object destructor function for the allocated block. If this</span>
<a name="l05114"></a>05114 <span class="comment"> *      destructor returns zero, it will then proceed and free all allocated children before finally releasing the block.</span>
<a name="l05115"></a>05115 <span class="comment"> *  @param ptr Memory to free. If NULL, take no action.</span>
<a name="l05116"></a>05116 <span class="comment"> *  @return Returns zero if the block was actually freed. If the destructor prevented the freeing, a non-zero value will</span>
<a name="l05117"></a>05117 <span class="comment"> *      be returned. </span>
<a name="l05118"></a>05118 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05119"></a>05119 <span class="comment"> */</span>
<a name="l05120"></a>05120 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>(<span class="keywordtype">void</span> *ptr);
<a name="l05121"></a>05121 <span class="comment"></span>
<a name="l05122"></a>05122 <span class="comment">/**</span>
<a name="l05123"></a>05123 <span class="comment"> *  Update the destructor for a block of memory.</span>
<a name="l05124"></a>05124 <span class="comment"> *  @description This call updates the destructor for a block of memory allocated via mprAllocWithDestructor.</span>
<a name="l05125"></a>05125 <span class="comment"> *  @param ptr Memory to free. If NULL, take no action.</span>
<a name="l05126"></a>05126 <span class="comment"> *  @param destructor Destructor function to invoke when #mprFree is called.</span>
<a name="l05127"></a>05127 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05128"></a>05128 <span class="comment"> */</span>
<a name="l05129"></a>05129 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_mem.html#gdeb570e7b9f2ee67eef01e574baaecb4" title="Update the destructor for a block of memory.">mprSetDestructor</a>(<span class="keywordtype">void</span> *ptr, <a class="code" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663" title="Mpr memory block destructors prototype.">MprDestructor</a> destructor);
<a name="l05130"></a>05130 <span class="comment"></span>
<a name="l05131"></a>05131 <span class="comment">/**</span>
<a name="l05132"></a>05132 <span class="comment"> *  Free all the children blocks allocated of a block</span>
<a name="l05133"></a>05133 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05134"></a>05134 <span class="comment"> */</span>
<a name="l05135"></a>05135 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#1d03816923ffb4392c095869ac37d0c0" title="Free all the children blocks allocated of a block.">mprFreeChildren</a>(MprCtx ctx);
<a name="l05136"></a>05136 <span class="comment"></span>
<a name="l05137"></a>05137 <span class="comment">/**</span>
<a name="l05138"></a>05138 <span class="comment"> *  Reassign a block from its current parent context to a new context.</span>
<a name="l05139"></a>05139 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate. This will be the new owning context of the ptr.</span>
<a name="l05140"></a>05140 <span class="comment"> *  @param ptr Pointer to a block to reassign.</span>
<a name="l05141"></a>05141 <span class="comment"> */</span>
<a name="l05142"></a>05142 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#0174635f1fe63aac33da9554b476c3f2" title="Reassign a block from its current parent context to a new context.">mprStealBlock</a>(MprCtx ctx, cvoid *ptr);
<a name="l05143"></a>05143 <span class="comment"></span>
<a name="l05144"></a>05144 <span class="comment">/**</span>
<a name="l05145"></a>05145 <span class="comment"> *  Reparent a block</span>
<a name="l05146"></a>05146 <span class="comment"> *  @description Moves a block from one memory context to another within a single memory heap or arena. This call</span>
<a name="l05147"></a>05147 <span class="comment"> *      is fast and is not thread-safe.</span>
<a name="l05148"></a>05148 <span class="comment"> *  @param ctx New memory context for the block. Any memory context allocated by the MPR.</span>
<a name="l05149"></a>05149 <span class="comment"> *  @param ptr Pointer to memory block.</span>
<a name="l05150"></a>05150 <span class="comment"> */</span>
<a name="l05151"></a>05151 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#1f9db7dccdae9651f616f3e0740d6c81" title="Reparent a block.">mprReparent</a>(MprCtx ctx, cvoid *ptr);
<a name="l05152"></a>05152 <span class="comment"></span>
<a name="l05153"></a>05153 <span class="comment">/**</span>
<a name="l05154"></a>05154 <span class="comment"> *  Validate a memory block and issue asserts if the memory block or any children blocks do not validate</span>
<a name="l05155"></a>05155 <span class="comment"> *  @param ctx New memory context for the block. Any memory context allocated by the MPR.</span>
<a name="l05156"></a>05156 <span class="comment"> */</span>
<a name="l05157"></a>05157 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#d5c8927e1a2c78d302726c41cd6da6cd" title="Validate a memory block and issue asserts if the memory block or any children blocks...">mprValidateBlock</a>(MprCtx ctx);
<a name="l05158"></a>05158 <span class="comment"></span>
<a name="l05159"></a>05159 <span class="comment">/**</span>
<a name="l05160"></a>05160 <span class="comment"> *  Print a memory usage report to stdout</span>
<a name="l05161"></a>05161 <span class="comment"> *  @param ctx New memory context for the block. Any memory context allocated by the MPR.</span>
<a name="l05162"></a>05162 <span class="comment"> *  @param msg Prefix message to the report</span>
<a name="l05163"></a>05163 <span class="comment"> */</span>
<a name="l05164"></a>05164 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#3413b2b0b86894f0ca40efa0f7156bea" title="Print a memory usage report to stdout.">mprPrintAllocReport</a>(MprCtx ctx, cchar *msg);
<a name="l05165"></a>05165 <span class="comment"></span>
<a name="l05166"></a>05166 <span class="comment">/**</span>
<a name="l05167"></a>05167 <span class="comment"> *  Determine if the MPR has encountered memory allocation errors.</span>
<a name="l05168"></a>05168 <span class="comment"> *  @description Returns true if the MPR has had a memory allocation error. Allocation errors occur if any</span>
<a name="l05169"></a>05169 <span class="comment"> *      memory allocation would cause the application to exceed the configured redline limit, or if any O/S memory</span>
<a name="l05170"></a>05170 <span class="comment"> *      allocation request fails.</span>
<a name="l05171"></a>05171 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05172"></a>05172 <span class="comment"> *  @return TRUE if a memory allocation error has occurred. Otherwise returns FALSE.</span>
<a name="l05173"></a>05173 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05174"></a>05174 <span class="comment"> */</span>
<a name="l05175"></a>05175 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_mem.html#g46b725c5e3a7818e3051401b016f7902" title="Determine if the MPR has encountered memory allocation errors.">mprHasAllocError</a>(MprCtx ctx);
<a name="l05176"></a>05176 <span class="comment"></span>
<a name="l05177"></a>05177 <span class="comment">/**</span>
<a name="l05178"></a>05178 <span class="comment"> *  Reset the memory allocation error flag</span>
<a name="l05179"></a>05179 <span class="comment"> *  @description Reset the alloc error flag triggered.</span>
<a name="l05180"></a>05180 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05181"></a>05181 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05182"></a>05182 <span class="comment"> */</span>
<a name="l05183"></a>05183 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_mem.html#g8a1a2ca6fb1f9e1cd45660ba1004e9a2" title="Reset the memory allocation error flag.">mprResetAllocError</a>(MprCtx ctx);
<a name="l05184"></a>05184 <span class="comment"></span>
<a name="l05185"></a>05185 <span class="comment">/**</span>
<a name="l05186"></a>05186 <span class="comment"> *  Set an memory allocation error condition on a memory context. This will set an allocation error condition on the</span>
<a name="l05187"></a>05187 <span class="comment"> *  given context and all its parents. This way, you can test the ultimate parent and detect if any memory allocation</span>
<a name="l05188"></a>05188 <span class="comment"> *  errors have occurred.</span>
<a name="l05189"></a>05189 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l05190"></a>05190 <span class="comment"> */</span>
<a name="l05191"></a>05191 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#5afb03370eb13fda6f023dc6d928b477" title="Set an memory allocation error condition on a memory context.">mprSetAllocError</a>(MprCtx ctx);
<a name="l05192"></a>05192 <span class="comment"></span>
<a name="l05193"></a>05193 <span class="comment">/**</span>
<a name="l05194"></a>05194 <span class="comment"> *  Get the memory parent of a block.</span>
<a name="l05195"></a>05195 <span class="comment"> *  @description Return the parent memory context for a block</span>
<a name="l05196"></a>05196 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05197"></a>05197 <span class="comment"> *  @return Return the memory owning this block</span>
<a name="l05198"></a>05198 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05199"></a>05199 <span class="comment"> */</span>
<a name="l05200"></a>05200 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="group___mpr_mem.html#ga2917f1fe62535e7f18549bad3c87c3f" title="Get the memory parent of a block.">mprGetParent</a>(MprCtx ctx);
<a name="l05201"></a>05201 <span class="comment"></span>
<a name="l05202"></a>05202 <span class="comment">/**</span>
<a name="l05203"></a>05203 <span class="comment"> *  Test is a pointer is a valid memory context. This is used to test if a block has been dynamically allocated.</span>
<a name="l05204"></a>05204 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05205"></a>05205 <span class="comment"> */</span>
<a name="l05206"></a>05206 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#eb1d9013dbfca5d9080b881e0fde2cde" title="Test is a pointer is a valid memory context.">mprIsValid</a>(MprCtx ctx);
<a name="l05207"></a>05207 <span class="comment"></span>
<a name="l05208"></a>05208 <span class="comment">/**</span>
<a name="l05209"></a>05209 <span class="comment"> *  Monitory stack usage and check if the stack has grown since last monitoring.</span>
<a name="l05210"></a>05210 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05211"></a>05211 <span class="comment"> *  @returns true if the stack has grown</span>
<a name="l05212"></a>05212 <span class="comment"> */</span>
<a name="l05213"></a>05213 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="mpr_8h.html#efdcc565b19075801a65604d388715d0" title="Monitory stack usage and check if the stack has grown since last monitoring.">mprStackCheck</a>(MprCtx ctx);
<a name="l05214"></a>05214 <span class="comment"></span>
<a name="l05215"></a>05215 <span class="comment">/**</span>
<a name="l05216"></a>05216 <span class="comment"> *  Configure the application memory limits</span>
<a name="l05217"></a>05217 <span class="comment"> *  @description Configure memory limits to constrain memory usage by the application. The memory allocation subsystem</span>
<a name="l05218"></a>05218 <span class="comment"> *      will check these limits before granting memory allocation requrests. The redLine is a soft limit that if exceeded</span>
<a name="l05219"></a>05219 <span class="comment"> *      will invoke the memory allocation callback, but will still honor the request. The maxMemory limit is a hard limit.</span>
<a name="l05220"></a>05220 <span class="comment"> *      The MPR will prevent allocations which exceed this maximum. The memory callback handler is defined via </span>
<a name="l05221"></a>05221 <span class="comment"> *      the #mprCreate call.</span>
<a name="l05222"></a>05222 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05223"></a>05223 <span class="comment"> *  @param redline Soft memory limit. If exceeded, the request will be granted, but the memory handler will be invoked.</span>
<a name="l05224"></a>05224 <span class="comment"> *  @param maxMemory Hard memory limit. If exceeded, the request will not be granted, and the memory handler will be invoked.</span>
<a name="l05225"></a>05225 <span class="comment"> *  @ingroup MprMem</span>
<a name="l05226"></a>05226 <span class="comment"> */</span>
<a name="l05227"></a>05227 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_mem.html#g1aba81525e6f3570db267f1a71c96d1d" title="Configure the application memory limits.">mprSetAllocLimits</a>(MprCtx ctx, uint redline, uint maxMemory);
<a name="l05228"></a>05228 <span class="comment"></span>
<a name="l05229"></a>05229 <span class="comment">/**</span>
<a name="l05230"></a>05230 <span class="comment"> *  Return the current allocation memory statistics block</span>
<a name="l05231"></a>05231 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05232"></a>05232 <span class="comment"> *  @returns a reference to the allocation memory statistics. Do not modify its contents.</span>
<a name="l05233"></a>05233 <span class="comment"> */</span>
<a name="l05234"></a>05234 <span class="keyword">extern</span> MprAlloc *<a class="code" href="mpr_8h.html#c1c737cca87de821e71f45c89b965365" title="Return the current allocation memory statistics block.">mprGetAllocStats</a>(MprCtx ctx);
<a name="l05235"></a>05235 <span class="comment"></span>
<a name="l05236"></a>05236 <span class="comment">/**</span>
<a name="l05237"></a>05237 <span class="comment"> *  Return the amount of memory currently used by the application. This only reports heap memory.</span>
<a name="l05238"></a>05238 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05239"></a>05239 <span class="comment"> *  @returns the amount of heap memory used by the application in bytes.</span>
<a name="l05240"></a>05240 <span class="comment"> */</span>
<a name="l05241"></a>05241 <span class="keyword">extern</span> int64 <a class="code" href="mpr_8h.html#a071656602927b54f839595f162336a9" title="Return the amount of memory currently used by the application.">mprGetUsedMemory</a>(MprCtx ctx);
<a name="l05242"></a>05242 <span class="comment"></span>
<a name="l05243"></a>05243 <span class="comment">/**</span>
<a name="l05244"></a>05244 <span class="comment"> *  Memory virtual memory into the applications address space.</span>
<a name="l05245"></a>05245 <span class="comment"> *  @param size of virtual memory to map. This size will be rounded up to the nearest page boundary.</span>
<a name="l05246"></a>05246 <span class="comment"> *  @param mode Mask set to MPR_MAP_READ | MPR_MAP_WRITE</span>
<a name="l05247"></a>05247 <span class="comment"> */</span>
<a name="l05248"></a>05248 <span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code" href="mpr_8h.html#6d8444f927dac1b01ccb48450c2cb0d1" title="Memory virtual memory into the applications address space.">mprMapAlloc</a>(uint size, <span class="keywordtype">int</span> mode);
<a name="l05249"></a>05249 <span class="comment"></span>
<a name="l05250"></a>05250 <span class="comment">/**</span>
<a name="l05251"></a>05251 <span class="comment"> *  Free (unpin) a mapped section of virtual memory</span>
<a name="l05252"></a>05252 <span class="comment"> *  @param ptr Virtual address to free. Should be page aligned</span>
<a name="l05253"></a>05253 <span class="comment"> *  @param size Size of memory to free in bytes</span>
<a name="l05254"></a>05254 <span class="comment"> */</span>
<a name="l05255"></a>05255 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#2c5d14b85515f1d8155856285e50611f" title="Free (unpin) a mapped section of virtual memory.">mprMapFree</a>(<span class="keywordtype">void</span> *ptr, uint size);
<a name="l05256"></a>05256 <span class="comment"></span>
<a name="l05257"></a>05257 <span class="comment">/**</span>
<a name="l05258"></a>05258 <span class="comment"> *  Get the current O/S virtual page size</span>
<a name="l05259"></a>05259 <span class="comment"> *  @param ctx Any memory context allocated by mprAlloc or mprCreate.</span>
<a name="l05260"></a>05260 <span class="comment"> *  @returns the page size in bytes</span>
<a name="l05261"></a>05261 <span class="comment"> */</span>
<a name="l05262"></a>05262 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#144c637773024a22bbc1be9a257555ef" title="Get the current O/S virtual page size.">mprGetPageSize</a>(MprCtx ctx);
<a name="l05263"></a>05263 
<a name="l05264"></a>05264 <span class="comment">/*</span>
<a name="l05265"></a>05265 <span class="comment"> *  Wait service.</span>
<a name="l05266"></a>05266 <span class="comment"> */</span>
<a name="l05267"></a>05267 
<a name="l05268"></a>05268 <span class="preprocessor">#define MPR_READABLE           0x2          </span><span class="comment">/* Read event mask */</span>
<a name="l05269"></a>05269 <span class="preprocessor">#define MPR_WRITABLE           0x4          </span><span class="comment">/* Write event mask */</span>
<a name="l05270"></a>05270 
<a name="l05271"></a>05271 <span class="preprocessor">#define MPR_READ_PIPE          0            </span><span class="comment">/* Read side */</span>
<a name="l05272"></a>05272 <span class="preprocessor">#define MPR_WRITE_PIPE         1            </span><span class="comment">/* Write side */</span>
<a name="l05273"></a>05273 
<a name="l05274"></a>05274 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l05275"></a>05275 <span class="preprocessor"></span><span class="keyword">typedef</span> long (*MprMsgCallback)(HWND hwnd, uint msg, uint wp, <span class="keywordtype">long</span> lp);
<a name="l05276"></a>05276 <span class="preprocessor">#endif</span>
<a name="l05277"></a>05277 <span class="preprocessor"></span>
<a name="l05278"></a>05278 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprWaitService {
<a name="l05279"></a>05279     MprList         *handlers;              <span class="comment">/* List of handlers */</span>
<a name="l05280"></a>05280     <span class="keywordtype">int</span>             needRecall;             <span class="comment">/* A handler needs a recall due to buffered data */</span>
<a name="l05281"></a>05281     <span class="keywordtype">int</span>             wakeRequested;          <span class="comment">/* Wakeup of the wait service has been requested (only multithreaded) */</span>
<a name="l05282"></a>05282 <span class="preprocessor">#if MPR_EVENT_EPOLL</span>
<a name="l05283"></a>05283 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             epoll;                  <span class="comment">/* Kqueue() return descriptor */</span>
<a name="l05284"></a>05284     <span class="keyword">struct </span>epoll_event *events;                <span class="comment">/* Events triggered */</span>
<a name="l05285"></a>05285     <span class="keywordtype">int</span>             eventsMax;              <span class="comment">/* Max size of events/interest */</span>
<a name="l05286"></a>05286     <span class="keyword">struct </span>MprWaitHandler **handlerMap;     <span class="comment">/* Map of fds to handlers */</span>
<a name="l05287"></a>05287     <span class="keywordtype">int</span>             handlerMax;             <span class="comment">/* Size of the handlers array */</span>
<a name="l05288"></a>05288     <span class="keywordtype">int</span>             breakPipe[2];           <span class="comment">/* Pipe to wakeup select when multithreaded */</span>
<a name="l05289"></a>05289 <span class="preprocessor">#elif MPR_EVENT_KQUEUE</span>
<a name="l05290"></a>05290 <span class="preprocessor"></span>    <span class="keywordtype">int</span>             kq;                     <span class="comment">/* Kqueue() return descriptor */</span>
<a name="l05291"></a>05291     <span class="keyword">struct </span>kevent   *interest;              <span class="comment">/* Events of interest */</span>
<a name="l05292"></a>05292     <span class="keywordtype">int</span>             interestMax;            <span class="comment">/* Size of the interest array */</span>
<a name="l05293"></a>05293     <span class="keywordtype">int</span>             interestCount;          <span class="comment">/* Last used entry in the interest array */</span>
<a name="l05294"></a>05294     <span class="keyword">struct </span>kevent   *stableInterest;        <span class="comment">/* Stable copy of interest during kevent() */</span>
<a name="l05295"></a>05295     <span class="keywordtype">int</span>             stableInterestCount;    <span class="comment">/* Last used entry in the stableInterest array */</span>
<a name="l05296"></a>05296     <span class="keyword">struct </span>kevent   *events;                <span class="comment">/* Events triggered */</span>
<a name="l05297"></a>05297     <span class="keywordtype">int</span>             eventsMax;              <span class="comment">/* Max size of events/interest */</span>
<a name="l05298"></a>05298     <span class="keyword">struct </span>MprWaitHandler **handlerMap;     <span class="comment">/* Map of fds to handlers */</span>
<a name="l05299"></a>05299     <span class="keywordtype">int</span>             handlerMax;             <span class="comment">/* Size of the handlers array */</span>
<a name="l05300"></a>05300     <span class="keywordtype">int</span>             breakPipe[2];           <span class="comment">/* Pipe to wakeup select when multithreaded */</span>
<a name="l05301"></a>05301 <span class="preprocessor">#elif MPR_EVENT_POLL</span>
<a name="l05302"></a>05302 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprWaitHandler **handlerMap;     <span class="comment">/* Map of fds to handlers (indexed by fd) */</span>
<a name="l05303"></a>05303     <span class="keywordtype">int</span>             handlerMax;             <span class="comment">/* Size of the handlers array */</span>
<a name="l05304"></a>05304     <span class="keyword">struct </span>pollfd   *fds;                   <span class="comment">/* File descriptors to select on (linear index) */</span>
<a name="l05305"></a>05305     <span class="keywordtype">int</span>             fdsCount;               <span class="comment">/* Last used entry in the fds array */</span>
<a name="l05306"></a>05306     <span class="keywordtype">int</span>             fdMax;                  <span class="comment">/* Size of the fds array */</span>
<a name="l05307"></a>05307     <span class="keyword">struct </span>pollfd   *stableFds;             <span class="comment">/* Stable copy of fds used when polling */</span>
<a name="l05308"></a>05308     <span class="keywordtype">int</span>             stableFdsCount;         <span class="comment">/* Last used entry in the stableFds array */</span>
<a name="l05309"></a>05309     <span class="keywordtype">int</span>             breakPipe[2];           <span class="comment">/* Pipe to wakeup select when multithreaded */</span>
<a name="l05310"></a>05310 <span class="preprocessor">#elif MPR_EVENT_ASYNC</span>
<a name="l05311"></a>05311 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprWaitHandler **handlerMap;     <span class="comment">/* Map of fds to handlers */</span>
<a name="l05312"></a>05312     <span class="keywordtype">int</span>             handlerMax;             <span class="comment">/* Size of the handlers array */</span>
<a name="l05313"></a>05313     <span class="keywordtype">int</span>             nfd;                    <span class="comment">/* Last used entry in the handlerMap array */</span>
<a name="l05314"></a>05314     <span class="keywordtype">int</span>             fdmax;                  <span class="comment">/* Size of the fds array */</span>
<a name="l05315"></a>05315     HWND            hwnd;                   <span class="comment">/* Window handle */</span>
<a name="l05316"></a>05316     <span class="keywordtype">int</span>             socketMessage;          <span class="comment">/* Message id for socket events */</span>
<a name="l05317"></a>05317     MprMsgCallback  msgCallback;            <span class="comment">/* Message handler callback */</span>
<a name="l05318"></a>05318 <span class="preprocessor">#elif MPR_EVENT_SELECT</span>
<a name="l05319"></a>05319 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprWaitHandler **handlerMap;     <span class="comment">/* Map of fds to handlers */</span>
<a name="l05320"></a>05320     <span class="keywordtype">int</span>             handlerMax;             <span class="comment">/* Size of the handlers array */</span>
<a name="l05321"></a>05321     fd_set          readMask;               <span class="comment">/* Current read events mask */</span>
<a name="l05322"></a>05322     fd_set          writeMask;              <span class="comment">/* Current write events mask */</span>
<a name="l05323"></a>05323     fd_set          stableReadMask;         <span class="comment">/* Read events mask used for select() */</span>
<a name="l05324"></a>05324     fd_set          stableWriteMask;        <span class="comment">/* Write events mask used for select() */</span>
<a name="l05325"></a>05325     <span class="keywordtype">int</span>             highestFd;              <span class="comment">/* Highest socket in masks + 1 */</span>
<a name="l05326"></a>05326     <span class="keywordtype">int</span>             breakSock;              <span class="comment">/* Socket to wakeup select when multithreaded */</span>
<a name="l05327"></a>05327     <span class="keyword">struct </span>sockaddr_in breakAddress;        <span class="comment">/* Address of wakeup socket */</span>
<a name="l05328"></a>05328 <span class="preprocessor">#endif </span><span class="comment">/* EVENT_SELECT */</span>
<a name="l05329"></a>05329 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05330"></a>05330 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;                 <span class="comment">/* General multi-thread sync */</span>
<a name="l05331"></a>05331     <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a>         *spin;                  <span class="comment">/* Fast short locking */</span>
<a name="l05332"></a>05332 <span class="preprocessor">#endif</span>
<a name="l05333"></a>05333 <span class="preprocessor"></span>} MprWaitService;
<a name="l05334"></a>05334 
<a name="l05335"></a>05335 
<a name="l05336"></a>05336 <span class="keyword">extern</span> MprWaitService *mprCreateWaitService(<span class="keyword">struct</span> Mpr *mpr);
<a name="l05337"></a>05337 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprTermOsWait(MprWaitService *ws);
<a name="l05338"></a>05338 <span class="keyword">extern</span> <span class="keywordtype">int</span>  mprStartWaitService(MprWaitService *ws);
<a name="l05339"></a>05339 <span class="keyword">extern</span> <span class="keywordtype">int</span>  mprStopWaitService(MprWaitService *ws);
<a name="l05340"></a>05340 
<a name="l05341"></a>05341 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l05342"></a>05342 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span>  mprInitWindow(MprWaitService *ws);
<a name="l05343"></a>05343 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetWinMsgCallback(MprWaitService *ws, MprMsgCallback callback);
<a name="l05344"></a>05344 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprServiceWinIO(MprWaitService *ws, <span class="keywordtype">int</span> sockFd, <span class="keywordtype">int</span> winMask);
<a name="l05345"></a>05345 <span class="preprocessor">#endif</span>
<a name="l05346"></a>05346 <span class="preprocessor"></span>
<a name="l05347"></a>05347 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05348"></a>05348 <span class="preprocessor"></span>    <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetWaitServiceThread(MprWaitService *ws, MprThread *thread);
<a name="l05349"></a>05349     <span class="keyword">extern</span> <span class="keywordtype">void</span> mprWakeWaitService(MprCtx ctx);
<a name="l05350"></a>05350     <span class="keyword">extern</span> <span class="keywordtype">void</span> mprWakeNotifier(MprCtx ctx);
<a name="l05351"></a>05351 <span class="preprocessor">#else</span>
<a name="l05352"></a>05352 <span class="preprocessor"></span><span class="preprocessor">    #define mprWakeWaitService(ws)</span>
<a name="l05353"></a>05353 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l05354"></a>05354 <span class="preprocessor"></span><span class="comment"></span>
<a name="l05355"></a>05355 <span class="comment">/**</span>
<a name="l05356"></a>05356 <span class="comment"> *  Wait for I/O on a file descriptor. No processing of the I/O event is done.</span>
<a name="l05357"></a>05357 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05358"></a>05358 <span class="comment"> *  @param fd File descriptor to examine</span>
<a name="l05359"></a>05359 <span class="comment"> *  @param mask Mask of events of interest (MPR_READABLE | MPR_WRITABLE)</span>
<a name="l05360"></a>05360 <span class="comment"> *  @param timeout Timeout in milliseconds to wait for an event.</span>
<a name="l05361"></a>05361 <span class="comment"> *  @returns A count of events received.</span>
<a name="l05362"></a>05362 <span class="comment"> */</span>
<a name="l05363"></a>05363 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#f1b9807f41341d92c190f8ae71390e78" title="Wait for I/O on a file descriptor.">mprWaitForSingleIO</a>(MprCtx ctx, <span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> mask, <span class="keywordtype">int</span> timeout);
<a name="l05364"></a>05364 <span class="comment"></span>
<a name="l05365"></a>05365 <span class="comment">/**</span>
<a name="l05366"></a>05366 <span class="comment"> *  Wait for I/O. This call waits for any I/O events on wait handlers until the given timeout expires.</span>
<a name="l05367"></a>05367 <span class="comment"> *  @param ws Wait service object</span>
<a name="l05368"></a>05368 <span class="comment"> *  @param timeout Timeout in milliseconds to wait for an event.</span>
<a name="l05369"></a>05369 <span class="comment"> *  @returns A count of events received.</span>
<a name="l05370"></a>05370 <span class="comment"> */</span>
<a name="l05371"></a>05371 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#aabd29f554c4fa6b528f5c9587a7adb4" title="Wait for I/O.">mprWaitForIO</a>(MprWaitService *ws, <span class="keywordtype">int</span> timeout);
<a name="l05372"></a>05372 
<a name="l05373"></a>05373 <span class="comment">/*</span>
<a name="l05374"></a>05374 <span class="comment"> *  Handler Flags</span>
<a name="l05375"></a>05375 <span class="comment"> */</span>
<a name="l05376"></a>05376 <span class="preprocessor">#define MPR_WAIT_RECALL_HANDLER 0x1     </span><span class="comment">/* Must recall the handler asap */</span>
<a name="l05377"></a>05377 <span class="comment"></span>
<a name="l05378"></a>05378 <span class="comment">/**</span>
<a name="l05379"></a>05379 <span class="comment"> *  Wait Handler Service</span>
<a name="l05380"></a>05380 <span class="comment"> *  @description Wait handlers provide callbacks for when I/O events occur. They provide a wait to service many</span>
<a name="l05381"></a>05381 <span class="comment"> *      I/O file descriptors without requiring a thread per descriptor.</span>
<a name="l05382"></a>05382 <span class="comment"> *  @see mprDisableWaitEvents, mprEnableWaitEvents,</span>
<a name="l05383"></a>05383 <span class="comment"> *      mprRecallWaitHandler, MprWaitHandler, mprCreateEvent, mprServiceDispatcher, MprEvent</span>
<a name="l05384"></a>05384 <span class="comment"> *  @defgroup MprWaitHandler MprWaitHandler</span>
<a name="l05385"></a>05385 <span class="comment"> */</span>
<a name="l05386"></a>05386 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprWaitHandler {
<a name="l05387"></a>05387     <span class="keywordtype">int</span>             desiredMask;        <span class="comment">/**&lt; Mask of desired events */</span>
<a name="l05388"></a>05388     <span class="keywordtype">int</span>             presentMask;        <span class="comment">/**&lt; Mask of current events */</span>
<a name="l05389"></a>05389     <span class="keywordtype">int</span>             fd;                 <span class="comment">/**&lt; O/S File descriptor (sp-&gt;sock) */</span>
<a name="l05390"></a>05390     <span class="keywordtype">int</span>             notifierIndex;      <span class="comment">/**&lt; Index for notifier */</span>
<a name="l05391"></a>05391     <span class="keywordtype">int</span>             flags;              <span class="comment">/**&lt; Control flags */</span>
<a name="l05392"></a>05392     <span class="keywordtype">void</span>            *handlerData;       <span class="comment">/**&lt; Argument to pass to proc */</span>
<a name="l05393"></a>05393     MprEvent        event;              <span class="comment">/**&lt; Inline event object to process I/O events */</span>
<a name="l05394"></a>05394     MprWaitService  *service;           <span class="comment">/**&lt; Wait service pointer */</span>
<a name="l05395"></a>05395     MprDispatcher   *dispatcher;        <span class="comment">/**&lt; Event dispatcher to use for I/O events */</span>
<a name="l05396"></a>05396     <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a>    proc;               <span class="comment">/**&lt; Callback event procedure */</span>
<a name="l05397"></a>05397     <span class="keyword">struct </span>MprWaitHandler *next;        <span class="comment">/**&lt; List linkage */</span>
<a name="l05398"></a>05398     <span class="keyword">struct </span>MprWaitHandler *prev;
<a name="l05399"></a>05399 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05400"></a>05400 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprWorker *requiredWorker;   <span class="comment">/**&lt; Designate the required worker thread to run the callback */</span>
<a name="l05401"></a>05401     <span class="keyword">struct </span>MprThread *thread;           <span class="comment">/**&lt; Thread executing the callback, set even if worker is null */</span>
<a name="l05402"></a>05402     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *callbackComplete;  <span class="comment">/**&lt; Signalled when a callback is complete */</span>
<a name="l05403"></a>05403 <span class="preprocessor">#endif</span>
<a name="l05404"></a>05404 <span class="preprocessor"></span>} MprWaitHandler;
<a name="l05405"></a>05405 
<a name="l05406"></a>05406 <span class="comment"></span>
<a name="l05407"></a>05407 <span class="comment">/**</span>
<a name="l05408"></a>05408 <span class="comment"> *  Create a wait handler</span>
<a name="l05409"></a>05409 <span class="comment"> *  @description Create a wait handler that will be invoked when I/O of interest occurs on the specified file handle</span>
<a name="l05410"></a>05410 <span class="comment"> *      The wait handler is registered with the MPR event I/O mechanism.</span>
<a name="l05411"></a>05411 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05412"></a>05412 <span class="comment"> *  @param fd File descriptor</span>
<a name="l05413"></a>05413 <span class="comment"> *  @param mask Mask of events of interest. This is made by oring MPR_READABLE and MPR_WRITABLE</span>
<a name="l05414"></a>05414 <span class="comment"> *  @param dispatcher Dispatcher object to use for scheduling the I/O event.</span>
<a name="l05415"></a>05415 <span class="comment"> *  @param proc Callback function to invoke when an I/O event of interest has occurred.</span>
<a name="l05416"></a>05416 <span class="comment"> *  @param data Data item to pass to the callback</span>
<a name="l05417"></a>05417 <span class="comment"> *  @returns A new wait handler registered with the MPR event mechanism</span>
<a name="l05418"></a>05418 <span class="comment"> *  @ingroup MprWaitHandler</span>
<a name="l05419"></a>05419 <span class="comment"> */</span>
<a name="l05420"></a>05420 <span class="keyword">extern</span> MprWaitHandler *<a class="code" href="group___mpr_wait_handler.html#gcc222183cbeb335191a334899b5635bd" title="Create a wait handler.">mprCreateWaitHandler</a>(MprCtx ctx, <span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> mask, MprDispatcher *dispatcher, <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, 
<a name="l05421"></a>05421     <span class="keywordtype">void</span> *data);
<a name="l05422"></a>05422 <span class="comment"></span>
<a name="l05423"></a>05423 <span class="comment">/**</span>
<a name="l05424"></a>05424 <span class="comment"> *  Statically initialize a wait handler</span>
<a name="l05425"></a>05425 <span class="comment"> *  @description Initialize a wait handler that will be invoked when I/O of interest occurs on the specified file handle</span>
<a name="l05426"></a>05426 <span class="comment"> *      The wait handler is registered with the MPR event I/O mechanism.</span>
<a name="l05427"></a>05427 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05428"></a>05428 <span class="comment"> *  @param wp Wait handler structure to initialize</span>
<a name="l05429"></a>05429 <span class="comment"> *  @param fd File descriptor</span>
<a name="l05430"></a>05430 <span class="comment"> *  @param mask Mask of events of interest. This is made by oring MPR_READABLE and MPR_WRITABLE</span>
<a name="l05431"></a>05431 <span class="comment"> *  @param dispatcher Dispatcher object to use for scheduling the I/O event.</span>
<a name="l05432"></a>05432 <span class="comment"> *  @param proc Callback function to invoke when an I/O event of interest has occurred.</span>
<a name="l05433"></a>05433 <span class="comment"> *  @param data Data item to pass to the callback</span>
<a name="l05434"></a>05434 <span class="comment"> *  @returns A new wait handler registered with the MPR event mechanism</span>
<a name="l05435"></a>05435 <span class="comment"> *  @ingroup MprWaitHandler</span>
<a name="l05436"></a>05436 <span class="comment"> */</span>
<a name="l05437"></a>05437 <span class="keyword">extern</span> MprWaitHandler *<a class="code" href="group___mpr_wait_handler.html#g4aba5720db6c4d68637f34019eea4559" title="Statically initialize a wait handler.">mprInitWaitHandler</a>(MprCtx ctx, MprWaitHandler *wp, <span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> mask, MprDispatcher *dispatcher, 
<a name="l05438"></a>05438         <a class="code" href="group___mpr_event.html#g6777c813e9ab55b0e29dfa9d0d19f32b" title="Event callback function.">MprEventProc</a> proc, <span class="keywordtype">void</span> *data);
<a name="l05439"></a>05439 <span class="comment"></span>
<a name="l05440"></a>05440 <span class="comment">/**</span>
<a name="l05441"></a>05441 <span class="comment"> *  Disconnect a wait handler from its underlying file descriptor. This is used to prevent further I/O wait events while</span>
<a name="l05442"></a>05442 <span class="comment"> *  still preserving the wait handler.</span>
<a name="l05443"></a>05443 <span class="comment"> *  @param wp Wait handler object</span>
<a name="l05444"></a>05444 <span class="comment"> */</span>
<a name="l05445"></a>05445 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#a7e94f04dd2634590ebf35d099bc3c63" title="Disconnect a wait handler from its underlying file descriptor.">mprRemoveWaitHandler</a>(MprWaitHandler *wp);
<a name="l05446"></a>05446 <span class="comment"></span>
<a name="l05447"></a>05447 <span class="comment">/**</span>
<a name="l05448"></a>05448 <span class="comment"> *  Disable wait events</span>
<a name="l05449"></a>05449 <span class="comment"> *  @description Disable wait events for a given file descriptor.</span>
<a name="l05450"></a>05450 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05451"></a>05451 <span class="comment"> *  @ingroup MprWaitHandler</span>
<a name="l05452"></a>05452 <span class="comment"> */</span>
<a name="l05453"></a>05453 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_wait_handler.html#gdb816527b96de477a69bb9e99098c9cf" title="Disable wait events.">mprDisableWaitEvents</a>(MprWaitHandler *wp);
<a name="l05454"></a>05454 <span class="comment"></span>
<a name="l05455"></a>05455 <span class="comment">/**</span>
<a name="l05456"></a>05456 <span class="comment"> *  Enable wait events</span>
<a name="l05457"></a>05457 <span class="comment"> *  @description Enable wait events for a given file descriptor.</span>
<a name="l05458"></a>05458 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05459"></a>05459 <span class="comment"> *  @param desiredMask Mask of desirable events (MPR_READABLE | MPR_WRITABLE)</span>
<a name="l05460"></a>05460 <span class="comment"> *  @ingroup MprWaitHandler</span>
<a name="l05461"></a>05461 <span class="comment"> */</span>
<a name="l05462"></a>05462 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_wait_handler.html#g3a2dba730e20be0baf6166050ac947d4" title="Enable wait events.">mprEnableWaitEvents</a>(MprWaitHandler *wp, <span class="keywordtype">int</span> desiredMask);
<a name="l05463"></a>05463 <span class="comment"></span>
<a name="l05464"></a>05464 <span class="comment">/**</span>
<a name="l05465"></a>05465 <span class="comment"> *  Recall a wait handler</span>
<a name="l05466"></a>05466 <span class="comment"> *  @description Signal that a wait handler should be recalled at the earliest opportunity. This is useful</span>
<a name="l05467"></a>05467 <span class="comment"> *      when a protocol stack has buffered data that must be processed regardless of whether more I/O occurs. </span>
<a name="l05468"></a>05468 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05469"></a>05469 <span class="comment"> *  @param fd File descriptor to recall</span>
<a name="l05470"></a>05470 <span class="comment"> *  @ingroup MprWaitHandler</span>
<a name="l05471"></a>05471 <span class="comment"> */</span>
<a name="l05472"></a>05472 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_wait_handler.html#gd95b0d5c47ddbc6f5219a4a2c0678ab9" title="Recall a wait handler.">mprRecallWaitHandler</a>(MprCtx ctx, <span class="keywordtype">int</span> fd);
<a name="l05473"></a>05473 <span class="comment"></span>
<a name="l05474"></a>05474 <span class="comment">/**</span>
<a name="l05475"></a>05475 <span class="comment"> *  Apply wait handler updates. While a wait handler is in use, wait event updates are buffered. This routine applies</span>
<a name="l05476"></a>05476 <span class="comment"> *      such buffered updates.</span>
<a name="l05477"></a>05477 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05478"></a>05478 <span class="comment"> *  @param wakeup Wake up the service events thread. Typically it is safest to wake up the service events thread if the</span>
<a name="l05479"></a>05479 <span class="comment"> *      wait handler event masks have been modified. However, there are some cases where it can be useful to suppress</span>
<a name="l05480"></a>05480 <span class="comment"> *      this behavior.</span>
<a name="l05481"></a>05481 <span class="comment"> */</span>
<a name="l05482"></a>05482 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#64b669a1f52e62b8010fe14094db885b" title="Apply wait handler updates.">mprUpdateWaitHandler</a>(MprWaitHandler *wp, <span class="keywordtype">bool</span> wakeup);
<a name="l05483"></a>05483 <span class="comment"></span>
<a name="l05484"></a>05484 <span class="comment">/**</span>
<a name="l05485"></a>05485 <span class="comment"> *  Queue an IO event for dispatch on the wait handler dispatcher</span>
<a name="l05486"></a>05486 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05487"></a>05487 <span class="comment"> */</span>
<a name="l05488"></a>05488 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#52f88939c5c03270beff007574b4aeb0" title="Queue an IO event for dispatch on the wait handler dispatcher.">mprQueueIOEvent</a>(MprWaitHandler *wp);
<a name="l05489"></a>05489 
<a name="l05490"></a>05490 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05491"></a>05491 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l05492"></a>05492 <span class="comment"> *  Dedicate a worker thread to a wait handler. This implements thread affinity and is required on some platforms</span>
<a name="l05493"></a>05493 <span class="comment"> *      where some APIs (waitpid on uClibc) cannot be called on a different thread.</span>
<a name="l05494"></a>05494 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05495"></a>05495 <span class="comment"> *  @param worker Worker thread reference</span>
<a name="l05496"></a>05496 <span class="comment"> */</span>
<a name="l05497"></a>05497 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#f738be140726725efc160324b0d209e8" title="Dedicate a worker thread to a wait handler.">mprDedicateWorkerToHandler</a>(MprWaitHandler *wp, <span class="keyword">struct</span> MprWorker *worker);
<a name="l05498"></a>05498 <span class="comment"></span>
<a name="l05499"></a>05499 <span class="comment">/**</span>
<a name="l05500"></a>05500 <span class="comment"> *  Release a worker thread. This releases a worker thread to be assignable to any other wait handler.</span>
<a name="l05501"></a>05501 <span class="comment"> *  @param wp Wait handler created via #mprCreateWaitHandler</span>
<a name="l05502"></a>05502 <span class="comment"> *  @param worker Worker thread reference</span>
<a name="l05503"></a>05503 <span class="comment"> */</span>
<a name="l05504"></a>05504 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#e0e96f55e5ae3bd167e1b51f563e580d" title="Release a worker thread.">mprReleaseWorkerFromHandler</a>(MprWaitHandler *wp, <span class="keyword">struct</span> MprWorker *worker);
<a name="l05505"></a>05505 <span class="preprocessor">#endif</span>
<a name="l05506"></a>05506 <span class="preprocessor"></span>
<a name="l05507"></a>05507 <span class="comment">/*</span>
<a name="l05508"></a>05508 <span class="comment"> *  This is an internal API</span>
<a name="l05509"></a>05509 <span class="comment"> */</span>
<a name="l05510"></a>05510 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprCreateNotifierService(MprWaitService *ws);
<a name="l05511"></a>05511 
<a name="l05512"></a>05512 <span class="comment">/*</span>
<a name="l05513"></a>05513 <span class="comment"> *  Begin I/O notification services on a wait handler</span>
<a name="l05514"></a>05514 <span class="comment"> *  @param wp Wait handler associated with the file descriptor</span>
<a name="l05515"></a>05515 <span class="comment"> *  @param mask Mask of events of interest. This is made by oring MPR_READABLE and MPR_WRITABLE</span>
<a name="l05516"></a>05516 <span class="comment"> *  @return Zero if successful, otherwise a negative MPR error code.</span>
<a name="l05517"></a>05517 <span class="comment"> */</span>
<a name="l05518"></a>05518 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprAddNotifier(MprWaitService *ws, MprWaitHandler *wp, <span class="keywordtype">int</span> mask);
<a name="l05519"></a>05519 
<a name="l05520"></a>05520 <span class="comment">/*</span>
<a name="l05521"></a>05521 <span class="comment"> *  Suspend I/O notification services on a wait handler</span>
<a name="l05522"></a>05522 <span class="comment"> *  Remove a file descriptor from the wait service</span>
<a name="l05523"></a>05523 <span class="comment"> *  @param wp Wait handler associated with the file descriptor</span>
<a name="l05524"></a>05524 <span class="comment"> */</span>
<a name="l05525"></a>05525 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprRemoveNotifier(MprWaitHandler *wp);
<a name="l05526"></a>05526 <span class="comment"></span>
<a name="l05527"></a>05527 <span class="comment">/**</span>
<a name="l05528"></a>05528 <span class="comment"> *  Socket I/O callback procedure. Proc returns non-zero if the socket has been deleted.</span>
<a name="l05529"></a>05529 <span class="comment"> */</span>
<a name="l05530"></a><a class="code" href="mpr_8h.html#86674106f5fcb47ba730f66375407e0a">05530</a> <span class="keyword">typedef</span> int (*<a class="code" href="mpr_8h.html#86674106f5fcb47ba730f66375407e0a" title="Socket I/O callback procedure.">MprSocketProc</a>)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> mask);
<a name="l05531"></a>05531 
<a name="l05532"></a>05532 <span class="comment">/*</span>
<a name="l05533"></a>05533 <span class="comment"> *  Socket service provider interface.</span>
<a name="l05534"></a>05534 <span class="comment"> */</span>
<a name="l05535"></a>05535 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprSocketProvider {
<a name="l05536"></a>05536     cchar           *name;
<a name="l05537"></a>05537 <span class="preprocessor">#if BLD_FEATURE_SSL</span>
<a name="l05538"></a>05538 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprSsl   *defaultSsl;
<a name="l05539"></a>05539 <span class="preprocessor">#endif</span>
<a name="l05540"></a>05540 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprSocket *(*acceptSocket)(<span class="keyword">struct </span>MprSocket *sp);
<a name="l05541"></a>05541     void            (*closeSocket)(<span class="keyword">struct </span>MprSocket *socket, <span class="keywordtype">bool</span> gracefully);
<a name="l05542"></a>05542     int             (*configureSsl)(<span class="keyword">struct </span>MprSsl *ssl);
<a name="l05543"></a>05543     int             (*connectSocket)(<span class="keyword">struct </span>MprSocket *socket, cchar *host, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> flags);
<a name="l05544"></a>05544     <span class="keyword">struct </span>MprSocket *(*createSocket)(MprCtx ctx, <span class="keyword">struct </span>MprSsl *ssl);
<a name="l05545"></a>05545     void            (*disconnectSocket)(<span class="keyword">struct </span>MprSocket *socket);
<a name="l05546"></a>05546     int             (*flushSocket)(<span class="keyword">struct </span>MprSocket *socket);
<a name="l05547"></a>05547     int             (*listenSocket)(<span class="keyword">struct </span>MprSocket *socket, cchar *host, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> flags);
<a name="l05548"></a>05548     int             (*readSocket)(<span class="keyword">struct </span>MprSocket *socket, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len);
<a name="l05549"></a>05549     int             (*writeSocket)(<span class="keyword">struct </span>MprSocket *socket, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len);
<a name="l05550"></a>05550 } MprSocketProvider;
<a name="l05551"></a>05551 
<a name="l05552"></a>05552 
<a name="l05553"></a>05553 <span class="comment">/*</span>
<a name="l05554"></a>05554 <span class="comment"> *  Mpr socket service class</span>
<a name="l05555"></a>05555 <span class="comment"> */</span>
<a name="l05556"></a>05556 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprSocketService {
<a name="l05557"></a>05557     MprList         *connections;
<a name="l05558"></a>05558     <span class="keywordtype">int</span>             maxClients;                 <span class="comment">/* Maximum client side sockets */</span>
<a name="l05559"></a>05559     <span class="keywordtype">int</span>             numClients;                 <span class="comment">/* Count of client side sockets */</span>
<a name="l05560"></a>05560     <span class="keywordtype">int</span>             next;
<a name="l05561"></a>05561 
<a name="l05562"></a>05562     MprSocketProvider *standardProvider;
<a name="l05563"></a>05563     MprSocketProvider *secureProvider;
<a name="l05564"></a>05564 
<a name="l05565"></a>05565 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05566"></a>05566 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;
<a name="l05567"></a>05567 <span class="preprocessor">#endif</span>
<a name="l05568"></a>05568 <span class="preprocessor"></span>} MprSocketService;
<a name="l05569"></a>05569 
<a name="l05570"></a>05570 
<a name="l05571"></a>05571 <span class="keyword">extern</span> MprSocketService *mprCreateSocketService(MprCtx ctx);
<a name="l05572"></a>05572 <span class="keyword">extern</span> <span class="keywordtype">int</span>  mprStartSocketService(MprSocketService *ss);
<a name="l05573"></a>05573 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprStopSocketService(MprSocketService *ss);
<a name="l05574"></a>05574 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprSetSecureProvider(MprCtx ctx, MprSocketProvider *provider);
<a name="l05575"></a>05575 <span class="comment"></span>
<a name="l05576"></a>05576 <span class="comment">/**</span>
<a name="l05577"></a>05577 <span class="comment"> *  Determine if SSL is available</span>
<a name="l05578"></a>05578 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05579"></a>05579 <span class="comment"> *  @returns True if SSL is available</span>
<a name="l05580"></a>05580 <span class="comment"> */</span>
<a name="l05581"></a>05581 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="mpr_8h.html#634f21ee23b89c3612785f8a59d27103" title="Determine if SSL is available.">mprHasSecureSockets</a>(MprCtx ctx);
<a name="l05582"></a>05582 <span class="comment"></span>
<a name="l05583"></a>05583 <span class="comment">/**</span>
<a name="l05584"></a>05584 <span class="comment"> *  Set the maximum number of client sockets that are permissable</span>
<a name="l05585"></a>05585 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05586"></a>05586 <span class="comment"> *  @param max New maximum number of client sockets.</span>
<a name="l05587"></a>05587 <span class="comment"> */</span>
<a name="l05588"></a>05588 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#c6a350c9fbbcd569b8c265b9c65845cd" title="Set the maximum number of client sockets that are permissable.">mprSetMaxSocketClients</a>(MprCtx ctx, <span class="keywordtype">int</span> max);
<a name="l05589"></a>05589 
<a name="l05590"></a>05590 <span class="comment">/*</span>
<a name="l05591"></a>05591 <span class="comment"> *  Socket close flags</span>
<a name="l05592"></a>05592 <span class="comment"> */</span>
<a name="l05593"></a>05593 <span class="preprocessor">#define MPR_SOCKET_GRACEFUL     1           </span><span class="comment">/* Do a graceful shutdown */</span>
<a name="l05594"></a>05594 
<a name="l05595"></a>05595 <span class="comment">/*</span>
<a name="l05596"></a>05596 <span class="comment"> *  Socket event types</span>
<a name="l05597"></a>05597 <span class="comment"> */</span>
<a name="l05598"></a>05598 <span class="preprocessor">#define MPR_SOCKET_READABLE     MPR_READABLE</span>
<a name="l05599"></a>05599 <span class="preprocessor"></span><span class="preprocessor">#define MPR_SOCKET_WRITABLE     MPR_WRITABLE</span>
<a name="l05600"></a>05600 <span class="preprocessor"></span>
<a name="l05601"></a>05601 <span class="comment">/*</span>
<a name="l05602"></a>05602 <span class="comment"> *  Socket Flags</span>
<a name="l05603"></a>05603 <span class="comment"> */</span>
<a name="l05604"></a><a class="code" href="mpr_8h.html#a26b2bbf78247ef8fd3528aabea7aa32">05604</a> <span class="preprocessor">#define MPR_SOCKET_BLOCK        0x1         </span><span class="comment">/**&lt; Use blocking I/O */</span>
<a name="l05605"></a><a class="code" href="mpr_8h.html#99a15ede7932c340743a75f118ca16c6">05605</a> <span class="preprocessor">#define MPR_SOCKET_BROADCAST    0x2         </span><span class="comment">/**&lt; Broadcast mode */</span>
<a name="l05606"></a><a class="code" href="mpr_8h.html#9899fbaf22958ef4d2fbb5bce6cbb898">05606</a> <span class="preprocessor">#define MPR_SOCKET_CLOSED       0x4         </span><span class="comment">/**&lt; MprSocket has been closed */</span>
<a name="l05607"></a><a class="code" href="mpr_8h.html#d5e870cae7f4f67d9d9da412128ee8f1">05607</a> <span class="preprocessor">#define MPR_SOCKET_CONNECTING   0x8         </span><span class="comment">/**&lt; MprSocket has been closed */</span>
<a name="l05608"></a><a class="code" href="mpr_8h.html#3af7ac22e43b6d66754503bf4b038823">05608</a> <span class="preprocessor">#define MPR_SOCKET_DATAGRAM     0x10        </span><span class="comment">/**&lt; Use datagrams */</span>
<a name="l05609"></a><a class="code" href="mpr_8h.html#84190073ab879726ad4f3c97206fd01b">05609</a> <span class="preprocessor">#define MPR_SOCKET_EOF          0x20        </span><span class="comment">/**&lt; Seen end of file */</span>
<a name="l05610"></a><a class="code" href="mpr_8h.html#0dcff326be6be22f7382a95cf01fcc15">05610</a> <span class="preprocessor">#define MPR_SOCKET_LISTENER     0x40        </span><span class="comment">/**&lt; MprSocket is server listener */</span>
<a name="l05611"></a><a class="code" href="mpr_8h.html#83a3df553a14edcbf46c671097860f20">05611</a> <span class="preprocessor">#define MPR_SOCKET_NOREUSE      0x80        </span><span class="comment">/**&lt; Dont set SO_REUSEADDR option */</span>
<a name="l05612"></a><a class="code" href="mpr_8h.html#51675ba1c7573f654989a489c0803f8b">05612</a> <span class="preprocessor">#define MPR_SOCKET_NODELAY      0x100       </span><span class="comment">/**&lt; Disable Nagle algorithm */</span>
<a name="l05613"></a><a class="code" href="mpr_8h.html#f3d6547888a1ecdcb880bccfc8511dd0">05613</a> <span class="preprocessor">#define MPR_SOCKET_THREAD       0x400       </span><span class="comment">/**&lt; Process callbacks on a worker thread */</span>
<a name="l05614"></a><a class="code" href="mpr_8h.html#1f98ea149c4bce9ffe816678bbc49f0d">05614</a> <span class="preprocessor">#define MPR_SOCKET_CLIENT       0x800       </span><span class="comment">/**&lt; Socket is a client */</span>
<a name="l05615"></a><a class="code" href="mpr_8h.html#38565a33ada00883ec935b577d1811ab">05615</a> <span class="preprocessor">#define MPR_SOCKET_PENDING      0x1000      </span><span class="comment">/**&lt; Pending buffered read data */</span>
<a name="l05616"></a>05616 <span class="comment"></span>
<a name="l05617"></a>05617 <span class="comment">/**</span>
<a name="l05618"></a>05618 <span class="comment"> *  Socket Service</span>
<a name="l05619"></a>05619 <span class="comment"> *  @description The MPR Socket service provides IPv4 and IPv6 capabilities for both client and server endpoints.</span>
<a name="l05620"></a>05620 <span class="comment"> *  Datagrams, Broadcast and point to point services are supported. The APIs can be used in both blocking and</span>
<a name="l05621"></a>05621 <span class="comment"> *  non-blocking modes.</span>
<a name="l05622"></a>05622 <span class="comment"> *  \n\n</span>
<a name="l05623"></a>05623 <span class="comment"> *  The socket service integrates with the MPR worker thread pool and eventing services. Socket connections can be handled</span>
<a name="l05624"></a>05624 <span class="comment"> *  by threads from the worker thread pool for scalable, multithreaded applications.</span>
<a name="l05625"></a>05625 <span class="comment"> *</span>
<a name="l05626"></a>05626 <span class="comment"> *  @stability Evolving</span>
<a name="l05627"></a>05627 <span class="comment"> *  @see MprSocket, mprCreateSocket, mprOpenClientSocket, mprOpenServerSocket, mprCloseSocket, mprFree, mprFlushSocket,</span>
<a name="l05628"></a>05628 <span class="comment"> *      mprWriteSocket, mprWriteSocketString, mprReadSocket, mprSetSocketCallback, mprSetSocketEventMask, </span>
<a name="l05629"></a>05629 <span class="comment"> *      mprGetSocketBlockingMode, mprIsSocketEof, mprGetSocketFd, mprGetSocketPort, mprGetSocketBlockingMode, </span>
<a name="l05630"></a>05630 <span class="comment"> *      mprSetSocketNoDelay, mprGetSocketError, mprParseIp, mprSendFileToSocket, mprSetSocketEof, mprIsSocketSecure</span>
<a name="l05631"></a>05631 <span class="comment"> *      mprWriteSocketVector</span>
<a name="l05632"></a>05632 <span class="comment"> *  @defgroup MprSocket MprSocket</span>
<a name="l05633"></a>05633 <span class="comment"> */</span>
<a name="l05634"></a>05634 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprSocket {
<a name="l05635"></a>05635     MprSocketService *service;          <span class="comment">/**&lt; Socket service */</span>
<a name="l05636"></a>05636     <span class="keywordtype">int</span>             error;              <span class="comment">/**&lt; Last error */</span>
<a name="l05637"></a>05637     MprDispatcher   *dispatcher;        <span class="comment">/**&lt; Event dispatcher for I/O events */</span>
<a name="l05638"></a>05638     MprWaitHandler  *handler;           <span class="comment">/**&lt; Wait handler */</span>
<a name="l05639"></a>05639     <span class="keywordtype">char</span>            *ip;                <span class="comment">/**&lt; Server side ip address */</span>
<a name="l05640"></a>05640     <span class="keywordtype">char</span>            *clientIpAddr;      <span class="comment">/**&lt; Client side ip address */</span>
<a name="l05641"></a>05641     <span class="keywordtype">int</span>             port;               <span class="comment">/**&lt; Port to listen on */</span>
<a name="l05642"></a>05642     <span class="keywordtype">int</span>             fd;                 <span class="comment">/**&lt; Actual socket file handle */</span>
<a name="l05643"></a>05643     <span class="keywordtype">int</span>             flags;              <span class="comment">/**&lt; Current state flags */</span>
<a name="l05644"></a>05644     MprSocketProvider *provider;        <span class="comment">/**&lt; Socket implementation provider */</span>
<a name="l05645"></a>05645     <span class="keyword">struct </span>MprSocket *listenSock;       <span class="comment">/**&lt; Listening socket */</span>
<a name="l05646"></a>05646     <span class="keyword">struct </span>MprSslSocket *sslSocket;     <span class="comment">/**&lt; Extended ssl socket state. If set, then using ssl */</span>
<a name="l05647"></a>05647     <span class="keyword">struct </span>MprSsl   *ssl;               <span class="comment">/**&lt; SSL configuration */</span>
<a name="l05648"></a>05648 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05649"></a>05649 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;             <span class="comment">/**&lt; Multi-thread sync */</span>
<a name="l05650"></a>05650 <span class="preprocessor">#endif</span>
<a name="l05651"></a>05651 <span class="preprocessor"></span>} MprSocket;
<a name="l05652"></a>05652 
<a name="l05653"></a>05653 
<a name="l05654"></a>05654 <span class="comment">/*</span>
<a name="l05655"></a>05655 <span class="comment"> *  Vectored write array</span>
<a name="l05656"></a>05656 <span class="comment"> */</span>
<a name="l05657"></a>05657 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprIOVec {
<a name="l05658"></a>05658     <span class="keywordtype">char</span>            *start;
<a name="l05659"></a>05659     <span class="keywordtype">size_t</span>          len;
<a name="l05660"></a>05660 } MprIOVec;
<a name="l05661"></a>05661 
<a name="l05662"></a>05662 <span class="comment"></span>
<a name="l05663"></a>05663 <span class="comment">/**</span>
<a name="l05664"></a>05664 <span class="comment"> *  Flag for mprCreateSocket to use the default SSL provider</span>
<a name="l05665"></a>05665 <span class="comment"> */</span> 
<a name="l05666"></a><a class="code" href="mpr_8h.html#7bbe6982e4e64f2f034971b88d3da3af">05666</a> <span class="preprocessor">#define MPR_SECURE_CLIENT ((struct MprSsl*) 1)</span>
<a name="l05667"></a>05667 <span class="preprocessor"></span>
<a name="l05668"></a>05668 <span class="comment">//  TODO - some of these names are not very consistent</span><span class="comment"></span>
<a name="l05669"></a>05669 <span class="comment">/**</span>
<a name="l05670"></a>05670 <span class="comment"> *  Create a socket</span>
<a name="l05671"></a>05671 <span class="comment"> *  @description Create a new socket</span>
<a name="l05672"></a>05672 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05673"></a>05673 <span class="comment"> *  @param ssl An optional SSL context if the socket is to support SSL. Use the #MPR_SECURE_CLIENT define to specify</span>
<a name="l05674"></a>05674 <span class="comment"> *      that mprCreateSocket should use the default SSL provider.</span>
<a name="l05675"></a>05675 <span class="comment"> *  @return A new socket object</span>
<a name="l05676"></a>05676 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05677"></a>05677 <span class="comment"> */</span>
<a name="l05678"></a>05678 <span class="keyword">extern</span> MprSocket *<a class="code" href="group___mpr_socket.html#g2889978d5c1a2e1990eb3198379cdeb9" title="Create a socket.">mprCreateSocket</a>(MprCtx ctx, <span class="keyword">struct</span> MprSsl *ssl);
<a name="l05679"></a>05679 <span class="comment"></span>
<a name="l05680"></a>05680 <span class="comment">/**</span>
<a name="l05681"></a>05681 <span class="comment"> *  Open a client socket</span>
<a name="l05682"></a>05682 <span class="comment"> *  @description Open a client connection</span>
<a name="l05683"></a>05683 <span class="comment"> *  @param sp Socket object returned via #mprCreateSocket</span>
<a name="l05684"></a>05684 <span class="comment"> *  @param hostName Host or IP address to connect to.</span>
<a name="l05685"></a>05685 <span class="comment"> *  @param port TCP/IP port number to connect to.</span>
<a name="l05686"></a>05686 <span class="comment"> *  @param flags Socket flags may use the following flags ored together:</span>
<a name="l05687"></a>05687 <span class="comment"> *      @li MPR_SOCKET_BLOCK - to use blocking I/O. The default is non-blocking.</span>
<a name="l05688"></a>05688 <span class="comment"> *      @li MPR_SOCKET_BROADCAST - Use IPv4 broadcast</span>
<a name="l05689"></a>05689 <span class="comment"> *      @li MPR_SOCKET_DATAGRAM - Use IPv4 datagrams</span>
<a name="l05690"></a>05690 <span class="comment"> *      @li MPR_SOCKET_NOREUSE - Set NOREUSE flag on the socket</span>
<a name="l05691"></a>05691 <span class="comment"> *      @li MPR_SOCKET_NODELAY - Set NODELAY on the socket</span>
<a name="l05692"></a>05692 <span class="comment"> *      @li MPR_SOCKET_THREAD - Process callbacks on a separate thread.</span>
<a name="l05693"></a>05693 <span class="comment"> *  @return Zero if the connection is successful. Otherwise a negative MPR error code.</span>
<a name="l05694"></a>05694 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05695"></a>05695 <span class="comment"> */</span>
<a name="l05696"></a>05696 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g52aa9a1c6e3f411df5f4cdd9e787ed16" title="Open a client socket.">mprOpenClientSocket</a>(MprSocket *sp, cchar *hostName, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> flags);
<a name="l05697"></a>05697 <span class="comment"></span>
<a name="l05698"></a>05698 <span class="comment">/**</span>
<a name="l05699"></a>05699 <span class="comment"> *  Disconnect a socket by closing its underlying file descriptor. This is used to prevent further I/O wait events while</span>
<a name="l05700"></a>05700 <span class="comment"> *  still preserving the socket object.</span>
<a name="l05701"></a>05701 <span class="comment"> *  @param sp Socket object</span>
<a name="l05702"></a>05702 <span class="comment"> */</span>
<a name="l05703"></a>05703 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#5f9301dbcddf9d1a62b40c69bc67fe40" title="Disconnect a socket by closing its underlying file descriptor.">mprDisconnectSocket</a>(MprSocket *sp);
<a name="l05704"></a>05704 <span class="comment"></span>
<a name="l05705"></a>05705 <span class="comment">/**</span>
<a name="l05706"></a>05706 <span class="comment"> *  Open a server socket</span>
<a name="l05707"></a>05707 <span class="comment"> *  @description Open a server socket and listen for client connections.</span>
<a name="l05708"></a>05708 <span class="comment"> *  @param sp Socket object returned via #mprCreateSocket</span>
<a name="l05709"></a>05709 <span class="comment"> *  @param ip IP address to bind to. Set to 0.0.0.0 to bind to all possible addresses on a given port.</span>
<a name="l05710"></a>05710 <span class="comment"> *  @param port TCP/IP port number to connect to. </span>
<a name="l05711"></a>05711 <span class="comment"> *  @param flags Socket flags may use the following flags ored together:</span>
<a name="l05712"></a>05712 <span class="comment"> *      @li MPR_SOCKET_BLOCK - to use blocking I/O. The default is non-blocking.</span>
<a name="l05713"></a>05713 <span class="comment"> *      @li MPR_SOCKET_BROADCAST - Use IPv4 broadcast</span>
<a name="l05714"></a>05714 <span class="comment"> *      @li MPR_SOCKET_DATAGRAM - Use IPv4 datagrams</span>
<a name="l05715"></a>05715 <span class="comment"> *      @li MPR_SOCKET_NOREUSE - Set NOREUSE flag on the socket</span>
<a name="l05716"></a>05716 <span class="comment"> *      @li MPR_SOCKET_NODELAY - Set NODELAY on the socket</span>
<a name="l05717"></a>05717 <span class="comment"> *      @li MPR_SOCKET_THREAD - Process callbacks on a separate thread.</span>
<a name="l05718"></a>05718 <span class="comment"> *  @return Zero if the connection is successful. Otherwise a negative MPR error code.</span>
<a name="l05719"></a>05719 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05720"></a>05720 <span class="comment"> */</span>
<a name="l05721"></a>05721 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#ge3e24d3cf87c63f71440aed20b5486cc" title="Open a server socket.">mprOpenServerSocket</a>(MprSocket *sp, cchar *ip, <span class="keywordtype">int</span> port, <span class="keywordtype">int</span> flags);
<a name="l05722"></a>05722 
<a name="l05723"></a>05723 <span class="comment"></span>
<a name="l05724"></a>05724 <span class="comment">/**</span>
<a name="l05725"></a>05725 <span class="comment"> *  Accept an incoming connection</span>
<a name="l05726"></a>05726 <span class="comment"> *  @param listen Listening server socket</span>
<a name="l05727"></a>05727 <span class="comment"> *  @returns A new socket connection</span>
<a name="l05728"></a>05728 <span class="comment"> */</span>
<a name="l05729"></a>05729 MprSocket *<a class="code" href="mpr_8h.html#8e5dff8e25775b63954faa81e54c7f82" title="Accept an incoming connection.">mprAcceptSocket</a>(MprSocket *listen);
<a name="l05730"></a>05730 <span class="comment"></span>
<a name="l05731"></a>05731 <span class="comment">/**</span>
<a name="l05732"></a>05732 <span class="comment"> *  Close a socket</span>
<a name="l05733"></a>05733 <span class="comment"> *  @description Close a socket. If the \a graceful option is true, the socket will first wait for written data to drain</span>
<a name="l05734"></a>05734 <span class="comment"> *      before doing a graceful close.</span>
<a name="l05735"></a>05735 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05736"></a>05736 <span class="comment"> *  @param graceful Set to true to do a graceful close. Otherwise, an abortive close will be performed.</span>
<a name="l05737"></a>05737 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05738"></a>05738 <span class="comment"> */</span>
<a name="l05739"></a>05739 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_socket.html#g5bd6e40cb8a29c92a8f5e1ce9529b726" title="Close a socket.">mprCloseSocket</a>(MprSocket *sp, <span class="keywordtype">bool</span> graceful);
<a name="l05740"></a>05740 <span class="comment"></span>
<a name="l05741"></a>05741 <span class="comment">/**</span>
<a name="l05742"></a>05742 <span class="comment"> *  Flush a socket</span>
<a name="l05743"></a>05743 <span class="comment"> *  @description Flush any buffered data in a socket. Standard sockets do not use buffering and this call will do nothing.</span>
<a name="l05744"></a>05744 <span class="comment"> *      SSL sockets do buffer and calling mprFlushSocket will write pending written data.</span>
<a name="l05745"></a>05745 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05746"></a>05746 <span class="comment"> *  @return A count of bytes actually written. Return a negative MPR error code on errors.</span>
<a name="l05747"></a>05747 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05748"></a>05748 <span class="comment"> */</span>
<a name="l05749"></a>05749 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g1e94b295effb81620c20b7ecf6e0e1d0" title="Flush a socket.">mprFlushSocket</a>(MprSocket *sp);
<a name="l05750"></a>05750 <span class="comment"></span>
<a name="l05751"></a>05751 <span class="comment">/**</span>
<a name="l05752"></a>05752 <span class="comment"> *  Write to a socket</span>
<a name="l05753"></a>05753 <span class="comment"> *  @description Write a block of data to a socket. If the socket is in non-blocking mode (the default), the write</span>
<a name="l05754"></a>05754 <span class="comment"> *      may return having written less than the required bytes. </span>
<a name="l05755"></a>05755 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05756"></a>05756 <span class="comment"> *  @param buf Reference to a block to write to the socket</span>
<a name="l05757"></a>05757 <span class="comment"> *  @param len Length of data to write. This may be less than the requested write length if the socket is in non-blocking</span>
<a name="l05758"></a>05758 <span class="comment"> *      mode. Will return a negative MPR error code on errors.</span>
<a name="l05759"></a>05759 <span class="comment"> *  @return A count of bytes actually written. Return a negative MPR error code on errors.</span>
<a name="l05760"></a>05760 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05761"></a>05761 <span class="comment"> */</span>
<a name="l05762"></a>05762 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#gbd2ae7ff08fb05f45d78f728a3af93a1" title="Write to a socket.">mprWriteSocket</a>(MprSocket *sp, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> len);
<a name="l05763"></a>05763 <span class="comment"></span>
<a name="l05764"></a>05764 <span class="comment">/**</span>
<a name="l05765"></a>05765 <span class="comment"> *  Write to a string to a socket</span>
<a name="l05766"></a>05766 <span class="comment"> *  @description Write a string  to a socket. If the socket is in non-blocking mode (the default), the write</span>
<a name="l05767"></a>05767 <span class="comment"> *      may return having written less than the required bytes. </span>
<a name="l05768"></a>05768 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05769"></a>05769 <span class="comment"> *  @param str Null terminated string to write.</span>
<a name="l05770"></a>05770 <span class="comment"> *  @return A count of bytes actually written. Return a negative MPR error code on errors.</span>
<a name="l05771"></a>05771 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05772"></a>05772 <span class="comment"> */</span>
<a name="l05773"></a>05773 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#gbf3c8418ff828a0301005b26ae06df92" title="Write to a string to a socket.">mprWriteSocketString</a>(MprSocket *sp, cchar *str);
<a name="l05774"></a>05774 <span class="comment"></span>
<a name="l05775"></a>05775 <span class="comment">/**</span>
<a name="l05776"></a>05776 <span class="comment"> *  Read from a socket</span>
<a name="l05777"></a>05777 <span class="comment"> *  @description Read data from a socket. The read will return with whatever bytes are available. If none and the socket</span>
<a name="l05778"></a>05778 <span class="comment"> *      is in blocking mode, it will block untill there is some data available or the socket is disconnected.</span>
<a name="l05779"></a>05779 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05780"></a>05780 <span class="comment"> *  @param buf Pointer to a buffer to hold the read data. </span>
<a name="l05781"></a>05781 <span class="comment"> *  @param size Size of the buffer.</span>
<a name="l05782"></a>05782 <span class="comment"> *  @return A count of bytes actually read. Return a negative MPR error code on errors.</span>
<a name="l05783"></a>05783 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05784"></a>05784 <span class="comment"> */</span>
<a name="l05785"></a>05785 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#gbff8106d1e1a3b5aa108542d3241f0b5" title="Read from a socket.">mprReadSocket</a>(MprSocket *sp, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> size);
<a name="l05786"></a>05786 <span class="comment"></span>
<a name="l05787"></a>05787 <span class="comment">/**</span>
<a name="l05788"></a>05788 <span class="comment"> *  Get the socket blocking mode.</span>
<a name="l05789"></a>05789 <span class="comment"> *  @description Return the current blocking mode setting.</span>
<a name="l05790"></a>05790 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05791"></a>05791 <span class="comment"> *  @return True if the socket is in blocking mode. Otherwise false.</span>
<a name="l05792"></a>05792 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05793"></a>05793 <span class="comment"> */</span>
<a name="l05794"></a>05794 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_socket.html#g8240b2dc5540ae928d19410447c2bab0" title="Get the socket blocking mode.">mprGetSocketBlockingMode</a>(MprSocket *sp);
<a name="l05795"></a>05795 <span class="comment"></span>
<a name="l05796"></a>05796 <span class="comment">/**</span>
<a name="l05797"></a>05797 <span class="comment"> *  Test if the socket has buffered read data.</span>
<a name="l05798"></a>05798 <span class="comment"> *  @description Use this function to avoid waiting for incoming I/O if data is already buffered.</span>
<a name="l05799"></a>05799 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05800"></a>05800 <span class="comment"> *  @return True if the socket has pending read data.</span>
<a name="l05801"></a>05801 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05802"></a>05802 <span class="comment"> */</span>
<a name="l05803"></a>05803 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_socket.html#g9ba5a2637bcf166c5b3f4289e590bb39" title="Test if the socket has buffered read data.">mprHasSocketPendingData</a>(MprSocket *sp);
<a name="l05804"></a>05804 <span class="comment"></span>
<a name="l05805"></a>05805 <span class="comment">/**</span>
<a name="l05806"></a>05806 <span class="comment"> *  Test if the other end of the socket has been closed.</span>
<a name="l05807"></a>05807 <span class="comment"> *  @description Determine if the other end of the socket has been closed and the socket is at end-of-file.</span>
<a name="l05808"></a>05808 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05809"></a>05809 <span class="comment"> *  @return True if the socket is at end-of-file.</span>
<a name="l05810"></a>05810 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05811"></a>05811 <span class="comment"> */</span>
<a name="l05812"></a>05812 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_socket.html#g122966f272c5d7d00bab8f66d569d362" title="Test if the other end of the socket has been closed.">mprIsSocketEof</a>(MprSocket *sp);
<a name="l05813"></a>05813 <span class="comment"></span>
<a name="l05814"></a>05814 <span class="comment">/**</span>
<a name="l05815"></a>05815 <span class="comment"> *  Get the socket file descriptor.</span>
<a name="l05816"></a>05816 <span class="comment"> *  @description Get the file descriptor associated with a socket.</span>
<a name="l05817"></a>05817 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05818"></a>05818 <span class="comment"> *  @return The integer file descriptor used by the O/S for the socket.</span>
<a name="l05819"></a>05819 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05820"></a>05820 <span class="comment"> */</span>
<a name="l05821"></a>05821 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g4ed3619958eac42ab4e8136464ae00c3" title="Get the socket file descriptor.">mprGetSocketFd</a>(MprSocket *sp);
<a name="l05822"></a>05822 <span class="comment"></span>
<a name="l05823"></a>05823 <span class="comment">/**</span>
<a name="l05824"></a>05824 <span class="comment"> *  Get the port used by a socket</span>
<a name="l05825"></a>05825 <span class="comment"> *  @description Get the TCP/IP port number used by the socket.</span>
<a name="l05826"></a>05826 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05827"></a>05827 <span class="comment"> *  @return The integer TCP/IP port number used by the socket.</span>
<a name="l05828"></a>05828 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05829"></a>05829 <span class="comment"> */</span>
<a name="l05830"></a>05830 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#ga4d2f67f80f168a4be7e5f3b96541bab" title="Get the port used by a socket.">mprGetSocketPort</a>(MprSocket *sp);
<a name="l05831"></a>05831 <span class="comment"></span>
<a name="l05832"></a>05832 <span class="comment">/**</span>
<a name="l05833"></a>05833 <span class="comment"> *  Set the socket blocking mode.</span>
<a name="l05834"></a>05834 <span class="comment"> *  @description Set the blocking mode for a socket. By default a socket is in non-blocking mode where read / write</span>
<a name="l05835"></a>05835 <span class="comment"> *      calls will not block.</span>
<a name="l05836"></a>05836 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05837"></a>05837 <span class="comment"> *  @param on Set to zero to put the socket into non-blocking mode. Set to non-zero to enable blocking mode.</span>
<a name="l05838"></a>05838 <span class="comment"> *  @return The old blocking mode if successful or a negative MPR error code.</span>
<a name="l05839"></a>05839 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05840"></a>05840 <span class="comment"> */</span>
<a name="l05841"></a>05841 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#ge2baa591f0466c9c64f0cf0147ada904" title="Set the socket blocking mode.">mprSetSocketBlockingMode</a>(MprSocket *sp, <span class="keywordtype">bool</span> on);
<a name="l05842"></a>05842 <span class="comment"></span>
<a name="l05843"></a>05843 <span class="comment">/**</span>
<a name="l05844"></a>05844 <span class="comment"> *  Set the socket delay mode.</span>
<a name="l05845"></a>05845 <span class="comment"> *  @description Set the socket delay behavior (nagle algorithm). By default a socket will partial packet writes</span>
<a name="l05846"></a>05846 <span class="comment"> *      a little to try to accumulate data and coalesce TCP/IP packages. Setting the delay mode to false may</span>
<a name="l05847"></a>05847 <span class="comment"> *      result in higher performance for interactive applications.</span>
<a name="l05848"></a>05848 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05849"></a>05849 <span class="comment"> *  @param on Set to non-zero to put the socket into no delay mode. Set to zero to enable the nagle algorithm.</span>
<a name="l05850"></a>05850 <span class="comment"> *  @return The old delay mode if successful or a negative MPR error code.</span>
<a name="l05851"></a>05851 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05852"></a>05852 <span class="comment"> */</span>
<a name="l05853"></a>05853 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g51594bafaa2003511990ffd804189a31" title="Set the socket delay mode.">mprSetSocketNoDelay</a>(MprSocket *sp, <span class="keywordtype">bool</span> on);
<a name="l05854"></a>05854 <span class="comment"></span>
<a name="l05855"></a>05855 <span class="comment">/**</span>
<a name="l05856"></a>05856 <span class="comment"> *  Get a socket error code</span>
<a name="l05857"></a>05857 <span class="comment"> *  @description This will map a Windows socket error code into a posix error code.</span>
<a name="l05858"></a>05858 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05859"></a>05859 <span class="comment"> *  @return A posix error code. </span>
<a name="l05860"></a>05860 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05861"></a>05861 <span class="comment"> */</span>
<a name="l05862"></a>05862 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g64ccf4250b432690a73bb66f0a639f7a" title="Get a socket error code.">mprGetSocketError</a>(MprSocket *sp);
<a name="l05863"></a>05863 
<a name="l05864"></a>05864 <span class="preprocessor">#if !BLD_FEATURE_ROMFS</span>
<a name="l05865"></a>05865 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l05866"></a>05866 <span class="comment"> *  Send a file to a socket</span>
<a name="l05867"></a>05867 <span class="comment"> *  @description Write the contents of a file to a socket. If the socket is in non-blocking mode (the default), the write</span>
<a name="l05868"></a>05868 <span class="comment"> *      may return having written less than the required bytes. This API permits the writing of data before and after</span>
<a name="l05869"></a>05869 <span class="comment"> *      the file contents. </span>
<a name="l05870"></a>05870 <span class="comment"> *  @param file File to write to the socket</span>
<a name="l05871"></a>05871 <span class="comment"> *  @param sock Socket object returned from #mprCreateSocket</span>
<a name="l05872"></a>05872 <span class="comment"> *  @param offset offset within the file from which to read data</span>
<a name="l05873"></a>05873 <span class="comment"> *  @param bytes Length of file data to write</span>
<a name="l05874"></a>05874 <span class="comment"> *  @param beforeVec Vector of data to write before the file contents</span>
<a name="l05875"></a>05875 <span class="comment"> *  @param beforeCount Count of entries in beforeVect</span>
<a name="l05876"></a>05876 <span class="comment"> *  @param afterVec Vector of data to write after the file contents</span>
<a name="l05877"></a>05877 <span class="comment"> *  @param afterCount Count of entries in afterCount</span>
<a name="l05878"></a>05878 <span class="comment"> *  @return A count of bytes actually written. Return a negative MPR error code on errors.</span>
<a name="l05879"></a>05879 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05880"></a>05880 <span class="comment"> */</span>
<a name="l05881"></a>05881 <span class="keyword">extern</span> MprOffset mprSendFileToSocket(MprSocket *sock, MprFile *file, MprOffset offset, <span class="keywordtype">int</span> bytes, MprIOVec *beforeVec, 
<a name="l05882"></a>05882     <span class="keywordtype">int</span> beforeCount, MprIOVec *afterVec, <span class="keywordtype">int</span> afterCount);
<a name="l05883"></a>05883 <span class="preprocessor">#endif</span>
<a name="l05884"></a>05884 <span class="preprocessor"></span><span class="comment"></span>
<a name="l05885"></a>05885 <span class="comment">/**</span>
<a name="l05886"></a>05886 <span class="comment"> *  Set an EOF condition on the socket</span>
<a name="l05887"></a>05887 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05888"></a>05888 <span class="comment"> *  @param eof Set to true to set an EOF condition. Set to false to clear it.</span>
<a name="l05889"></a>05889 <span class="comment"> */</span>
<a name="l05890"></a>05890 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#27866b4c10d6e45ffd96604b221cf314" title="Set an EOF condition on the socket.">mprSetSocketEof</a>(MprSocket *sp, <span class="keywordtype">bool</span> eof);
<a name="l05891"></a>05891 <span class="comment"></span>
<a name="l05892"></a>05892 <span class="comment">/**</span>
<a name="l05893"></a>05893 <span class="comment"> *  Determine if the socket is secure</span>
<a name="l05894"></a>05894 <span class="comment"> *  @description Determine if the socket is using SSL to provide enhanced security.</span>
<a name="l05895"></a>05895 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05896"></a>05896 <span class="comment"> *  @return True if the socket is using SSL, otherwise zero.</span>
<a name="l05897"></a>05897 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05898"></a>05898 <span class="comment"> */</span>
<a name="l05899"></a>05899 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_socket.html#gbeeb5c489632e55d36e2139f8ac0f423" title="Determine if the socket is secure.">mprIsSocketSecure</a>(MprSocket *sp);
<a name="l05900"></a>05900 <span class="comment"></span>
<a name="l05901"></a>05901 <span class="comment">/**</span>
<a name="l05902"></a>05902 <span class="comment"> *  Write a vector to a socket</span>
<a name="l05903"></a>05903 <span class="comment"> *  @description Do scatter/gather I/O by writing a vector of buffers to a socket.</span>
<a name="l05904"></a>05904 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05905"></a>05905 <span class="comment"> *  @param iovec Vector of data to write before the file contents</span>
<a name="l05906"></a>05906 <span class="comment"> *  @param count Count of entries in beforeVect</span>
<a name="l05907"></a>05907 <span class="comment"> *  @return A count of bytes actually written. Return a negative MPR error code on errors.</span>
<a name="l05908"></a>05908 <span class="comment"> *  @ingroup MprSocket</span>
<a name="l05909"></a>05909 <span class="comment"> */</span>
<a name="l05910"></a>05910 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_socket.html#g50a28b5aac234b66ad03d0e3a8e38038" title="Write a vector to a socket.">mprWriteSocketVector</a>(MprSocket *sp, MprIOVec *iovec, <span class="keywordtype">int</span> count);
<a name="l05911"></a>05911 <span class="comment"></span>
<a name="l05912"></a>05912 <span class="comment">/**</span>
<a name="l05913"></a>05913 <span class="comment"> *  Enable socket events for a socket callback</span>
<a name="l05914"></a>05914 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05915"></a>05915 <span class="comment"> */</span>
<a name="l05916"></a>05916 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#a2b9f1eb8ccbe19f2ca1c277e9e714e2" title="Enable socket events for a socket callback.">mprEnableSocketEvents</a>(MprSocket *sp);
<a name="l05917"></a>05917 <span class="comment"></span>
<a name="l05918"></a>05918 <span class="comment">/**</span>
<a name="l05919"></a>05919 <span class="comment"> *  Disable socket events for a socket callback</span>
<a name="l05920"></a>05920 <span class="comment"> *  @param sp Socket object returned from #mprCreateSocket</span>
<a name="l05921"></a>05921 <span class="comment"> */</span>
<a name="l05922"></a>05922 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#40585bcce880703910e75ff4599529da" title="Disable socket events for a socket callback.">mprDisableSocketEvents</a>(MprSocket *sp);
<a name="l05923"></a>05923 <span class="comment"></span>
<a name="l05924"></a>05924 <span class="comment">/**</span>
<a name="l05925"></a>05925 <span class="comment"> *  Parse an IP address. This parses a string containing an IP:PORT specification and returns the IP address and port </span>
<a name="l05926"></a>05926 <span class="comment"> *  components. Handles ipv4 and ipv6 addresses. </span>
<a name="l05927"></a>05927 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05928"></a>05928 <span class="comment"> *  @param ipSpec An IP:PORT specification. The :PORT is optional. When an IP address contains an ipv6 port it should be </span>
<a name="l05929"></a>05929 <span class="comment"> *  written as</span>
<a name="l05930"></a>05930 <span class="comment"> *      aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh:iiii    or</span>
<a name="l05931"></a>05931 <span class="comment"> *     [aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh:iiii]:port</span>
<a name="l05932"></a>05932 <span class="comment"> *  @param ip Pointer to receive a dynamically allocated IP string. Caller should free.</span>
<a name="l05933"></a>05933 <span class="comment"> *  @param port Pointer to an integer to receive the port value.</span>
<a name="l05934"></a>05934 <span class="comment"> *  @param defaultPort The default port number to use if the ipSpec does not contain a port</span>
<a name="l05935"></a>05935 <span class="comment"> */</span>
<a name="l05936"></a>05936 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#978aa9d1ee3d0fe7b50e566f3d471ed3" title="Parse an IP address.">mprParseIp</a>(MprCtx ctx, cchar *ipSpec, <span class="keywordtype">char</span> **ip, <span class="keywordtype">int</span> *port, <span class="keywordtype">int</span> defaultPort);
<a name="l05937"></a>05937 
<a name="l05938"></a>05938 <span class="preprocessor">#if BLD_FEATURE_SSL</span>
<a name="l05939"></a>05939 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l05940"></a>05940 <span class="comment"> *  These are here to reduce namespace clutter, so users who want SSL don't have to include mprSsl.h and thus </span>
<a name="l05941"></a>05941 <span class="comment"> *  pull in ssl headers.</span>
<a name="l05942"></a>05942 <span class="comment"> */</span><span class="comment"></span>
<a name="l05943"></a>05943 <span class="comment">/**</span>
<a name="l05944"></a>05944 <span class="comment"> *  Load the SSL module.</span>
<a name="l05945"></a>05945 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l05946"></a>05946 <span class="comment"> *  @param lazy Set to true to delay initialization until SSL is actually used.</span>
<a name="l05947"></a>05947 <span class="comment"> */</span>
<a name="l05948"></a>05948 <span class="keyword">extern</span> MprModule *<a class="code" href="mpr_8h.html#7f73646ba41280e4da88fd7ff89bd383" title="Load the SSL module.">mprLoadSsl</a>(MprCtx ctx, <span class="keywordtype">bool</span> lazy);
<a name="l05949"></a>05949 <span class="comment"></span>
<a name="l05950"></a>05950 <span class="comment">/**</span>
<a name="l05951"></a>05951 <span class="comment"> *  Configure SSL based on the parsed MprSsl configuration</span>
<a name="l05952"></a>05952 <span class="comment"> *  @param ssl MprSsl configuration</span>
<a name="l05953"></a>05953 <span class="comment"> */</span>
<a name="l05954"></a>05954 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#5f3e1db5d7e207edaa4dde272a63c5fa" title="Configure SSL based on the parsed MprSsl configuration.">mprConfigureSsl</a>(<span class="keyword">struct</span> MprSsl *ssl);
<a name="l05955"></a>05955 <span class="preprocessor">#endif</span>
<a name="l05956"></a>05956 <span class="preprocessor"></span>
<a name="l05957"></a>05957 <span class="comment">//  TODO DOC</span>
<a name="l05958"></a>05958 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprListenOnSocket(MprSocket *sp);
<a name="l05959"></a>05959 
<a name="l05960"></a>05960 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l05961"></a>05961 <span class="preprocessor"></span>
<a name="l05962"></a>05962 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprWorkerStats {
<a name="l05963"></a>05963     <span class="keywordtype">int</span>             maxThreads;         <span class="comment">/* Configured max number of threads */</span>
<a name="l05964"></a>05964     <span class="keywordtype">int</span>             minThreads;         <span class="comment">/* Configured minimum */</span>
<a name="l05965"></a>05965     <span class="keywordtype">int</span>             numThreads;         <span class="comment">/* Configured minimum */</span>
<a name="l05966"></a>05966     <span class="keywordtype">int</span>             maxUse;             <span class="comment">/* Max used */</span>
<a name="l05967"></a>05967     <span class="keywordtype">int</span>             pruneHighWater;     <span class="comment">/* Peak thread use in last minute */</span>
<a name="l05968"></a>05968     <span class="keywordtype">int</span>             idleThreads;        <span class="comment">/* Current idle */</span>
<a name="l05969"></a>05969     <span class="keywordtype">int</span>             busyThreads;        <span class="comment">/* Current busy */</span>
<a name="l05970"></a>05970 } MprWorkerStats;
<a name="l05971"></a>05971 <span class="comment"></span>
<a name="l05972"></a>05972 <span class="comment">/**</span>
<a name="l05973"></a>05973 <span class="comment"> *  Worker Thread Service</span>
<a name="l05974"></a>05974 <span class="comment"> *  @description The MPR provides a worker thread pool for rapid starting and assignment of threads to tasks.</span>
<a name="l05975"></a>05975 <span class="comment"> *  @stability Evolving</span>
<a name="l05976"></a>05976 <span class="comment"> *  @see MprWorkerService, mprAvailableWorkers, mprSetMaxWorkers, mprSetMinWorkers</span>
<a name="l05977"></a>05977 <span class="comment"> *  @defgroup MprWorkerService MprWorkerService</span>
<a name="l05978"></a>05978 <span class="comment"> */</span>
<a name="l05979"></a>05979 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprWorkerService {
<a name="l05980"></a>05980     <span class="keywordtype">int</span>             nextTaskNum;        <span class="comment">/* Unique next task number */</span>
<a name="l05981"></a>05981     MprList         *runningTasks;      <span class="comment">/* List of executing tasks */</span>
<a name="l05982"></a>05982     <span class="keywordtype">int</span>             stackSize;          <span class="comment">/* Stack size for worker threads */</span>
<a name="l05983"></a>05983     MprList         *tasks;             <span class="comment">/* Prioritized list of pending tasks */</span>
<a name="l05984"></a>05984 
<a name="l05985"></a>05985     MprList         *busyThreads;       <span class="comment">/* List of threads to service tasks */</span>
<a name="l05986"></a>05986     MprList         *idleThreads;       <span class="comment">/* List of threads to service tasks */</span>
<a name="l05987"></a>05987     <span class="keywordtype">int</span>             maxThreads;         <span class="comment">/* Max # threads in worker pool */</span>
<a name="l05988"></a>05988     <span class="keywordtype">int</span>             maxUseThreads;      <span class="comment">/* Max threads ever used */</span>
<a name="l05989"></a>05989     <span class="keywordtype">int</span>             minThreads;         <span class="comment">/* Max # threads in worker pool */</span>
<a name="l05990"></a>05990     <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;             <span class="comment">/* Per task synchronization */</span>
<a name="l05991"></a>05991     <span class="keywordtype">int</span>             nextThreadNum;      <span class="comment">/* Unique next thread number */</span>
<a name="l05992"></a>05992     <span class="keywordtype">int</span>             numThreads;         <span class="comment">/* Current number of threads in worker pool */</span>
<a name="l05993"></a>05993     <span class="keywordtype">int</span>             pruneHighWater;     <span class="comment">/* Peak thread use in last minute */</span>
<a name="l05994"></a>05994     <span class="keyword">struct </span>MprEvent *pruneTimer;        <span class="comment">/* Timer for excess threads pruner */</span>
<a name="l05995"></a>05995 } MprWorkerService;
<a name="l05996"></a>05996 
<a name="l05997"></a>05997 
<a name="l05998"></a>05998 <span class="keyword">extern</span> MprWorkerService *mprCreateWorkerService(MprCtx ctx);
<a name="l05999"></a>05999 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprStartWorkerService(MprWorkerService *ws);
<a name="l06000"></a>06000 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprStopWorkerService(MprWorkerService *ws, <span class="keywordtype">int</span> timeout);
<a name="l06001"></a>06001 <span class="comment"></span>
<a name="l06002"></a>06002 <span class="comment">/**</span>
<a name="l06003"></a>06003 <span class="comment"> *  Get the count of available worker threads</span>
<a name="l06004"></a>06004 <span class="comment"> *  Return the count of free threads in the worker thread pool.</span>
<a name="l06005"></a>06005 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06006"></a>06006 <span class="comment"> *  @returns An integer count of worker threads.</span>
<a name="l06007"></a>06007 <span class="comment"> *  @ingroup MprWorkerService</span>
<a name="l06008"></a>06008 <span class="comment"> */</span>
<a name="l06009"></a>06009 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_worker_service.html#gf26e38fd431360fd0099279a28acdd9b" title="Get the count of available worker threads Return the count of free threads in the...">mprGetAvailableWorkers</a>(MprCtx ctx);
<a name="l06010"></a>06010 <span class="comment"></span>
<a name="l06011"></a>06011 <span class="comment">/**</span>
<a name="l06012"></a>06012 <span class="comment"> *  Set the default worker stack size</span>
<a name="l06013"></a>06013 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06014"></a>06014 <span class="comment"> *  @param size Stack size in bytes</span>
<a name="l06015"></a>06015 <span class="comment"> */</span>
<a name="l06016"></a>06016 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#33ba4772eb9d6ea4725f2c3bec6947f8" title="Set the default worker stack size.">mprSetWorkerStackSize</a>(MprCtx ctx, <span class="keywordtype">int</span> size);
<a name="l06017"></a>06017 <span class="comment"></span>
<a name="l06018"></a>06018 <span class="comment">/**</span>
<a name="l06019"></a>06019 <span class="comment"> *  Set the minimum count of worker threads</span>
<a name="l06020"></a>06020 <span class="comment"> *  Set the count of threads the worker pool will have. This will cause the worker pool to pre-create at least this </span>
<a name="l06021"></a>06021 <span class="comment"> *  many threads.</span>
<a name="l06022"></a>06022 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06023"></a>06023 <span class="comment"> *  @param count Minimum count of threads to use.</span>
<a name="l06024"></a>06024 <span class="comment"> *  @ingroup MprWorkerService</span>
<a name="l06025"></a>06025 <span class="comment"> */</span>
<a name="l06026"></a>06026 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_worker_service.html#g2c7a32b885496896b69c928c7f08ffe7" title="Set the minimum count of worker threads Set the count of threads the worker pool...">mprSetMinWorkers</a>(MprCtx ctx, <span class="keywordtype">int</span> count);
<a name="l06027"></a>06027 <span class="comment"></span>
<a name="l06028"></a>06028 <span class="comment">/**</span>
<a name="l06029"></a>06029 <span class="comment"> *  Set the maximum count of worker threads</span>
<a name="l06030"></a>06030 <span class="comment"> *  Set the maximum number of worker pool threads for the MPR. If this number if less than the current number of threads,</span>
<a name="l06031"></a>06031 <span class="comment"> *      excess threads will be gracefully pruned as they exit.</span>
<a name="l06032"></a>06032 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06033"></a>06033 <span class="comment"> *  @param count Maximum limit of threads to define.</span>
<a name="l06034"></a>06034 <span class="comment"> *  @ingroup MprWorkerService</span>
<a name="l06035"></a>06035 <span class="comment"> */</span>
<a name="l06036"></a>06036 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_worker_service.html#gdb937865f624afea0be874b043260672" title="Set the maximum count of worker threads Set the maximum number of worker pool threads...">mprSetMaxWorkers</a>(MprCtx ctx, <span class="keywordtype">int</span> count);
<a name="l06037"></a>06037 <span class="comment"></span>
<a name="l06038"></a>06038 <span class="comment">/**</span>
<a name="l06039"></a>06039 <span class="comment"> *  Get the maximum count of worker pool threads</span>
<a name="l06040"></a>06040 <span class="comment"> *  Get the maximum limit of worker pool threads. </span>
<a name="l06041"></a>06041 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06042"></a>06042 <span class="comment"> *  @return The maximum count of worker pool threads.</span>
<a name="l06043"></a>06043 <span class="comment"> *  @ingroup MprWorkerService</span>
<a name="l06044"></a>06044 <span class="comment"> */</span>
<a name="l06045"></a>06045 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_worker_service.html#g5ec8913eb20bf209312f10f69005667a" title="Get the maximum count of worker pool threads Get the maximum limit of worker pool...">mprGetMaxWorkers</a>(MprCtx ctx);
<a name="l06046"></a>06046 
<a name="l06047"></a>06047 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprGetWorkerServiceStats(MprWorkerService *ps, MprWorkerStats *stats);
<a name="l06048"></a>06048 
<a name="l06049"></a>06049 <span class="comment">/*</span>
<a name="l06050"></a>06050 <span class="comment"> *  State</span>
<a name="l06051"></a>06051 <span class="comment"> */</span>
<a name="l06052"></a>06052 <span class="preprocessor">#define MPR_WORKER_BUSY        0x1          </span><span class="comment">/* Worker currently running to a callback */</span>
<a name="l06053"></a>06053 <span class="preprocessor">#define MPR_WORKER_IDLE        0x2          </span><span class="comment">/* Worker idle and available for work */</span>
<a name="l06054"></a>06054 <span class="preprocessor">#define MPR_WORKER_PRUNED      0x4          </span><span class="comment">/* Worker has been pruned and will be terminated */</span>
<a name="l06055"></a>06055 <span class="preprocessor">#define MPR_WORKER_SLEEPING    0x8          </span><span class="comment">/* Worker is sleeping (idle) on idleCond */</span>
<a name="l06056"></a>06056 
<a name="l06057"></a>06057 <span class="comment">/*</span>
<a name="l06058"></a>06058 <span class="comment"> *  Flags</span>
<a name="l06059"></a>06059 <span class="comment"> */</span>
<a name="l06060"></a>06060 <span class="preprocessor">#define MPR_WORKER_DEDICATED   0x1          </span><span class="comment">/* Worker reserved and not part of the worker pool */</span>
<a name="l06061"></a>06061 <span class="comment"></span>
<a name="l06062"></a>06062 <span class="comment">/**</span>
<a name="l06063"></a>06063 <span class="comment"> *  Worker thread callback signature</span>
<a name="l06064"></a>06064 <span class="comment"> *  @param data worker callback data. Set via mprStartWorker or mprActivateWorker</span>
<a name="l06065"></a>06065 <span class="comment"> *  @param worker Reference to the worker thread object</span>
<a name="l06066"></a>06066 <span class="comment"> */</span>
<a name="l06067"></a><a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99">06067</a> <span class="keyword">typedef</span> void (*<a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99" title="Worker thread callback signature.">MprWorkerProc</a>)(<span class="keywordtype">void</span> *data, <span class="keyword">struct </span>MprWorker *worker);
<a name="l06068"></a>06068 
<a name="l06069"></a>06069 <span class="comment">/*</span>
<a name="l06070"></a>06070 <span class="comment"> *  Threads in the worker thread pool</span>
<a name="l06071"></a>06071 <span class="comment"> */</span>
<a name="l06072"></a>06072 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprWorker {
<a name="l06073"></a>06073     <a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99" title="Worker thread callback signature.">MprWorkerProc</a>   proc;                   <span class="comment">/* Procedure to run */</span>
<a name="l06074"></a>06074     <a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99" title="Worker thread callback signature.">MprWorkerProc</a>   cleanup;                <span class="comment">/* Procedure to cleanup after run before sleeping */</span>
<a name="l06075"></a>06075     <span class="keywordtype">void</span>            *data;
<a name="l06076"></a>06076     <span class="keywordtype">int</span>             state;
<a name="l06077"></a>06077     <span class="keywordtype">int</span>             flags;
<a name="l06078"></a>06078     MprThread       *thread;                <span class="comment">/* Thread associated with this worker */</span>
<a name="l06079"></a>06079     MprWorkerService *workerService;        <span class="comment">/* Worker service */</span>
<a name="l06080"></a>06080     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *idleCond;              <span class="comment">/* Used to wait for work */</span>
<a name="l06081"></a>06081 } MprWorker;
<a name="l06082"></a>06082 
<a name="l06083"></a>06083 <span class="keyword">extern</span> <span class="keywordtype">void</span> mprActivateWorker(MprWorker *worker, <a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99" title="Worker thread callback signature.">MprWorkerProc</a> proc, <span class="keywordtype">void</span> *data);
<a name="l06084"></a>06084 <span class="comment"></span>
<a name="l06085"></a>06085 <span class="comment">/**</span>
<a name="l06086"></a>06086 <span class="comment"> *  Start a worker thread</span>
<a name="l06087"></a>06087 <span class="comment"> *  @description Start a worker thread executing the given worker procedure callback.</span>
<a name="l06088"></a>06088 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06089"></a>06089 <span class="comment"> *  @param proc Worker procedure callback</span>
<a name="l06090"></a>06090 <span class="comment"> *  @param data Data parameter to the callback</span>
<a name="l06091"></a>06091 <span class="comment"> *  @returns Zero if successful, otherwise a negative MPR error code.</span>
<a name="l06092"></a>06092 <span class="comment"> */</span>
<a name="l06093"></a>06093 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#da0a427a03ab3475fb0faab39d3f5459" title="Start a worker thread.">mprStartWorker</a>(MprCtx ctx, <a class="code" href="mpr_8h.html#1c2789aea11b60b13644c3b4e7c54f99" title="Worker thread callback signature.">MprWorkerProc</a> proc, <span class="keywordtype">void</span> *data);
<a name="l06094"></a>06094 <span class="comment"></span>
<a name="l06095"></a>06095 <span class="comment">/**</span>
<a name="l06096"></a>06096 <span class="comment"> *  Dedicate a worker thread to a current real thread. This implements thread affinity and is required on some platforms</span>
<a name="l06097"></a>06097 <span class="comment"> *      where some APIs (waitpid on uClibc) cannot be called on a different thread.</span>
<a name="l06098"></a>06098 <span class="comment"> *  @param worker Worker object</span>
<a name="l06099"></a>06099 <span class="comment"> *  @param worker Worker thread reference</span>
<a name="l06100"></a>06100 <span class="comment"> */</span>
<a name="l06101"></a>06101 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#7fe4c3fb94490eb462405d86f71514d7" title="Dedicate a worker thread to a current real thread.">mprDedicateWorker</a>(MprWorker *worker);
<a name="l06102"></a>06102 <span class="comment"></span>
<a name="l06103"></a>06103 <span class="comment">/**</span>
<a name="l06104"></a>06104 <span class="comment"> *  Release a worker thread. This releases a worker thread to be assignable to any real thread.</span>
<a name="l06105"></a>06105 <span class="comment"> *  @param worker Worker object</span>
<a name="l06106"></a>06106 <span class="comment"> *  @param worker Worker thread reference</span>
<a name="l06107"></a>06107 <span class="comment"> */</span>
<a name="l06108"></a>06108 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#dae3b874e39e0d5e0155d5179f1d83cc" title="Release a worker thread.">mprReleaseWorker</a>(MprWorker *worker);
<a name="l06109"></a>06109 
<a name="l06110"></a>06110 <span class="comment">/*</span>
<a name="l06111"></a>06111 <span class="comment"> *  Get the worker object if the current thread is actually a worker thread.</span>
<a name="l06112"></a>06112 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06113"></a>06113 <span class="comment"> *  @returns A worker thread object if the thread is a worker thread. Otherwise, NULL.</span>
<a name="l06114"></a>06114 <span class="comment"> */</span>
<a name="l06115"></a>06115 <span class="keyword">extern</span> MprWorker *mprGetCurrentWorker(MprCtx ctx);
<a name="l06116"></a>06116 
<a name="l06117"></a>06117 <span class="preprocessor">#endif </span><span class="comment">/* BLD_FEATURE_MULTITHREAD */</span>
<a name="l06118"></a>06118 <span class="comment">/**</span>
<a name="l06119"></a>06119 <span class="comment"> *  Deocde buffer using base-46 encoding.</span>
<a name="l06120"></a>06120 <span class="comment"> *  @param buffer Reference to a buffer containing that data to decode</span>
<a name="l06121"></a>06121 <span class="comment"> *  @param bufsize size of the buffer in bytes</span>
<a name="l06122"></a>06122 <span class="comment"> *  @param str String to decode</span>
<a name="l06123"></a>06123 <span class="comment"> *  @returns Zero if successful, otherwise returns MPR_ERR_WONT_FIT if the buffer is too small.</span>
<a name="l06124"></a>06124 <span class="comment"> * </span>
<a name="l06125"></a>06125 <span class="comment"> */</span>
<a name="l06126"></a>06126 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#6161ae2c822d03b9bda53ef7663f14f9" title="Deocde buffer using base-46 encoding.">mprDecode64</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufsize, cchar *str);
<a name="l06127"></a>06127 <span class="comment"></span>
<a name="l06128"></a>06128 <span class="comment">/**</span>
<a name="l06129"></a>06129 <span class="comment"> *  Encode buffer using base-46 encoding.</span>
<a name="l06130"></a>06130 <span class="comment"> *  @param buffer Reference to a buffer that will contain the encoded data.</span>
<a name="l06131"></a>06131 <span class="comment"> *  @param bufsize size of the buffer in bytes</span>
<a name="l06132"></a>06132 <span class="comment"> *  @param str String to encode</span>
<a name="l06133"></a>06133 <span class="comment"> *  @returns Zero if successful, otherwise returns MPR_ERR_WONT_FIT if the buffer is too small.</span>
<a name="l06134"></a>06134 <span class="comment"> */</span>
<a name="l06135"></a>06135 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#e57602feb972619422110f9fbd0d8341" title="Encode buffer using base-46 encoding.">mprEncode64</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufsize, cchar *str);
<a name="l06136"></a>06136 <span class="comment"></span>
<a name="l06137"></a>06137 <span class="comment">/**</span>
<a name="l06138"></a>06138 <span class="comment"> *  Get an MD5 checksum</span>
<a name="l06139"></a>06139 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06140"></a>06140 <span class="comment"> *  @param buf Buffer to checksum</span>
<a name="l06141"></a>06141 <span class="comment"> *  @param len Size of the buffer</span>
<a name="l06142"></a>06142 <span class="comment"> *  @param prefix String prefix to insert at the start of the result</span>
<a name="l06143"></a>06143 <span class="comment"> *  @returns An MD5 checksum string. Caller must free.</span>
<a name="l06144"></a>06144 <span class="comment"> */</span>
<a name="l06145"></a>06145 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#a5fff86cf2f5455dba2476c579ca3efb" title="Get an MD5 checksum.">mprGetMD5Hash</a>(MprCtx ctx, cchar *buf, <span class="keywordtype">int</span> len, cchar *prefix);
<a name="l06146"></a>06146 
<a name="l06147"></a>06147 <span class="keyword">extern</span> <span class="keywordtype">int</span>  mprCalcDigestNonce(MprCtx ctx, <span class="keywordtype">char</span> **nonce, cchar *secret, cchar *etag, cchar *realm);
<a name="l06148"></a>06148 <span class="keyword">extern</span> <span class="keywordtype">int</span>  mprCalcDigest(MprCtx ctx, <span class="keywordtype">char</span> **digest, cchar *userName, cchar *password, cchar *realm,
<a name="l06149"></a>06149                 cchar *uri, cchar *nonce, cchar *qop, cchar *nc, cchar *cnonce, cchar *method);
<a name="l06150"></a>06150 
<a name="l06151"></a>06151 <span class="comment">/* ********************************* MprCmd ************************************/</span>
<a name="l06152"></a>06152 <span class="preprocessor">#if BLD_FEATURE_CMD</span>
<a name="l06153"></a>06153 <span class="preprocessor"></span>
<a name="l06154"></a>06154 <span class="comment">/*</span>
<a name="l06155"></a>06155 <span class="comment"> *  Child status structure. Designed to be async-thread safe.</span>
<a name="l06156"></a>06156 <span class="comment"> */</span>
<a name="l06157"></a>06157 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprCmdChild {
<a name="l06158"></a>06158     ulong           pid;                <span class="comment">/*  Process ID */</span>
<a name="l06159"></a>06159     <span class="keywordtype">int</span>             exitStatus;         <span class="comment">/*  Exit status */</span>
<a name="l06160"></a>06160 } MprCmdChild;
<a name="l06161"></a>06161 
<a name="l06162"></a>06162 <span class="preprocessor">#define MPR_CMD_EOF_COUNT       2</span>
<a name="l06163"></a>06163 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CMD_VXWORKS_EOF     "_ _EOF_ _"</span>
<a name="l06164"></a>06164 <span class="preprocessor"></span><span class="preprocessor">#define MPR_CMD_VXWORKS_EOF_LEN 9</span>
<a name="l06165"></a>06165 <span class="preprocessor"></span>
<a name="l06166"></a>06166 <span class="comment">/*</span>
<a name="l06167"></a>06167 <span class="comment"> *  Channels for clientFd and serverFd</span>
<a name="l06168"></a>06168 <span class="comment"> */</span>
<a name="l06169"></a>06169 <span class="preprocessor">#define MPR_CMD_STDIN           0       </span><span class="comment">/* Stdout for the client side */</span>
<a name="l06170"></a>06170 <span class="preprocessor">#define MPR_CMD_STDOUT          1       </span><span class="comment">/* Stdin for the client side */</span>
<a name="l06171"></a>06171 <span class="preprocessor">#define MPR_CMD_STDERR          2       </span><span class="comment">/* Stderr for the client side */</span>
<a name="l06172"></a>06172 <span class="preprocessor">#define MPR_CMD_MAX_PIPE        3</span>
<a name="l06173"></a>06173 <span class="preprocessor"></span>
<a name="l06174"></a>06174 <span class="comment">/*</span>
<a name="l06175"></a>06175 <span class="comment"> *  Cmd procs must return the number of bytes read or -1 for errors.</span>
<a name="l06176"></a>06176 <span class="comment"> */</span>
<a name="l06177"></a>06177 <span class="keyword">struct </span>MprCmd;
<a name="l06178"></a>06178 <span class="keyword">typedef</span> int    (*MprCmdProc)(<span class="keyword">struct </span>MprCmd *cmd, <span class="keywordtype">int</span> channel, <span class="keywordtype">void</span> *data);
<a name="l06179"></a>06179 
<a name="l06180"></a>06180 <span class="comment">/*</span>
<a name="l06181"></a>06181 <span class="comment"> *  Flags</span>
<a name="l06182"></a>06182 <span class="comment"> */</span>
<a name="l06183"></a>06183 <span class="preprocessor">#define MPR_CMD_NEW_SESSION     0x1     </span><span class="comment">/* Create a new session on unix */</span>
<a name="l06184"></a>06184 <span class="preprocessor">#define MPR_CMD_SHOW            0x2     </span><span class="comment">/* Show the window of the created process on windows */</span>
<a name="l06185"></a>06185 <span class="preprocessor">#define MPR_CMD_DETACH          0x4     </span><span class="comment">/* Detach the child process and don't wait */</span>
<a name="l06186"></a>06186 <span class="preprocessor">#define MPR_CMD_IN              0x1000  </span><span class="comment">/* Connect to stdin */</span>
<a name="l06187"></a>06187 <span class="preprocessor">#define MPR_CMD_OUT             0x2000  </span><span class="comment">/* Capture stdout */</span>
<a name="l06188"></a>06188 <span class="preprocessor">#define MPR_CMD_ERR             0x4000  </span><span class="comment">/* Capture stdout */</span>
<a name="l06189"></a>06189 
<a name="l06190"></a>06190 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprCmdFile {
<a name="l06191"></a>06191     <span class="keywordtype">char</span>            *name;
<a name="l06192"></a>06192     <span class="keywordtype">int</span>             fd;
<a name="l06193"></a>06193     <span class="keywordtype">int</span>             clientFd;
<a name="l06194"></a>06194 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l06195"></a>06195 <span class="preprocessor"></span>    HANDLE          handle;
<a name="l06196"></a>06196 <span class="preprocessor">#endif</span>
<a name="l06197"></a>06197 <span class="preprocessor"></span>} MprCmdFile;
<a name="l06198"></a>06198 <span class="comment"></span>
<a name="l06199"></a>06199 <span class="comment">/**</span>
<a name="l06200"></a>06200 <span class="comment"> *  Command execution Service</span>
<a name="l06201"></a>06201 <span class="comment"> *  @description The MprCmd service enables execution of local commands. It uses three full-duplex pipes to communicate</span>
<a name="l06202"></a>06202 <span class="comment"> *      read, write and error data with the command. </span>
<a name="l06203"></a>06203 <span class="comment"> *  @stability Evolving.</span>
<a name="l06204"></a>06204 <span class="comment"> *  @see mprGetCmdBuf mprCreateCmd mprIsCmdRunning mprStartCmd mprGetCmdExitStatus mprGetCmdFd mprMakeCmdIO </span>
<a name="l06205"></a>06205 <span class="comment"> *      mprReadCmdPipe mprReapCmd mprRunCmd mprRunCmdV mprWaitForCmd mprWriteCmdPipe mprCloseCmdFd </span>
<a name="l06206"></a>06206 <span class="comment"> *      mprDisableCmdEvents mprDisconnectCmd mprEnableCmdEvents mprPollCmdPipes mprSetCmdCallback mprSetCmdDir </span>
<a name="l06207"></a>06207 <span class="comment"> *      mprSetCmdEnv mprStopCmd</span>
<a name="l06208"></a>06208 <span class="comment"> *  @defgroup MprCmd MprCmd</span>
<a name="l06209"></a>06209 <span class="comment"> */</span>
<a name="l06210"></a>06210 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprCmd {
<a name="l06211"></a>06211     <span class="keywordtype">char</span>            *program;           <span class="comment">/* Program path name */</span>
<a name="l06212"></a>06212     <span class="keywordtype">char</span>            **argv;             <span class="comment">/* List of args. Null terminated */</span>
<a name="l06213"></a>06213     <span class="keywordtype">char</span>            **env;              <span class="comment">/* List of environment variables. Null terminated */</span>
<a name="l06214"></a>06214     <span class="keywordtype">char</span>            *dir;               <span class="comment">/* Current working dir for the process */</span>
<a name="l06215"></a>06215     <span class="keywordtype">int</span>             argc;               <span class="comment">/* Count of args in argv */</span>
<a name="l06216"></a>06216     <span class="keywordtype">int</span>             status;             <span class="comment">/* Command exit status */</span>
<a name="l06217"></a>06217     <span class="keywordtype">int</span>             flags;              <span class="comment">/* Control flags (userFlags not here) */</span>
<a name="l06218"></a>06218     <span class="keywordtype">int</span>             eofCount;           <span class="comment">/* Count of end-of-files */</span>
<a name="l06219"></a>06219     <span class="keywordtype">int</span>             requiredEof;        <span class="comment">/* Number of EOFs required for an exit */</span>
<a name="l06220"></a>06220     MprTime         timestamp;          <span class="comment">/**&lt; Timeout timestamp for last I/O  */</span>
<a name="l06221"></a>06221     <span class="keywordtype">int</span>             timeoutPeriod;      <span class="comment">/**&lt; Timeout value */</span>
<a name="l06222"></a>06222     <span class="keywordtype">int</span>             timedout;           <span class="comment">/**&lt; Request has timedout */</span>
<a name="l06223"></a>06223     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *completeCond;      <span class="comment">/* Completion condition */</span>
<a name="l06224"></a>06224     MprCmdFile      files[MPR_CMD_MAX_PIPE]; <span class="comment">/* Stdin, stdout for the command */</span>
<a name="l06225"></a>06225     MprWaitHandler  *handlers[MPR_CMD_MAX_PIPE];
<a name="l06226"></a>06226     MprCmdProc      callback;           <span class="comment">/* Handler for client output and completion */</span>
<a name="l06227"></a>06227     <span class="keywordtype">void</span>            *callbackData;
<a name="l06228"></a>06228     MprBuf          *stdoutBuf;         <span class="comment">/* Standard output from the client */</span>
<a name="l06229"></a>06229     MprBuf          *stderrBuf;         <span class="comment">/* Standard error output from the client */</span>
<a name="l06230"></a>06230     MprTime         lastActivity;       <span class="comment">/* Time of last I/O */</span>
<a name="l06231"></a>06231     <span class="keywordtype">int</span>             pid;                <span class="comment">/* Process ID of the created process */</span>
<a name="l06232"></a>06232     <span class="keywordtype">void</span>            *userData;          <span class="comment">/* User data storage */</span>
<a name="l06233"></a>06233     <span class="keywordtype">int</span>             userFlags;          <span class="comment">/* User flags storage */</span>
<a name="l06234"></a>06234 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l06235"></a>06235 <span class="preprocessor"></span>    HANDLE          thread;             <span class="comment">/* Handle of the primary thread for the created process */</span>
<a name="l06236"></a>06236     HANDLE          process;            <span class="comment">/* Process handle for the created process */</span>
<a name="l06237"></a>06237     <span class="keywordtype">char</span>            *command;           <span class="comment">/* Windows command line */</span>          
<a name="l06238"></a>06238 <span class="preprocessor">#endif</span>
<a name="l06239"></a>06239 <span class="preprocessor"></span>
<a name="l06240"></a>06240 <span class="preprocessor">#if VXWORKS</span>
<a name="l06241"></a>06241 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l06242"></a>06242 <span class="comment">     *  Don't use MprCond so we can build single-threaded and still use MprCmd</span>
<a name="l06243"></a>06243 <span class="comment">     */</span>
<a name="l06244"></a>06244     SEM_ID          startCond;          <span class="comment">/* Synchronization semaphore for task start */</span>
<a name="l06245"></a>06245     SEM_ID          exitCond;           <span class="comment">/* Synchronization semaphore for task exit */</span>
<a name="l06246"></a>06246 <span class="preprocessor">#endif</span>
<a name="l06247"></a>06247 <span class="preprocessor"></span><span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l06248"></a>06248 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;             <span class="comment">/* Multithread sync */</span>
<a name="l06249"></a>06249     MprThread       *parent;            <span class="comment">/* Parent process thread */</span>
<a name="l06250"></a>06250 <span class="preprocessor">#endif</span>
<a name="l06251"></a>06251 <span class="preprocessor"></span>} MprCmd;
<a name="l06252"></a>06252 
<a name="l06253"></a>06253 <span class="comment"></span>
<a name="l06254"></a>06254 <span class="comment">/**</span>
<a name="l06255"></a>06255 <span class="comment"> *  Close the command channel</span>
<a name="l06256"></a>06256 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06257"></a>06257 <span class="comment"> *  @param channel Channel number to close. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06258"></a>06258 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06259"></a>06259 <span class="comment"> */</span>
<a name="l06260"></a>06260 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#gc48a59b1bfc4f3944a88e152863c3d32" title="Close the command channel.">mprCloseCmdFd</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel);
<a name="l06261"></a>06261 <span class="comment"></span>
<a name="l06262"></a>06262 <span class="comment">/**</span>
<a name="l06263"></a>06263 <span class="comment"> *  Create a new Command object </span>
<a name="l06264"></a>06264 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06265"></a>06265 <span class="comment"> *  @returns A newly allocated MprCmd object. Use mprFree to close and free.</span>
<a name="l06266"></a>06266 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06267"></a>06267 <span class="comment"> */</span>
<a name="l06268"></a>06268 <span class="keyword">extern</span> MprCmd *<a class="code" href="group___mpr_cmd.html#gbc453ad9cdcd6046373ebfce72ce1fd6" title="Create a new Command object.">mprCreateCmd</a>(MprCtx ctx);
<a name="l06269"></a>06269 <span class="comment"></span>
<a name="l06270"></a>06270 <span class="comment">/**</span>
<a name="l06271"></a>06271 <span class="comment"> *  Disconnect a command its underlying I/O channels. This is used to prevent further I/O wait events while</span>
<a name="l06272"></a>06272 <span class="comment"> *  still preserving the MprCmd object.</span>
<a name="l06273"></a>06273 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06274"></a>06274 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06275"></a>06275 <span class="comment"> */</span>
<a name="l06276"></a>06276 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g7562126cafba57260cd73634f1ee4aed" title="Disconnect a command its underlying I/O channels.">mprDisconnectCmd</a>(MprCmd *cmd);
<a name="l06277"></a>06277 <span class="comment"></span>
<a name="l06278"></a>06278 <span class="comment">/**</span>
<a name="l06279"></a>06279 <span class="comment"> *  Disable command I/O events. This disables events on a given channel.</span>
<a name="l06280"></a>06280 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06281"></a>06281 <span class="comment"> *  @param channel Channel number to close. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06282"></a>06282 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06283"></a>06283 <span class="comment"> */</span>
<a name="l06284"></a>06284 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g66cccaaaa550e9d2cf381ff8854c2d7a" title="Disable command I/O events.">mprDisableCmdEvents</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel);
<a name="l06285"></a>06285 <span class="comment"></span>
<a name="l06286"></a>06286 <span class="comment">/**</span>
<a name="l06287"></a>06287 <span class="comment"> *  Enable command I/O events. This enables events on a given channel.</span>
<a name="l06288"></a>06288 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06289"></a>06289 <span class="comment"> *  @param channel Channel number to close. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06290"></a>06290 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06291"></a>06291 <span class="comment"> */</span>
<a name="l06292"></a>06292 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g2fd38e2aaf8e7c2a1aed39aa1005155e" title="Enable command I/O events.">mprEnableCmdEvents</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel);
<a name="l06293"></a>06293 <span class="comment"></span>
<a name="l06294"></a>06294 <span class="comment">/**</span>
<a name="l06295"></a>06295 <span class="comment"> *  Get the command exit status</span>
<a name="l06296"></a>06296 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06297"></a>06297 <span class="comment"> *  @param status Reference to an integer to receive the command exit status. This is typically zero for success, but this</span>
<a name="l06298"></a>06298 <span class="comment"> *      is platform specific.</span>
<a name="l06299"></a>06299 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06300"></a>06300 <span class="comment"> */</span>
<a name="l06301"></a>06301 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g4dcefa4a65ff85b78c9b6580abac0a62" title="Get the command exit status.">mprGetCmdExitStatus</a>(MprCmd *cmd, <span class="keywordtype">int</span> *status);
<a name="l06302"></a>06302 <span class="comment"></span>
<a name="l06303"></a>06303 <span class="comment">/**</span>
<a name="l06304"></a>06304 <span class="comment"> *  Get the underlying file descriptor for an I/O channel</span>
<a name="l06305"></a>06305 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06306"></a>06306 <span class="comment"> *  @param channel Channel number to close. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06307"></a>06307 <span class="comment"> *  @return The file descriptor </span>
<a name="l06308"></a>06308 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06309"></a>06309 <span class="comment"> */</span>
<a name="l06310"></a>06310 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#gb286ce3b057579a16b84ec56997ae63f" title="Get the underlying file descriptor for an I/O channel.">mprGetCmdFd</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel);
<a name="l06311"></a>06311 <span class="comment"></span>
<a name="l06312"></a>06312 <span class="comment">/**</span>
<a name="l06313"></a>06313 <span class="comment"> *  Get the underlying buffer for a channel</span>
<a name="l06314"></a>06314 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06315"></a>06315 <span class="comment"> *  @param channel Channel number to close. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06316"></a>06316 <span class="comment"> *  @return A reference to the MprBuf buffer structure</span>
<a name="l06317"></a>06317 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06318"></a>06318 <span class="comment"> */</span>
<a name="l06319"></a>06319 <span class="keyword">extern</span> MprBuf *<a class="code" href="group___mpr_cmd.html#g68cf4226027c07ba3f3e5b30ecd48590" title="Get the underlying buffer for a channel.">mprGetCmdBuf</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel);
<a name="l06320"></a>06320 <span class="comment"></span>
<a name="l06321"></a>06321 <span class="comment">/**</span>
<a name="l06322"></a>06322 <span class="comment"> *  Test if the command is still running.</span>
<a name="l06323"></a>06323 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06324"></a>06324 <span class="comment"> *  @return True if the command is still running</span>
<a name="l06325"></a>06325 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06326"></a>06326 <span class="comment"> */</span>
<a name="l06327"></a>06327 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr_cmd.html#g5ac545e5959e115b2cd633004f5d949b" title="Test if the command is still running.">mprIsCmdRunning</a>(MprCmd *cmd);
<a name="l06328"></a>06328 <span class="comment"></span>
<a name="l06329"></a>06329 <span class="comment">/**</span>
<a name="l06330"></a>06330 <span class="comment"> *  Make the I/O channels to send and receive data to and from the command.</span>
<a name="l06331"></a>06331 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06332"></a>06332 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06333"></a>06333 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06334"></a>06334 <span class="comment"> */</span>
<a name="l06335"></a>06335 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g79b9d648fb26331b46aab5d8d6b0bce4" title="Make the I/O channels to send and receive data to and from the command.">mprMakeCmdIO</a>(MprCmd *cmd);
<a name="l06336"></a>06336 <span class="comment"></span>
<a name="l06337"></a>06337 <span class="comment">/**</span>
<a name="l06338"></a>06338 <span class="comment"> *  Make the I/O channels to send and receive data to and from the command.</span>
<a name="l06339"></a>06339 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06340"></a>06340 <span class="comment"> *  @param channel Channel number to read from. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06341"></a>06341 <span class="comment"> *  @param buf Buffer to read into</span>
<a name="l06342"></a>06342 <span class="comment"> *  @param bufsize Size of buffer</span>
<a name="l06343"></a>06343 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06344"></a>06344 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06345"></a>06345 <span class="comment"> */</span>
<a name="l06346"></a>06346 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g4a9036d982e301eb389e36b3b6a2bee7" title="Make the I/O channels to send and receive data to and from the command.">mprReadCmdPipe</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l06347"></a>06347 <span class="comment"></span>
<a name="l06348"></a>06348 <span class="comment">/**</span>
<a name="l06349"></a>06349 <span class="comment"> *  Reap the command. This waits for and collect the command exit status. </span>
<a name="l06350"></a>06350 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06351"></a>06351 <span class="comment"> *  @param timeout Time in milliseconds to wait for the command to complete and exit.</span>
<a name="l06352"></a>06352 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06353"></a>06353 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06354"></a>06354 <span class="comment"> */</span>
<a name="l06355"></a>06355 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g5644e84254f86b9f85374e90d081f0fc" title="Reap the command.">mprReapCmd</a>(MprCmd *cmd, <span class="keywordtype">int</span> timeout);
<a name="l06356"></a>06356 <span class="comment"></span>
<a name="l06357"></a>06357 <span class="comment">/**</span>
<a name="l06358"></a>06358 <span class="comment"> *  Run a command using a string command line. This starts the command via mprStartCmd() and waits for its completion.</span>
<a name="l06359"></a>06359 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06360"></a>06360 <span class="comment"> *  @param command Command line to run</span>
<a name="l06361"></a>06361 <span class="comment"> *  @param out Reference to a string to receive the stdout from the command. Caller must free.</span>
<a name="l06362"></a>06362 <span class="comment"> *  @param err Reference to a string to receive the stderr from the command. Caller must free.</span>
<a name="l06363"></a>06363 <span class="comment"> *  @param flags Flags to modify execution. Valid flags are:</span>
<a name="l06364"></a>06364 <span class="comment"> *      MPR_CMD_NEW_SESSION     Create a new session on Unix</span>
<a name="l06365"></a>06365 <span class="comment"> *      MPR_CMD_SHOW            Show the commands window on Windows</span>
<a name="l06366"></a>06366 <span class="comment"> *      MPR_CMD_IN              Connect to stdin</span>
<a name="l06367"></a>06367 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06368"></a>06368 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06369"></a>06369 <span class="comment"> */</span>
<a name="l06370"></a>06370 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g7f80cf889cf937a284d78552298667b3" title="Run a command using a string command line.">mprRunCmd</a>(MprCmd *cmd, cchar *command, <span class="keywordtype">char</span> **out, <span class="keywordtype">char</span> **err, <span class="keywordtype">int</span> flags);
<a name="l06371"></a>06371 <span class="comment"></span>
<a name="l06372"></a>06372 <span class="comment">/**</span>
<a name="l06373"></a>06373 <span class="comment"> *  Run a command using an argv[] array of arguments. This invokes mprStartCmd() and waits for its completion.</span>
<a name="l06374"></a>06374 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06375"></a>06375 <span class="comment"> *  @param argc Count of arguments in argv</span>
<a name="l06376"></a>06376 <span class="comment"> *  @param argv Command arguments array</span>
<a name="l06377"></a>06377 <span class="comment"> *  @param out Reference to a string to receive the stdout from the command. Caller must free.</span>
<a name="l06378"></a>06378 <span class="comment"> *  @param err Reference to a string to receive the stderr from the command. Caller must free.</span>
<a name="l06379"></a>06379 <span class="comment"> *  @param flags Flags to modify execution. Valid flags are:</span>
<a name="l06380"></a>06380 <span class="comment"> *      MPR_CMD_NEW_SESSION     Create a new session on Unix</span>
<a name="l06381"></a>06381 <span class="comment"> *      MPR_CMD_SHOW            Show the commands window on Windows</span>
<a name="l06382"></a>06382 <span class="comment"> *      MPR_CMD_IN              Connect to stdin</span>
<a name="l06383"></a>06383 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06384"></a>06384 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06385"></a>06385 <span class="comment"> */</span>
<a name="l06386"></a>06386 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#gfcea6f14d60761368a0644eb0c0de2aa" title="Run a command using an argv[] array of arguments.">mprRunCmdV</a>(MprCmd *cmd, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv, <span class="keywordtype">char</span> **out, <span class="keywordtype">char</span> **err, <span class="keywordtype">int</span> flags);
<a name="l06387"></a>06387 <span class="comment"></span>
<a name="l06388"></a>06388 <span class="comment">/**</span>
<a name="l06389"></a>06389 <span class="comment"> *  Define a callback to be invoked to receive response data from the command.</span>
<a name="l06390"></a>06390 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06391"></a>06391 <span class="comment"> *  @param callback Function of the signature MprCmdProc which will be invoked for receive notification</span>
<a name="l06392"></a>06392 <span class="comment"> *      for data from the commands stdout and stderr channels. MprCmdProc has the signature:</span>
<a name="l06393"></a>06393 <span class="comment"> *      int callback(MprCmd *cmd, int channel, void *data) {}</span>
<a name="l06394"></a>06394 <span class="comment"> *  @param data User defined data to be passed to the callback.</span>
<a name="l06395"></a>06395 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06396"></a>06396 <span class="comment"> */</span>
<a name="l06397"></a>06397 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g8288e08dc7387c14e0536d214eba6049" title="Define a callback to be invoked to receive response data from the command.">mprSetCmdCallback</a>(MprCmd *cmd, MprCmdProc callback, <span class="keywordtype">void</span> *data);
<a name="l06398"></a>06398 <span class="comment"></span>
<a name="l06399"></a>06399 <span class="comment">/**</span>
<a name="l06400"></a>06400 <span class="comment"> *  Set the home directory for the command</span>
<a name="l06401"></a>06401 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06402"></a>06402 <span class="comment"> *  @param dir String directory path name.</span>
<a name="l06403"></a>06403 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06404"></a>06404 <span class="comment"> */</span>
<a name="l06405"></a>06405 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#ga0e753a2136410b79e480713aaf97b89" title="Set the home directory for the command.">mprSetCmdDir</a>(MprCmd *cmd, cchar *dir);
<a name="l06406"></a>06406 <span class="comment"></span>
<a name="l06407"></a>06407 <span class="comment">/**</span>
<a name="l06408"></a>06408 <span class="comment"> *  Set the command environment</span>
<a name="l06409"></a>06409 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06410"></a>06410 <span class="comment"> *  @param env Array of environment strings. Each environment string should be of the form: "KEY=VALUE". The array</span>
<a name="l06411"></a>06411 <span class="comment"> *      must be null terminated.</span>
<a name="l06412"></a>06412 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06413"></a>06413 <span class="comment"> */</span>
<a name="l06414"></a>06414 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g731bf3b3b53862f42249d5a771107363" title="Set the command environment.">mprSetCmdEnv</a>(MprCmd *cmd, cchar **env);
<a name="l06415"></a>06415 <span class="comment"></span>
<a name="l06416"></a>06416 <span class="comment">/**</span>
<a name="l06417"></a>06417 <span class="comment"> *  Start the command. This starts the command but does not wait for its completion. Once started, mprWriteCmdPipe</span>
<a name="l06418"></a>06418 <span class="comment"> *  can be used to write to the command and response data can be received via mprReadCmdPipe.</span>
<a name="l06419"></a>06419 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06420"></a>06420 <span class="comment"> *  @param argc Count of arguments in argv</span>
<a name="l06421"></a>06421 <span class="comment"> *  @param argv Command arguments array</span>
<a name="l06422"></a>06422 <span class="comment"> *  @param envp Array of environment strings. Each environment string should be of the form: "KEY=VALUE". The array</span>
<a name="l06423"></a>06423 <span class="comment"> *      must be null terminated.</span>
<a name="l06424"></a>06424 <span class="comment"> *  @param flags Flags to modify execution. Valid flags are:</span>
<a name="l06425"></a>06425 <span class="comment"> *      MPR_CMD_NEW_SESSION     Create a new session on Unix</span>
<a name="l06426"></a>06426 <span class="comment"> *      MPR_CMD_SHOW            Show the commands window on Windows</span>
<a name="l06427"></a>06427 <span class="comment"> *      MPR_CMD_IN              Connect to stdin</span>
<a name="l06428"></a>06428 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06429"></a>06429 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06430"></a>06430 <span class="comment"> */</span>
<a name="l06431"></a>06431 <span class="keyword">extern</span> <span class="keywordtype">int</span>  <a class="code" href="group___mpr_cmd.html#g63558463aa20f047dbd03cae5b6dab7b" title="Start the command.">mprStartCmd</a>(MprCmd *cmd, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv, <span class="keywordtype">char</span> **envp, <span class="keywordtype">int</span> flags);
<a name="l06432"></a>06432 <span class="comment"></span>
<a name="l06433"></a>06433 <span class="comment">/**</span>
<a name="l06434"></a>06434 <span class="comment"> *  Stop the command. The command is immediately killed.</span>
<a name="l06435"></a>06435 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06436"></a>06436 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06437"></a>06437 <span class="comment"> */</span>
<a name="l06438"></a>06438 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g73dbe983174ac25e4af6a1fea4d8f966" title="Stop the command.">mprStopCmd</a>(MprCmd *cmd);
<a name="l06439"></a>06439 <span class="comment"></span>
<a name="l06440"></a>06440 <span class="comment">/**</span>
<a name="l06441"></a>06441 <span class="comment"> *  Wait for the command to complete.</span>
<a name="l06442"></a>06442 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06443"></a>06443 <span class="comment"> *  @param timeout Time in milliseconds to wait for the command to complete and exit.</span>
<a name="l06444"></a>06444 <span class="comment"> *  @return Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06445"></a>06445 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06446"></a>06446 <span class="comment"> */</span>
<a name="l06447"></a>06447 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#g86f4815eb5e4cdd4695ecfd17f8eb360" title="Wait for the command to complete.">mprWaitForCmd</a>(MprCmd *cmd, <span class="keywordtype">int</span> timeout);
<a name="l06448"></a>06448 <span class="comment"></span>
<a name="l06449"></a>06449 <span class="comment">/**</span>
<a name="l06450"></a>06450 <span class="comment"> *  Poll for I/O on the command pipes. This is only used on windows which can't adequately detect EOF on a named pipe.</span>
<a name="l06451"></a>06451 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06452"></a>06452 <span class="comment"> *  @param timeout Time in milliseconds to wait for the command to complete and exit.</span>
<a name="l06453"></a>06453 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06454"></a>06454 <span class="comment"> */</span>
<a name="l06455"></a>06455 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_cmd.html#g9aee91a4b53a03ea5dcf603b3c2437b8" title="Poll for I/O on the command pipes.">mprPollCmdPipes</a>(MprCmd *cmd, <span class="keywordtype">int</span> timeout);
<a name="l06456"></a>06456 <span class="comment"></span>
<a name="l06457"></a>06457 <span class="comment">/**</span>
<a name="l06458"></a>06458 <span class="comment"> *  Write data to an I/O channel</span>
<a name="l06459"></a>06459 <span class="comment"> *  @param cmd MprCmd object created via mprCreateCmd</span>
<a name="l06460"></a>06460 <span class="comment"> *  @param channel Channel number to read from. Should be either MPR_CMD_STDIN, MPR_CMD_STDOUT or MPR_CMD_STDERR.</span>
<a name="l06461"></a>06461 <span class="comment"> *  @param buf Buffer to read into</span>
<a name="l06462"></a>06462 <span class="comment"> *  @param bufsize Size of buffer</span>
<a name="l06463"></a>06463 <span class="comment"> *  @ingroup MprCmd</span>
<a name="l06464"></a>06464 <span class="comment"> */</span>
<a name="l06465"></a>06465 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr_cmd.html#gc69adc9b03e41150d6d79512c0895c12" title="Write data to an I/O channel.">mprWriteCmdPipe</a>(MprCmd *cmd, <span class="keywordtype">int</span> channel, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> bufsize);
<a name="l06466"></a>06466 
<a name="l06467"></a>06467 <span class="preprocessor">#endif </span><span class="comment">/* BLD_FEATURE_CMD */</span>
<a name="l06468"></a>06468 <span class="comment">/* *********************************** Mpr ************************************/</span>
<a name="l06469"></a>06469 <span class="comment">/*</span>
<a name="l06470"></a>06470 <span class="comment"> *  Mpr flags</span>
<a name="l06471"></a>06471 <span class="comment"> */</span>
<a name="l06472"></a>06472 <span class="preprocessor">#define MPR_EXITING                 0x1     </span><span class="comment">/* App is exiting */</span>
<a name="l06473"></a>06473 <span class="preprocessor">#define MPR_STOPPED                 0x2     </span><span class="comment">/* Mpr services stopped */</span>
<a name="l06474"></a>06474 <span class="preprocessor">#define MPR_STARTED                 0x4     </span><span class="comment">/* Mpr services started */</span>
<a name="l06475"></a>06475 <span class="preprocessor">#define MPR_SSL_PROVIDER_LOADED     0x8     </span><span class="comment">/* SSL provider loaded */</span>
<a name="l06476"></a>06476 <span class="comment"></span>
<a name="l06477"></a>06477 <span class="comment">/**</span>
<a name="l06478"></a>06478 <span class="comment"> *  Primary MPR application control structure</span>
<a name="l06479"></a>06479 <span class="comment"> *  @description The Mpr structure stores critical application state information and is the root memory allocation</span>
<a name="l06480"></a>06480 <span class="comment"> *      context block. It is used as the MprCtx context for other memory allocations and is thus</span>
<a name="l06481"></a>06481 <span class="comment"> *      the ultimate parent of all allocated memory.</span>
<a name="l06482"></a>06482 <span class="comment"> *  @stability Evolving.</span>
<a name="l06483"></a>06483 <span class="comment"> *  @see mprGetApp, mprCreateEx, mprIsExiting, mprSignalExit, mprTerminate, mprGetKeyValue, mprRemoveKeyValue,</span>
<a name="l06484"></a>06484 <span class="comment"> *      mprSetDebugMode, mprGetErrorMsg, mprGetOsError, mprGetError, mprBreakpoint</span>
<a name="l06485"></a>06485 <span class="comment"> *  @defgroup Mpr Mpr</span>
<a name="l06486"></a>06486 <span class="comment"> */</span>
<a name="l06487"></a>06487 <span class="keyword">typedef</span> <span class="keyword">struct </span>Mpr {
<a name="l06488"></a>06488     MprHeap         heap;                   <span class="comment">/**&lt; Top level memory pool */</span>
<a name="l06489"></a>06489     MprHeap         pageHeap;               <span class="comment">/**&lt; Heap for arenas and slabs. Always page oriented */</span>
<a name="l06490"></a>06490 
<a name="l06491"></a>06491     <span class="keywordtype">bool</span>            debugMode;              <span class="comment">/**&lt; Run in debug mode (no timers) */</span>
<a name="l06492"></a>06492     <span class="keywordtype">int</span>             logLevel;               <span class="comment">/**&lt; Log trace level */</span>
<a name="l06493"></a>06493     <a class="code" href="group___mpr_log.html#g8ca7894a05a04dc473d942ffc7cd1689" title="Log handler callback type.">MprLogHandler</a>   logHandler;             <span class="comment">/**&lt; Current log handler callback */</span>
<a name="l06494"></a>06494     <span class="keywordtype">void</span>            *logHandlerData;        <span class="comment">/**&lt; Handle data for log handler */</span>
<a name="l06495"></a>06495     <a class="code" href="struct_mpr_hash_table.html" title="Hash table control structure.">MprHashTable</a>    *timeTokens;            <span class="comment">/**&lt; Date/Time parsing tokens */</span>
<a name="l06496"></a>06496     <span class="keywordtype">char</span>            *name;                  <span class="comment">/**&lt; Product name */</span>
<a name="l06497"></a>06497     <span class="keywordtype">char</span>            *title;                 <span class="comment">/**&lt; Product title */</span>
<a name="l06498"></a>06498     <span class="keywordtype">char</span>            *version;               <span class="comment">/**&lt; Product version */</span>
<a name="l06499"></a>06499     <span class="keywordtype">int</span>             argc;                   <span class="comment">/**&lt; Count of command line args */</span>
<a name="l06500"></a>06500     <span class="keywordtype">char</span>            **argv;                 <span class="comment">/**&lt; Application command line args */</span>
<a name="l06501"></a>06501     <span class="keywordtype">char</span>            *domainName;            <span class="comment">/**&lt; Domain portion */</span>
<a name="l06502"></a>06502     <span class="keywordtype">char</span>            *hostName;              <span class="comment">/**&lt; Host name (fully qualified name) */</span>
<a name="l06503"></a>06503     <span class="keywordtype">char</span>            *ip;                    <span class="comment">/**&lt; Public IP Address */</span>
<a name="l06504"></a>06504     <span class="keywordtype">char</span>            *serverName;            <span class="comment">/**&lt; Server name portion (no domain) */</span>
<a name="l06505"></a>06505     <span class="keywordtype">char</span>            *appPath;               <span class="comment">/**&lt; Path name of application executable */</span>
<a name="l06506"></a>06506     <span class="keywordtype">char</span>            *appDir;                <span class="comment">/**&lt; Path of directory containing app executable */</span>
<a name="l06507"></a>06507     <span class="keywordtype">int</span>             flags;                  <span class="comment">/**&lt; Processing state */</span>
<a name="l06508"></a>06508     <span class="keywordtype">int</span>             timezone;               <span class="comment">/**&lt; Minutes west of Greenwich */</span>
<a name="l06509"></a>06509     <span class="keywordtype">int</span>             hasDedicatedService;    <span class="comment">/**&lt; Running a dedicated events thread */</span>
<a name="l06510"></a>06510     <span class="keywordtype">int</span>             multiThread;            <span class="comment">/**&lt; Is running multi-threaded */</span>
<a name="l06511"></a>06511 
<a name="l06512"></a>06512     <span class="comment">/*</span>
<a name="l06513"></a>06513 <span class="comment">     *  Service pointers</span>
<a name="l06514"></a>06514 <span class="comment">     */</span>
<a name="l06515"></a>06515     <span class="keyword">struct </span><a class="code" href="struct_mpr_file_system.html" title="File system service.">MprFileSystem</a>    *fileSystem;    <span class="comment">/**&lt; File system service object */</span>
<a name="l06516"></a>06516     <span class="keyword">struct </span>MprOsService     *osService;     <span class="comment">/**&lt; O/S service object */</span>
<a name="l06517"></a>06517     <span class="keyword">struct </span>MprDispatcherService *dispatcherService; <span class="comment">/**&lt; Dispatcher service object */</span>
<a name="l06518"></a>06518     <span class="keyword">struct </span>MprDispatcher    *dispatcher;    <span class="comment">/**&lt; Primary dispatcher */</span>
<a name="l06519"></a>06519     <span class="keyword">struct </span>MprModuleService *moduleService; <span class="comment">/**&lt; Module service object */</span>
<a name="l06520"></a>06520     <span class="keyword">struct </span>MprSocketService *socketService; <span class="comment">/**&lt; Socket service object */</span>
<a name="l06521"></a>06521     <span class="keyword">struct </span>MprWorkerService *workerService; <span class="comment">/**&lt; Worker service object */</span>
<a name="l06522"></a>06522     <span class="keyword">struct </span>MprWaitService   *waitService;   <span class="comment">/**&lt; IO Waiting service object */</span>
<a name="l06523"></a>06523 <span class="preprocessor">#if BLD_FEATURE_CMD</span>
<a name="l06524"></a>06524 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprCmdService    *cmdService;    <span class="comment">/**&lt; Command service object */</span>
<a name="l06525"></a>06525 <span class="preprocessor">#endif</span>
<a name="l06526"></a>06526 <span class="preprocessor"></span><span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l06527"></a>06527 <span class="preprocessor"></span>    <span class="keyword">struct </span>MprThreadService *threadService; <span class="comment">/**&lt; Thread service object */</span>
<a name="l06528"></a>06528     MprOsThread     mainOsThread;           <span class="comment">/**&lt; Main OS thread ID */</span>
<a name="l06529"></a>06529     <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;                 <span class="comment">/**&lt; Thread synchronization */</span>
<a name="l06530"></a>06530     <a class="code" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a>         *spin;                  <span class="comment">/**&lt; Quick thread synchronization */</span>
<a name="l06531"></a>06531 <span class="preprocessor">#endif</span>
<a name="l06532"></a>06532 <span class="preprocessor"></span><span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l06533"></a>06533 <span class="preprocessor"></span>    <span class="keywordtype">long</span>            appInstance;            <span class="comment">/**&lt; Application instance (windows) */</span>
<a name="l06534"></a>06534 <span class="preprocessor">#endif</span>
<a name="l06535"></a>06535 <span class="preprocessor"></span>} Mpr;
<a name="l06536"></a>06536 
<a name="l06537"></a>06537 
<a name="l06538"></a>06538 <span class="preprocessor">#if !BLD_WIN_LIKE || DOXYGEN</span>
<a name="l06539"></a>06539 <span class="preprocessor"></span><span class="keyword">extern</span> Mpr  *_globalMpr;                <span class="comment">/* Mpr singleton */</span>
<a name="l06540"></a>06540 <span class="preprocessor">#define mprGetMpr() _globalMpr</span>
<a name="l06541"></a>06541 <span class="preprocessor"></span><span class="preprocessor">#define MPR _globalMpr</span>
<a name="l06542"></a>06542 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l06543"></a>06543 <span class="preprocessor"></span><span class="comment"></span>
<a name="l06544"></a>06544 <span class="comment">/**</span>
<a name="l06545"></a>06545 <span class="comment"> *  Return the MPR control instance.</span>
<a name="l06546"></a>06546 <span class="comment"> *  @description Return the MPR singleton control object. </span>
<a name="l06547"></a>06547 <span class="comment"> *  @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06548"></a>06548 <span class="comment"> *  @return Returns the MPR control object.</span>
<a name="l06549"></a>06549 <span class="comment"> *  @stability Evolving.</span>
<a name="l06550"></a>06550 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06551"></a>06551 <span class="comment"> */</span>
<a name="l06552"></a>06552 <span class="keyword">extern</span> <span class="keyword">struct </span>Mpr *mprGetMpr();
<a name="l06553"></a>06553 <span class="preprocessor">#define MPR mprGetMpr</span>
<a name="l06554"></a>06554 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l06555"></a>06555 <span class="preprocessor"></span><span class="comment"></span>
<a name="l06556"></a>06556 <span class="comment">/**</span>
<a name="l06557"></a>06557 <span class="comment"> *  Create an instance of the MPR.</span>
<a name="l06558"></a>06558 <span class="comment"> *  @description Initializes the MPR and creates an Mpr control object. The Mpr Object manages Mpr facilities </span>
<a name="l06559"></a>06559 <span class="comment"> *      and is the top level memory context. It may be used wherever a MprCtx parameter is required. This </span>
<a name="l06560"></a>06560 <span class="comment"> *      function must be called prior to calling any other Mpr API.</span>
<a name="l06561"></a>06561 <span class="comment"> *  @param argc Count of command line args</span>
<a name="l06562"></a>06562 <span class="comment"> *  @param argv Command line arguments for the application. Arguments may be passed into the Mpr for retrieval</span>
<a name="l06563"></a>06563 <span class="comment"> *      by the unit test framework.</span>
<a name="l06564"></a>06564 <span class="comment"> *  @param cback Memory allocation failure notification callback.</span>
<a name="l06565"></a>06565 <span class="comment"> *  @return Returns a pointer to the Mpr object. </span>
<a name="l06566"></a>06566 <span class="comment"> *  @stability Evolving.</span>
<a name="l06567"></a>06567 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06568"></a>06568 <span class="comment"> */</span>
<a name="l06569"></a>06569 <span class="keyword">extern</span> Mpr *<a class="code" href="group___mpr.html#g4e84f505d5b6f74de677ffff29806906" title="Create an instance of the MPR.">mprCreate</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv, <a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a> cback);
<a name="l06570"></a>06570 <span class="comment"></span>
<a name="l06571"></a>06571 <span class="comment">/**</span>
<a name="l06572"></a>06572 <span class="comment"> *  Create an instance of the MPR.</span>
<a name="l06573"></a>06573 <span class="comment"> *  @description Alternate API to create and initialize the MPR. The Mpr object manages Mpr facilities and </span>
<a name="l06574"></a>06574 <span class="comment"> *      is the top level memory context. It may be used wherever a MprCtx parameter is required. This </span>
<a name="l06575"></a>06575 <span class="comment"> *      function, or #mprCreate must be called prior to calling any other Mpr API.</span>
<a name="l06576"></a>06576 <span class="comment"> *  @param argc Count of arguments supplied in argv</span>
<a name="l06577"></a>06577 <span class="comment"> *  @param argv Program arguments. The MPR can store the program arguments for retrieval by other parts of the program.</span>
<a name="l06578"></a>06578 <span class="comment"> *  @param cback Callback function to be invoked on memory allocation errors. Set to null if not required.</span>
<a name="l06579"></a>06579 <span class="comment"> *  @param shell Optional reference to an O/S implementation dependent shell object. Used by Brew.</span>
<a name="l06580"></a>06580 <span class="comment"> *  @return Returns a pointer to the Mpr object. </span>
<a name="l06581"></a>06581 <span class="comment"> *  @stability Evolving.</span>
<a name="l06582"></a>06582 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06583"></a>06583 <span class="comment"> */</span>
<a name="l06584"></a>06584 <span class="keyword">extern</span> Mpr *<a class="code" href="group___mpr.html#g045dc3d2476aebeecee838dacd0c63ba" title="Create an instance of the MPR.">mprCreateEx</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv, <a class="code" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0" title="Memory allocation error callback.">MprAllocFailure</a> cback, <span class="keywordtype">void</span> *shell);
<a name="l06585"></a>06585 
<a name="l06586"></a>06586 <span class="preprocessor">#define MPR_START_EVENTS_THREAD     0x1</span>
<a name="l06587"></a>06587 <span class="preprocessor"></span><span class="comment"></span>
<a name="l06588"></a>06588 <span class="comment">/**</span>
<a name="l06589"></a>06589 <span class="comment"> *  Start the Mpr services</span>
<a name="l06590"></a>06590 <span class="comment"> *  @param mpr Mpr object created via mprCreateMpr</span>
<a name="l06591"></a>06591 <span class="comment"> *  @param startEventsThread Set to true to start an events thread.</span>
<a name="l06592"></a>06592 <span class="comment"> */</span>
<a name="l06593"></a>06593 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#721856d6348713ef443f924013c42349" title="Start the Mpr services.">mprStart</a>(Mpr *mpr, <span class="keywordtype">int</span> startEventsThread);
<a name="l06594"></a>06594 <span class="comment"></span>
<a name="l06595"></a>06595 <span class="comment">/**</span>
<a name="l06596"></a>06596 <span class="comment"> *  Stop the MPR and shutdown all services. After this call, the MPR cannot be used.</span>
<a name="l06597"></a>06597 <span class="comment"> *  @param mpr Mpr object created via mprCreateMpr</span>
<a name="l06598"></a>06598 <span class="comment"> */</span>
<a name="l06599"></a>06599 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#f3f765dac52a91c673b6ff9f5d24da68" title="Stop the MPR and shutdown all services.">mprStop</a>(Mpr *mpr);
<a name="l06600"></a>06600 <span class="comment"></span>
<a name="l06601"></a>06601 <span class="comment">/**</span>
<a name="l06602"></a>06602 <span class="comment"> *  Signal the MPR to exit gracefully.</span>
<a name="l06603"></a>06603 <span class="comment"> *  @description Set the must exit flag for the MPR.</span>
<a name="l06604"></a>06604 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06605"></a>06605 <span class="comment"> *  @stability Evolving.</span>
<a name="l06606"></a>06606 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06607"></a>06607 <span class="comment"> */</span>
<a name="l06608"></a>06608 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr.html#gf86c5f0e03d6476670810091ba6a8d3c" title="Signal the MPR to exit gracefully.">mprSignalExit</a>(MprCtx ctx);
<a name="l06609"></a>06609 <span class="comment"></span>
<a name="l06610"></a>06610 <span class="comment">/**</span>
<a name="l06611"></a>06611 <span class="comment"> *  Determine if the MPR should exit</span>
<a name="l06612"></a>06612 <span class="comment"> *  @description Returns true if the MPR should exit gracefully.</span>
<a name="l06613"></a>06613 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06614"></a>06614 <span class="comment"> *  @returns True if the App has been instructed to exit.</span>
<a name="l06615"></a>06615 <span class="comment"> *  @stability Evolving.</span>
<a name="l06616"></a>06616 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06617"></a>06617 <span class="comment"> */</span>
<a name="l06618"></a>06618 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr.html#g1dfe792f44331fa47bb8e8cb8c04a2c7" title="Determine if the MPR should exit.">mprIsExiting</a>(MprCtx ctx);
<a name="l06619"></a>06619 <span class="comment"></span>
<a name="l06620"></a>06620 <span class="comment">/**</span>
<a name="l06621"></a>06621 <span class="comment"> *  Set the application name, title and version</span>
<a name="l06622"></a>06622 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06623"></a>06623 <span class="comment"> *  @param name One word, lower case name for the app.</span>
<a name="l06624"></a>06624 <span class="comment"> *  @param title Pascal case multi-word descriptive name.</span>
<a name="l06625"></a>06625 <span class="comment"> *  @param version Version of the app. Major-Minor-Patch. E.g. 1.2.3.</span>
<a name="l06626"></a>06626 <span class="comment"> *  @returns Zero if successful. Otherwise a negative MPR error code.</span>
<a name="l06627"></a>06627 <span class="comment"> */</span>
<a name="l06628"></a>06628 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#7e77eb84ba0cafd84b73bcc10a95376e" title="Set the application name, title and version.">mprSetAppName</a>(MprCtx ctx, cchar *name, cchar *title, cchar *version);
<a name="l06629"></a>06629 <span class="comment"></span>
<a name="l06630"></a>06630 <span class="comment">/**</span>
<a name="l06631"></a>06631 <span class="comment"> *  Get the application name defined via mprSetAppName</span>
<a name="l06632"></a>06632 <span class="comment"> *  @returns the one-word lower case application name defined via mprSetAppName</span>
<a name="l06633"></a>06633 <span class="comment"> */</span>
<a name="l06634"></a>06634 <span class="keyword">extern</span> cchar *<a class="code" href="mpr_8h.html#ee21b01fdc7627c3511f24c98252a706" title="Get the application name defined via mprSetAppName.">mprGetAppName</a>(MprCtx ctx);
<a name="l06635"></a>06635 <span class="comment"></span>
<a name="l06636"></a>06636 <span class="comment">/**</span>
<a name="l06637"></a>06637 <span class="comment"> *  Get the application executable path</span>
<a name="l06638"></a>06638 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06639"></a>06639 <span class="comment"> *  @returns A string containing the application executable path. Caller must free</span>
<a name="l06640"></a>06640 <span class="comment"> */</span>
<a name="l06641"></a>06641 <span class="keyword">extern</span> <span class="keywordtype">char</span>     *<a class="code" href="mpr_8h.html#b4545c6b9e0fc0e129525b3a7c3f41f5" title="Get the application executable path.">mprGetAppPath</a>(MprCtx ctx);
<a name="l06642"></a>06642 <span class="comment"></span>
<a name="l06643"></a>06643 <span class="comment">/**</span>
<a name="l06644"></a>06644 <span class="comment"> *  Get the application directory</span>
<a name="l06645"></a>06645 <span class="comment"> *  @description Get the directory containing the application executable.</span>
<a name="l06646"></a>06646 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06647"></a>06647 <span class="comment"> *  @returns A string containing the application directory. Caller must free.</span>
<a name="l06648"></a>06648 <span class="comment"> */</span>
<a name="l06649"></a>06649 <span class="keyword">extern</span> <span class="keywordtype">char</span>     *<a class="code" href="mpr_8h.html#de408e459ab57104df4b4c1376d3ff22" title="Get the application directory.">mprGetAppDir</a>(MprCtx ctx);
<a name="l06650"></a>06650 
<a name="l06651"></a>06651 <span class="comment">//  TODO - DOC</span>
<a name="l06652"></a>06652 <span class="keyword">extern</span> cchar    *mprGetAppTitle(MprCtx ctx);
<a name="l06653"></a>06653 <span class="keyword">extern</span> cchar    *mprGetAppVersion(MprCtx ctx);
<a name="l06654"></a>06654 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetHostName(MprCtx ctx, cchar *s);
<a name="l06655"></a>06655 <span class="keyword">extern</span> cchar    *mprGetHostName(MprCtx ctx);
<a name="l06656"></a>06656 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetServerName(MprCtx ctx, cchar *s);
<a name="l06657"></a>06657 <span class="keyword">extern</span> cchar    *mprGetServerName(MprCtx ctx);
<a name="l06658"></a>06658 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetDomainName(MprCtx ctx, cchar *s);
<a name="l06659"></a>06659 <span class="keyword">extern</span> cchar    *mprGetDomainName(MprCtx ctx);
<a name="l06660"></a>06660 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetIpAddr(MprCtx ctx, cchar *s);
<a name="l06661"></a>06661 <span class="keyword">extern</span> cchar    *mprGetIpAddr(MprCtx ctx);
<a name="l06662"></a>06662 <span class="comment"></span>
<a name="l06663"></a>06663 <span class="comment">/**</span>
<a name="l06664"></a>06664 <span class="comment"> *  Get the debug mode.</span>
<a name="l06665"></a>06665 <span class="comment"> *  @description Returns whether the debug mode is enabled. Some modules</span>
<a name="l06666"></a>06666 <span class="comment"> *      observe debug mode and disable timeouts and timers so that single-step</span>
<a name="l06667"></a>06667 <span class="comment"> *      debugging can be used.</span>
<a name="l06668"></a>06668 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06669"></a>06669 <span class="comment"> *  @return Returns true if debug mode is enabled, otherwise returns false.</span>
<a name="l06670"></a>06670 <span class="comment"> *  @stability Evolving.</span>
<a name="l06671"></a>06671 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06672"></a>06672 <span class="comment"> */</span>
<a name="l06673"></a>06673 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <a class="code" href="group___mpr.html#g1392efc11ff7ec56f8cb2e3b6fa1168c" title="Get the debug mode.">mprGetDebugMode</a>(MprCtx ctx);
<a name="l06674"></a>06674 <span class="comment"></span>
<a name="l06675"></a>06675 <span class="comment">/**</span>
<a name="l06676"></a>06676 <span class="comment"> *  Get the current logging level</span>
<a name="l06677"></a>06677 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06678"></a>06678 <span class="comment"> *  @return The current log level.</span>
<a name="l06679"></a>06679 <span class="comment"> */</span>
<a name="l06680"></a>06680 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mpr_8h.html#5a047d643f4c0b4f2dc2760aeea3e61c" title="Get the current logging level.">mprGetLogLevel</a>(MprCtx ctx);
<a name="l06681"></a>06681 <span class="comment"></span>
<a name="l06682"></a>06682 <span class="comment">/**</span>
<a name="l06683"></a>06683 <span class="comment"> *  Return the O/S error code.</span>
<a name="l06684"></a>06684 <span class="comment"> *  @description Returns an O/S error code from the most recent system call. </span>
<a name="l06685"></a>06685 <span class="comment"> *      This returns errno on Unix systems or GetLastError() on Windows..</span>
<a name="l06686"></a>06686 <span class="comment"> *  @return The O/S error code.</span>
<a name="l06687"></a>06687 <span class="comment"> *  @stability Evolving.</span>
<a name="l06688"></a>06688 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06689"></a>06689 <span class="comment"> */</span>
<a name="l06690"></a>06690 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr.html#gd2fa15bdd6890ff1df432ae25f4c981c" title="Return the O/S error code.">mprGetOsError</a>();
<a name="l06691"></a>06691 <span class="comment"></span>
<a name="l06692"></a>06692 <span class="comment">/**</span>
<a name="l06693"></a>06693 <span class="comment"> *  Return the error code for the most recent system or library operation.</span>
<a name="l06694"></a>06694 <span class="comment"> *  @description Returns an error code from the most recent system call. </span>
<a name="l06695"></a>06695 <span class="comment"> *      This will be mapped to be either a POSIX error code or an MPR error code.</span>
<a name="l06696"></a>06696 <span class="comment"> *  @return The mapped error code.</span>
<a name="l06697"></a>06697 <span class="comment"> *  @stability Evolving.</span>
<a name="l06698"></a>06698 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06699"></a>06699 <span class="comment"> */</span>
<a name="l06700"></a>06700 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="group___mpr.html#gf184a06275222c97f80e0a8d807418ac" title="Return the error code for the most recent system or library operation.">mprGetError</a>();
<a name="l06701"></a>06701 
<a name="l06702"></a>06702 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprMakeArgv(MprCtx ctx, cchar *prog, cchar *cmd, <span class="keywordtype">int</span> *argc, <span class="keywordtype">char</span> ***argv);
<a name="l06703"></a>06703 <span class="comment"></span>
<a name="l06704"></a>06704 <span class="comment">/** </span>
<a name="l06705"></a>06705 <span class="comment"> *  Turn on debug mode.</span>
<a name="l06706"></a>06706 <span class="comment"> *  @description Debug mode disables timeouts and timers. This makes debugging</span>
<a name="l06707"></a>06707 <span class="comment"> *      much easier.</span>
<a name="l06708"></a>06708 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06709"></a>06709 <span class="comment"> *  @param on Set to true to enable debugging mode.</span>
<a name="l06710"></a>06710 <span class="comment"> *  @stability Evolving.</span>
<a name="l06711"></a>06711 <span class="comment"> */</span>
<a name="l06712"></a>06712 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="mpr_8h.html#a0451f6be62ac9d8c4c9d57df6a4acfb" title="Turn on debug mode.">mprSetDebugMode</a>(MprCtx ctx, <span class="keywordtype">bool</span> on);
<a name="l06713"></a>06713 <span class="comment"></span>
<a name="l06714"></a>06714 <span class="comment">/**</span>
<a name="l06715"></a>06715 <span class="comment"> *  Set the current logging level.</span>
<a name="l06716"></a>06716 <span class="comment"> *  @description This call defines the maximum level of messages that will be</span>
<a name="l06717"></a>06717 <span class="comment"> *      logged. Calls to mprLog specify a message level. If the message level</span>
<a name="l06718"></a>06718 <span class="comment"> *      is greater than the defined logging level, the message is ignored.</span>
<a name="l06719"></a>06719 <span class="comment"> *  @param ctx Any memory context allocated by the MPR.</span>
<a name="l06720"></a>06720 <span class="comment"> *  @param level New logging level. Must be 0-9 inclusive.</span>
<a name="l06721"></a>06721 <span class="comment"> *  @return Returns the previous logging level.</span>
<a name="l06722"></a>06722 <span class="comment"> *  @stability Evolving.</span>
<a name="l06723"></a>06723 <span class="comment"> *  @ingroup MprLog</span>
<a name="l06724"></a>06724 <span class="comment"> */</span>
<a name="l06725"></a>06725 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr_log.html#g303a698e00e918f656e35e450f0ec7eb" title="Set the current logging level.">mprSetLogLevel</a>(MprCtx ctx, <span class="keywordtype">int</span> level);
<a name="l06726"></a>06726 
<a name="l06727"></a>06727 <span class="comment">//  TODO - DOC</span>
<a name="l06728"></a>06728 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSleep(MprCtx ctx, <span class="keywordtype">int</span> msec);
<a name="l06729"></a>06729 
<a name="l06730"></a>06730 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l06731"></a>06731 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span>      mprReadRegistry(MprCtx ctx, <span class="keywordtype">char</span> **buf, <span class="keywordtype">int</span> max, cchar *key, cchar *val);
<a name="l06732"></a>06732 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprWriteRegistry(MprCtx ctx, cchar *key, cchar *name, cchar *value);
<a name="l06733"></a>06733 <span class="preprocessor">#endif</span>
<a name="l06734"></a>06734 <span class="preprocessor"></span>
<a name="l06735"></a>06735 <span class="comment">//  TODO - DOC</span>
<a name="l06736"></a>06736 <span class="keyword">extern</span> <span class="keywordtype">int</span> mprStartEventsThread(Mpr *mpr);
<a name="l06737"></a>06737 <span class="comment"></span>
<a name="l06738"></a>06738 <span class="comment">/**</span>
<a name="l06739"></a>06739 <span class="comment"> *  Terminate the MPR.</span>
<a name="l06740"></a>06740 <span class="comment"> *  @description Terminates the MPR and disposes of all allocated resources. The mprTerminate</span>
<a name="l06741"></a>06741 <span class="comment"> *      function will recursively free all memory allocated by the MPR.</span>
<a name="l06742"></a>06742 <span class="comment"> *  @param ctx Any memory context object returned by #mprAlloc.</span>
<a name="l06743"></a>06743 <span class="comment"> *  @param graceful Shutdown gracefully waiting for all events to drain. Otherise exit immediately</span>
<a name="l06744"></a>06744 <span class="comment"> *      without waiting for any threads or events to complete.</span>
<a name="l06745"></a>06745 <span class="comment"> *  @stability Evolving.</span>
<a name="l06746"></a>06746 <span class="comment"> *  @ingroup Mpr</span>
<a name="l06747"></a>06747 <span class="comment"> */</span>
<a name="l06748"></a>06748 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="group___mpr.html#gedafb2bdaadd9bccf0938e8e6e31f539" title="Terminate the MPR.">mprTerminate</a>(MprCtx ctx, <span class="keywordtype">bool</span> graceful);
<a name="l06749"></a>06749 
<a name="l06750"></a>06750 <span class="keyword">extern</span> <span class="keywordtype">bool</span>     mprIsService(Mpr *mpr);
<a name="l06751"></a>06751 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetPriority(Mpr *mpr, <span class="keywordtype">int</span> pri);
<a name="l06752"></a>06752 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprWriteToOsLog(MprCtx ctx, cchar *msg, <span class="keywordtype">int</span> flags, <span class="keywordtype">int</span> level);
<a name="l06753"></a>06753 
<a name="l06754"></a>06754 <span class="preprocessor">#if BLD_WIN_LIKE</span>
<a name="l06755"></a>06755 <span class="preprocessor"></span><span class="keyword">extern</span> HWND     mprGetHwnd(MprCtx ctx);
<a name="l06756"></a>06756 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetHwnd(MprCtx ctx, HWND h);
<a name="l06757"></a>06757 <span class="keyword">extern</span> <span class="keywordtype">long</span>     mprGetInst(MprCtx ctx);
<a name="l06758"></a>06758 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetInst(MprCtx ctx, <span class="keywordtype">long</span> inst);
<a name="l06759"></a>06759 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprSetSocketMessage(MprCtx ctx, <span class="keywordtype">int</span> message);
<a name="l06760"></a>06760 <span class="preprocessor">#endif</span>
<a name="l06761"></a>06761 <span class="preprocessor"></span>
<a name="l06762"></a>06762 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprGetRandomBytes(MprCtx ctx, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> block);
<a name="l06763"></a>06763 
<a name="l06764"></a>06764 <span class="comment">//  TODO - doc</span>
<a name="l06765"></a>06765 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprGetEndian(MprCtx ctx);
<a name="l06766"></a>06766 
<a name="l06767"></a>06767 <span class="comment">/* ******************************** Encoding **********************************/</span>
<a name="l06768"></a>06768 <span class="comment">/*  Character encoding masks</span>
<a name="l06769"></a>06769 <span class="comment"> */</span>
<a name="l06770"></a>06770 <span class="preprocessor">#define MPR_ENCODE_HTML            0x1</span>
<a name="l06771"></a>06771 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ENCODE_SHELL           0x2</span>
<a name="l06772"></a>06772 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ENCODE_URI             0x4</span>
<a name="l06773"></a>06773 <span class="preprocessor"></span><span class="preprocessor">#define MPR_ENCODE_URI_COMPONENT   0x8</span>
<a name="l06774"></a>06774 <span class="preprocessor"></span><span class="comment"></span>
<a name="l06775"></a>06775 <span class="comment">/** Encode a string escaping typical command (shell) characters</span>
<a name="l06776"></a>06776 <span class="comment">    @description Encode a string escaping all dangerous characters that have meaning for the unix or MS-DOS command shells.</span>
<a name="l06777"></a>06777 <span class="comment">    @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06778"></a>06778 <span class="comment">    @param cmd Command string to encode</span>
<a name="l06779"></a>06779 <span class="comment">    @param escChar Escape character to use when encoding the command.</span>
<a name="l06780"></a>06780 <span class="comment">    @return An allocated string containing the escaped command. Caller must free using #mprFree.</span>
<a name="l06781"></a>06781 <span class="comment">    @ingroup HttpUri</span>
<a name="l06782"></a>06782 <span class="comment"> */</span>
<a name="l06783"></a>06783 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#43b32087d8a020c9fc1ed976a8e4371d" title="Encode a string escaping typical command (shell) characters.">mprEscapeCmd</a>(MprCtx ctx, cchar *cmd, <span class="keywordtype">int</span> escChar);
<a name="l06784"></a>06784 <span class="comment"></span>
<a name="l06785"></a>06785 <span class="comment">/**</span>
<a name="l06786"></a>06786 <span class="comment">    Encode a string by escaping typical HTML characters</span>
<a name="l06787"></a>06787 <span class="comment">    @description Encode a string escaping all dangerous characters that have meaning in HTML documents</span>
<a name="l06788"></a>06788 <span class="comment">    @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06789"></a>06789 <span class="comment">    @param html HTML content to encode</span>
<a name="l06790"></a>06790 <span class="comment">    @return An allocated string containing the escaped HTML. Caller must free using #mprFree.</span>
<a name="l06791"></a>06791 <span class="comment">    @ingroup HttpUri</span>
<a name="l06792"></a>06792 <span class="comment"> */</span>
<a name="l06793"></a>06793 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#4f15488d5680bfabf4f243c863d98314" title="Encode a string by escaping typical HTML characters.">mprEscapeHtml</a>(MprCtx ctx, cchar *html);
<a name="l06794"></a>06794 <span class="comment"></span>
<a name="l06795"></a>06795 <span class="comment">/** Get the mime type for an extension.</span>
<a name="l06796"></a>06796 <span class="comment">    This call will return the mime type from a limited internal set of mime types for the given path or extension.</span>
<a name="l06797"></a>06797 <span class="comment">    @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06798"></a>06798 <span class="comment">    @param ext Path or extension to examine</span>
<a name="l06799"></a>06799 <span class="comment">    @returns Mime type. This is a static string. Caller must not free.</span>
<a name="l06800"></a>06800 <span class="comment"> */</span>
<a name="l06801"></a>06801 <span class="keyword">extern</span> cchar *<a class="code" href="mpr_8h.html#92480f400bf2488c4901993123df7de6" title="Get the mime type for an extension.">mprLookupMimeType</a>(MprCtx ctx, cchar *ext);
<a name="l06802"></a>06802 <span class="comment"></span>
<a name="l06803"></a>06803 <span class="comment">/** Encode a string by escaping URI characters</span>
<a name="l06804"></a>06804 <span class="comment">    @description Encode a string escaping all characters that have meaning for URIs.</span>
<a name="l06805"></a>06805 <span class="comment">    @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06806"></a>06806 <span class="comment">    @param uri URI to encode</span>
<a name="l06807"></a>06807 <span class="comment">    @param map Map to encode characters. Select from MPR_ENCODE_URI or MPR_ENCODE_URI_COMPONENT.</span>
<a name="l06808"></a>06808 <span class="comment">    @return An allocated string containing the encoded URI. Caller must free using #mprFree.</span>
<a name="l06809"></a>06809 <span class="comment">    @ingroup HttpUri</span>
<a name="l06810"></a>06810 <span class="comment"> */</span>
<a name="l06811"></a>06811 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#ff8a0ff793cc8e580ace3501d6949173" title="Encode a string by escaping URI characters.">mprUriEncode</a>(MprCtx ctx, cchar *uri, <span class="keywordtype">int</span> map);
<a name="l06812"></a>06812 <span class="comment"></span>
<a name="l06813"></a>06813 <span class="comment">/** Decode a URI string by de-scaping URI characters</span>
<a name="l06814"></a>06814 <span class="comment">    @description Decode a string with www-encoded characters that have meaning for URIs.</span>
<a name="l06815"></a>06815 <span class="comment">    @param ctx Any memory allocation context created by MprAlloc</span>
<a name="l06816"></a>06816 <span class="comment">    @param uri URI to decode</span>
<a name="l06817"></a>06817 <span class="comment">    @return A reference to the buf argument.</span>
<a name="l06818"></a>06818 <span class="comment">    @ingroup HttpUri</span>
<a name="l06819"></a>06819 <span class="comment"> */</span>
<a name="l06820"></a>06820 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="mpr_8h.html#42505a60e5679606bc22d8c1aa1dc4ba" title="Decode a URI string by de-scaping URI characters.">mprUriDecode</a>(MprCtx ctx, cchar *uri);
<a name="l06821"></a>06821 
<a name="l06822"></a>06822 <span class="comment">/* ******************************** Unicode ***********************************/</span>
<a name="l06823"></a>06823 
<a name="l06824"></a>06824 <span class="preprocessor">#if WIN || WINCE</span>
<a name="l06825"></a>06825 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">char</span>* mprToAsc(MprCtx ctx, cuni *u);
<a name="l06826"></a>06826 <span class="keyword">extern</span> uni* mprToUni(MprCtx ctx, cchar* a);
<a name="l06827"></a>06827 <span class="preprocessor">#endif</span>
<a name="l06828"></a>06828 <span class="preprocessor"></span>
<a name="l06829"></a>06829 <span class="preprocessor">#if FUTURE</span>
<a name="l06830"></a>06830 <span class="preprocessor"></span><span class="preprocessor">#define BLD_FEATURE_UTF16  1</span>
<a name="l06831"></a>06831 <span class="preprocessor"></span><span class="preprocessor">#if BLD_FEATURE_UTF16</span>
<a name="l06832"></a>06832 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">short</span> MprUsData;
<a name="l06833"></a>06833 <span class="preprocessor">#else</span>
<a name="l06834"></a>06834 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">char</span> MprUsData;
<a name="l06835"></a>06835 <span class="preprocessor">#endif</span>
<a name="l06836"></a>06836 <span class="preprocessor"></span>
<a name="l06837"></a>06837 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprUs {
<a name="l06838"></a>06838     MprUsData   *str;
<a name="l06839"></a>06839     <span class="keywordtype">int</span>         length;
<a name="l06840"></a>06840 } MprUs;
<a name="l06841"></a>06841 
<a name="l06842"></a>06842 
<a name="l06843"></a>06843 <span class="keyword">extern</span> MprUs    *mprAllocUs(MprCtx ctx);
<a name="l06844"></a>06844 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprCopyUs(MprUs *dest, MprUs *src);
<a name="l06845"></a>06845 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprCatUs(MprUs *dest, MprUs *src);
<a name="l06846"></a>06846 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprCatUsArgs(MprUs *dest, MprUs *src, ...);
<a name="l06847"></a>06847 <span class="keyword">extern</span> MprUs    *mprDupUs(MprUs *us);
<a name="l06848"></a>06848 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprCopyStrToUs(MprUs *dest, cchar *str);
<a name="l06849"></a>06849 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprGetUsLength(MprUs *us);
<a name="l06850"></a>06850 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprContainsChar(MprUs *us, <span class="keywordtype">int</span> charPat);
<a name="l06851"></a>06851 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprContainsUs(MprUs *us, MprUs *pat);
<a name="l06852"></a>06852 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprContainsCaselessUs(MprUs *us, MprUs *pat);
<a name="l06853"></a>06853 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprContainsStr(MprUs *us, cchar *pat);
<a name="l06854"></a>06854 <span class="preprocessor">#if FUTURE</span>
<a name="l06855"></a>06855 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span>      mprContainsPattern(MprUs *us, MprRegex *pat);
<a name="l06856"></a>06856 <span class="preprocessor">#endif</span>
<a name="l06857"></a>06857 <span class="preprocessor"></span><span class="keyword">extern</span> MprUs    *mprTrimUs(MprUs *dest, MprUs *pat);
<a name="l06858"></a>06858 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprTruncateUs(MprUs *dest, <span class="keywordtype">int</span> len);
<a name="l06859"></a>06859 <span class="keyword">extern</span> MprUs    *mprSubUs(MprUs *dest, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> len);
<a name="l06860"></a>06860 <span class="keyword">extern</span> MprUs    *mprMemToUs(MprCtx ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len);
<a name="l06861"></a>06861 <span class="keyword">extern</span> MprUs    *mprStrToUs(MprCtx ctx, cchar *str);
<a name="l06862"></a>06862 <span class="keyword">extern</span> <span class="keywordtype">char</span>     *mprUsToStr(MprUs *us);
<a name="l06863"></a>06863 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprUsToLower(MprUs *us);
<a name="l06864"></a>06864 <span class="keyword">extern</span> <span class="keywordtype">void</span>     mprUsToUpper(MprUs *us);
<a name="l06865"></a>06865 <span class="keyword">extern</span> MprUs    *mprTokenizeUs(MprUs *us, MprUs *delim, <span class="keywordtype">int</span> *last);
<a name="l06866"></a>06866 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprFormatUs(MprUs *us, <span class="keywordtype">int</span> maxSize, cchar *fmt, ...);
<a name="l06867"></a>06867 <span class="keyword">extern</span> <span class="keywordtype">int</span>      mprScanUs(MprUs *us, cchar *fmt, ...);
<a name="l06868"></a>06868 
<a name="l06869"></a>06869 <span class="comment">/*</span>
<a name="l06870"></a>06870 <span class="comment"> *  What about:</span>
<a name="l06871"></a>06871 <span class="comment"> *      isdigit, isalpha, isalnum, isupper, islower, isspace</span>
<a name="l06872"></a>06872 <span class="comment"> *      replace</span>
<a name="l06873"></a>06873 <span class="comment"> *      reverse</span>
<a name="l06874"></a>06874 <span class="comment"> *      split</span>
<a name="l06875"></a>06875 <span class="comment"> *          extern MprList *mprSplit(MprUs *us, MprUs *delim)</span>
<a name="l06876"></a>06876 <span class="comment"> */</span>
<a name="l06877"></a>06877 <span class="preprocessor">#endif</span>
<a name="l06878"></a>06878 <span class="preprocessor"></span>
<a name="l06879"></a>06879 <span class="comment">/* ****************************************************************************/</span>
<a name="l06880"></a>06880 <span class="comment">/*</span>
<a name="l06881"></a>06881 <span class="comment">   External dependencies</span>
<a name="l06882"></a>06882 <span class="comment"> */</span>
<a name="l06883"></a>06883 <span class="keyword">extern</span> <span class="keywordtype">char</span> *dtoa(<span class="keywordtype">double</span> d, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> ndigits, <span class="keywordtype">int</span>* decpt, <span class="keywordtype">int</span>* sign, <span class="keywordtype">char</span>** rve);
<a name="l06884"></a>06884 <span class="keyword">extern</span> <span class="keywordtype">void</span> freedtoa(<span class="keywordtype">char</span>* ptr);
<a name="l06885"></a>06885 
<a name="l06886"></a>06886 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l06887"></a>06887 <span class="preprocessor"></span>}
<a name="l06888"></a>06888 <span class="preprocessor">#endif</span>
<a name="l06889"></a>06889 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* _h_MPR */</span>
<a name="l06890"></a>06890 
<a name="l06891"></a>06891 <span class="comment">/*</span>
<a name="l06892"></a>06892 <span class="comment"> *  @copy   default</span>
<a name="l06893"></a>06893 <span class="comment"> *</span>
<a name="l06894"></a>06894 <span class="comment"> *  Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.</span>
<a name="l06895"></a>06895 <span class="comment"> *  Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.</span>
<a name="l06896"></a>06896 <span class="comment"> *</span>
<a name="l06897"></a>06897 <span class="comment"> *  This software is distributed under commercial and open source licenses.</span>
<a name="l06898"></a>06898 <span class="comment"> *  You may use the GPL open source license described below or you may acquire</span>
<a name="l06899"></a>06899 <span class="comment"> *  a commercial license from Embedthis Software. You agree to be fully bound</span>
<a name="l06900"></a>06900 <span class="comment"> *  by the terms of either license. Consult the LICENSE.TXT distributed with</span>
<a name="l06901"></a>06901 <span class="comment"> *  this software for full details.</span>
<a name="l06902"></a>06902 <span class="comment"> *</span>
<a name="l06903"></a>06903 <span class="comment"> *  This software is open source; you can redistribute it and/or modify it</span>
<a name="l06904"></a>06904 <span class="comment"> *  under the terms of the GNU General Public License as published by the</span>
<a name="l06905"></a>06905 <span class="comment"> *  Free Software Foundation; either version 2 of the License, or (at your</span>
<a name="l06906"></a>06906 <span class="comment"> *  option) any later version. See the GNU General Public License for more</span>
<a name="l06907"></a>06907 <span class="comment"> *  details at: http://www.embedthis.com/downloads/gplLicense.html</span>
<a name="l06908"></a>06908 <span class="comment"> *</span>
<a name="l06909"></a>06909 <span class="comment"> *  This program is distributed WITHOUT ANY WARRANTY; without even the</span>
<a name="l06910"></a>06910 <span class="comment"> *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l06911"></a>06911 <span class="comment"> *</span>
<a name="l06912"></a>06912 <span class="comment"> *  This GPL license does NOT permit incorporating this software into</span>
<a name="l06913"></a>06913 <span class="comment"> *  proprietary programs. If you are unable to comply with the GPL, you must</span>
<a name="l06914"></a>06914 <span class="comment"> *  acquire a commercial license to use this software. Commercial licenses</span>
<a name="l06915"></a>06915 <span class="comment"> *  for this software and support services are available from Embedthis</span>
<a name="l06916"></a>06916 <span class="comment"> *  Software at http://www.embedthis.com</span>
<a name="l06917"></a>06917 <span class="comment"> *</span>
<a name="l06918"></a>06918 <span class="comment"> *  Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=8 ts=8 expandtab

    @end</span>
<a name="l06919"></a>06919 <span class="comment"> */</span>
<a name="l06920"></a>06920 <span class="comment">/************************************************************************/</span>
<a name="l06921"></a>06921 <span class="comment">/*</span>
<a name="l06922"></a>06922 <span class="comment"> *  End of file "../src/include/mpr.h"</span>
<a name="l06923"></a>06923 <span class="comment"> */</span>
<a name="l06924"></a>06924 <span class="comment">/************************************************************************/</span>
<a name="l06925"></a>06925 
<a name="l06926"></a>06926 
<a name="l06927"></a>06927 
<a name="l06928"></a>06928 <span class="comment">/************************************************************************/</span>
<a name="l06929"></a>06929 <span class="comment">/*</span>
<a name="l06930"></a>06930 <span class="comment"> *  Start of file "../src/include/mprTest.h"</span>
<a name="l06931"></a>06931 <span class="comment"> */</span>
<a name="l06932"></a>06932 <span class="comment">/************************************************************************/</span>
<a name="l06933"></a>06933 
<a name="l06934"></a>06934 <span class="comment">/*</span>
<a name="l06935"></a>06935 <span class="comment"> *  mprTest.h - Header for the Embedthis Unit Test Framework</span>
<a name="l06936"></a>06936 <span class="comment"> *  </span>
<a name="l06937"></a>06937 <span class="comment"> *  Copyright (c) All Rights Reserved. See details at the end of the file.</span>
<a name="l06938"></a>06938 <span class="comment"> */</span>
<a name="l06939"></a>06939 
<a name="l06940"></a>06940 
<a name="l06941"></a>06941 <span class="preprocessor">#ifndef _h_MPR_TEST</span>
<a name="l06942"></a>06942 <span class="preprocessor"></span><span class="preprocessor">#define _h_MPR_TEST 1</span>
<a name="l06943"></a>06943 <span class="preprocessor"></span>
<a name="l06944"></a>06944 
<a name="l06945"></a>06945 
<a name="l06946"></a>06946 <span class="preprocessor">#if BLD_FEATURE_TEST</span>
<a name="l06947"></a>06947 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06948"></a>06948 <span class="comment"> *  Tunable constants</span>
<a name="l06949"></a>06949 <span class="comment"> */</span>
<a name="l06950"></a>06950 <span class="preprocessor">#define MPR_TEST_POLL_NAP       25</span>
<a name="l06951"></a>06951 <span class="preprocessor"></span><span class="preprocessor">#define MPR_TEST_SLEEP          (60 * 1000)</span>
<a name="l06952"></a>06952 <span class="preprocessor"></span><span class="preprocessor">#define MPR_TEST_MAX_STACK      (16)</span>
<a name="l06953"></a>06953 <span class="preprocessor"></span>
<a name="l06954"></a>06954 <span class="preprocessor">#define MPR_TEST_TIMEOUT        10000       </span><span class="comment">/* Ten seconds */</span>
<a name="l06955"></a>06955 <span class="preprocessor">#define MPR_TEST_LONG_TIMEOUT   300000      </span><span class="comment">/* 5 minutes */</span>
<a name="l06956"></a>06956 <span class="preprocessor">#define MPR_TEST_SHORT_TIMEOUT  200         </span><span class="comment">/* 1/5 sec */</span>
<a name="l06957"></a>06957 <span class="preprocessor">#define MPR_TEST_NAP            50          </span><span class="comment">/* Short timeout to prevent busy waiting */</span>
<a name="l06958"></a>06958 
<a name="l06959"></a>06959 <span class="comment">/*</span>
<a name="l06960"></a>06960 <span class="comment"> *  Unit test definition structures</span>
<a name="l06961"></a>06961 <span class="comment"> */</span>
<a name="l06962"></a>06962 <span class="keyword">struct </span>MprTestGroup;
<a name="l06963"></a>06963 <span class="keyword">typedef</span> void        (*MprTestProc)(<span class="keyword">struct </span>MprTestGroup *tp);
<a name="l06964"></a>06964 
<a name="l06965"></a>06965 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprTestCase {
<a name="l06966"></a>06966     <span class="keywordtype">char</span>            *name;
<a name="l06967"></a>06967     <span class="keywordtype">int</span>             level;
<a name="l06968"></a>06968     MprTestProc     proc;
<a name="l06969"></a>06969     int             (*init)(<span class="keyword">struct </span>MprTestGroup *gp);
<a name="l06970"></a>06970     int             (*term)(<span class="keyword">struct </span>MprTestGroup *gp);
<a name="l06971"></a>06971 } MprTestCase;
<a name="l06972"></a>06972 
<a name="l06973"></a>06973 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprTestDef {
<a name="l06974"></a>06974     <span class="keywordtype">char</span>                *name;
<a name="l06975"></a>06975     <span class="keyword">struct </span>MprTestDef   **groupDefs;
<a name="l06976"></a>06976     int                 (*init)(<span class="keyword">struct </span>MprTestGroup *gp);
<a name="l06977"></a>06977     int                 (*term)(<span class="keyword">struct </span>MprTestGroup *gp);
<a name="l06978"></a>06978     MprTestCase         caseDefs[32];
<a name="l06979"></a>06979 } MprTestDef;
<a name="l06980"></a>06980 
<a name="l06981"></a>06981 
<a name="l06982"></a>06982 <span class="comment">/*</span>
<a name="l06983"></a>06983 <span class="comment"> *  Assert macros for use by unit tests</span>
<a name="l06984"></a>06984 <span class="comment"> */</span>
<a name="l06985"></a>06985 <span class="preprocessor">#undef  assert</span>
<a name="l06986"></a>06986 <span class="preprocessor"></span><span class="preprocessor">#define assert(C)   assertTrue(gp, MPR_LOC, C, #C)</span>
<a name="l06987"></a>06987 <span class="preprocessor"></span>
<a name="l06988"></a>06988 <span class="preprocessor">#define MPR_TEST(level, functionName) { #functionName, level, functionName, 0, 0 }</span>
<a name="l06989"></a>06989 <span class="preprocessor"></span>
<a name="l06990"></a>06990 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprTestService {
<a name="l06991"></a>06991     <span class="keywordtype">int</span>             argc;                   <span class="comment">/* Count of arguments */</span>
<a name="l06992"></a>06992     <span class="keywordtype">char</span>            **argv;                 <span class="comment">/* Arguments for test */</span>
<a name="l06993"></a>06993     <span class="keywordtype">int</span>             activeThreadCount;      <span class="comment">/* Currently active test threads */</span>
<a name="l06994"></a>06994     <span class="keywordtype">char</span>            *commandLine;
<a name="l06995"></a>06995     <span class="keywordtype">bool</span>            continueOnFailures;     <span class="comment">/* Keep testing on failures */</span>
<a name="l06996"></a>06996     <span class="keywordtype">bool</span>            debugOnFailures;        <span class="comment">/* Break to the debugger */</span>
<a name="l06997"></a>06997     <span class="keywordtype">int</span>             echoCmdLine;            <span class="comment">/* Echo the command line */</span>
<a name="l06998"></a>06998     <span class="keywordtype">int</span>             firstArg;               <span class="comment">/* Count of arguments */</span>
<a name="l06999"></a>06999     MprList         *groups;                <span class="comment">/* Master list of test groups */</span>
<a name="l07000"></a>07000     <span class="keywordtype">int</span>             iterations;             <span class="comment">/* Times to run the test */</span>
<a name="l07001"></a>07001     <span class="keywordtype">bool</span>            singleStep;             <span class="comment">/* Pause between tests */</span>
<a name="l07002"></a>07002     cchar           *name;                  <span class="comment">/* Name for entire test */</span>
<a name="l07003"></a>07003     <span class="keywordtype">int</span>             numThreads;             <span class="comment">/* Number of test threads */</span>
<a name="l07004"></a>07004     <span class="keywordtype">int</span>             workers;                <span class="comment">/* Count of worker threads */</span>
<a name="l07005"></a>07005     <a class="code" href="group___mpr_date.html#gdd377cb2c4ec9c665b99de02f87f768b" title="Mpr time structure.">MprTime</a>         start;                  <span class="comment">/* When testing began */</span>
<a name="l07006"></a>07006     <span class="keywordtype">int</span>             testDepth;              <span class="comment">/* Depth of entire test */</span>
<a name="l07007"></a>07007     MprList         *perThreadGroups;       <span class="comment">/* Per thread copy of groups */</span>
<a name="l07008"></a>07008     <span class="keywordtype">int</span>             totalFailedCount;       <span class="comment">/* Total count of failing tests */</span>
<a name="l07009"></a>07009     <span class="keywordtype">int</span>             totalTestCount;         <span class="comment">/* Total count of all tests */</span>
<a name="l07010"></a>07010     MprList         *testFilter;            <span class="comment">/* Test groups to run */</span>
<a name="l07011"></a>07011     <span class="keywordtype">int</span>             verbose;                <span class="comment">/* Output activity trace */</span>
<a name="l07012"></a>07012 
<a name="l07013"></a>07013 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l07014"></a>07014 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;                 <span class="comment">/* Multi-thread sync */</span>
<a name="l07015"></a>07015 <span class="preprocessor">#endif</span>
<a name="l07016"></a>07016 <span class="preprocessor"></span>} MprTestService;
<a name="l07017"></a>07017 
<a name="l07018"></a>07018 <span class="keyword">extern</span> MprTestService *mprCreateTestService(<a class="code" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f" title="Memory context type.">MprCtx</a> ctx);
<a name="l07019"></a>07019 <span class="keyword">extern</span> <span class="keywordtype">int</span>          mprParseTestArgs(MprTestService *ts, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);
<a name="l07020"></a>07020 <span class="keyword">extern</span> <span class="keywordtype">int</span>          mprRunTests(MprTestService *sp);
<a name="l07021"></a>07021 <span class="keyword">extern</span> <span class="keywordtype">void</span>         mprReportTestResults(MprTestService *sp);
<a name="l07022"></a>07022 
<a name="l07023"></a>07023 <span class="comment">/*</span>
<a name="l07024"></a>07024 <span class="comment"> *  A test group is a group of tests to cover a unit of functionality. A test group may contain other test groups.</span>
<a name="l07025"></a>07025 <span class="comment"> */</span>
<a name="l07026"></a>07026 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprTestGroup {
<a name="l07027"></a>07027     <span class="keywordtype">char</span>            *name;                  <span class="comment">/* Name of test */</span>
<a name="l07028"></a>07028     <span class="keywordtype">char</span>            *fullName;              <span class="comment">/* Fully qualified name of test */</span>
<a name="l07029"></a>07029     <span class="keywordtype">int</span>             testDepth;              <span class="comment">/* Depth at which test should run */</span>
<a name="l07030"></a>07030     <span class="keywordtype">bool</span>            skip;                   <span class="comment">/* Skip this test */</span>
<a name="l07031"></a>07031     <span class="keywordtype">bool</span>            skipWarned;             <span class="comment">/* Warned that test will be skipped */</span>
<a name="l07032"></a>07032 
<a name="l07033"></a>07033     <span class="keywordtype">bool</span>            success;                <span class="comment">/* Result of last run */</span>
<a name="l07034"></a>07034     <span class="keywordtype">int</span>             failedCount;            <span class="comment">/* Total failures of this test */</span>
<a name="l07035"></a>07035     <span class="keywordtype">int</span>             testCount;              <span class="comment">/* Count of tests */</span>
<a name="l07036"></a>07036     MprList         *failures;              <span class="comment">/* List of all failures */</span>
<a name="l07037"></a>07037 
<a name="l07038"></a>07038     MprTestService  *service;               <span class="comment">/* Reference to the service */</span>
<a name="l07039"></a>07039     <span class="keyword">struct </span>MprTestGroup *parent;            <span class="comment">/* Parent test group */</span>
<a name="l07040"></a>07040     <span class="keyword">struct </span>MprTestGroup *root;              <span class="comment">/* Top level test group parent */</span>
<a name="l07041"></a>07041 
<a name="l07042"></a>07042     MprList         *groups;                <span class="comment">/* List of groups */</span>
<a name="l07043"></a>07043     MprList         *cases;                 <span class="comment">/* List of tests in this group */</span>
<a name="l07044"></a>07044     MprTestDef      *def;                   <span class="comment">/* Test definition ref */</span>
<a name="l07045"></a>07045 
<a name="l07046"></a>07046     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *cond;                  <span class="comment">/* Multi-thread sync */</span>
<a name="l07047"></a>07047     <a class="code" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>         *cond2;                 <span class="comment">/* Second multi-thread sync */</span>
<a name="l07048"></a>07048 
<a name="l07049"></a>07049     <span class="comment">//  TODO - remove</span>
<a name="l07050"></a>07050 <span class="preprocessor">#if BLD_FEATURE_HTTP_CLIENT</span>
<a name="l07051"></a>07051 <span class="preprocessor"></span>    <span class="keyword">struct </span>Http     *http;                  <span class="comment">/* Http service */</span>
<a name="l07052"></a>07052     <span class="keyword">struct </span>HttpConn *conn;                  <span class="comment">/* Http connection for this group */</span>
<a name="l07053"></a>07053     <span class="keywordtype">char</span>            *content;               <span class="comment">/* Cached response content */</span>
<a name="l07054"></a>07054 <span class="preprocessor">#endif</span>
<a name="l07055"></a>07055 <span class="preprocessor"></span>
<a name="l07056"></a>07056     <span class="keywordtype">void</span>            *data;                  <span class="comment">/* Test specific data */</span>
<a name="l07057"></a>07057     <a class="code" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f" title="Memory context type.">MprCtx</a>          ctx;                    <span class="comment">/* Memory context for unit tests to use */</span>
<a name="l07058"></a>07058     <span class="keywordtype">int</span>             hasInternet;            <span class="comment">/* Convenience flag for internet available for use */</span>
<a name="l07059"></a>07059     
<a name="l07060"></a>07060 <span class="preprocessor">#if BLD_FEATURE_MULTITHREAD</span>
<a name="l07061"></a>07061 <span class="preprocessor"></span>    <a class="code" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>        *mutex;                 <span class="comment">/* Multi-thread sync */</span>
<a name="l07062"></a>07062 <span class="preprocessor">#endif</span>
<a name="l07063"></a>07063 <span class="preprocessor"></span>
<a name="l07064"></a>07064 } MprTestGroup;
<a name="l07065"></a>07065 
<a name="l07066"></a>07066 
<a name="l07067"></a>07067 <span class="keyword">extern</span> MprTestGroup *mprAddTestGroup(MprTestService *ts, MprTestDef *def);
<a name="l07068"></a>07068 <span class="keyword">extern</span> <span class="keywordtype">void</span>         mprResetTestGroup(MprTestGroup *gp);
<a name="l07069"></a>07069 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         assertTrue(MprTestGroup *gp, cchar *loc, <span class="keywordtype">bool</span> success, cchar *msg);
<a name="l07070"></a>07070 <span class="keyword">extern</span> <span class="keywordtype">void</span>         mprSignalTestComplete(MprTestGroup *gp);
<a name="l07071"></a>07071 <span class="keyword">extern</span> <span class="keywordtype">void</span>         mprSignalTest2Complete(MprTestGroup *gp);
<a name="l07072"></a>07072 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         mprWaitForTestToComplete(MprTestGroup *gp, <span class="keywordtype">int</span> timeout);
<a name="l07073"></a>07073 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         mprWaitForTest2ToComplete(MprTestGroup *gp, <span class="keywordtype">int</span> timeout);
<a name="l07074"></a>07074 
<a name="l07075"></a>07075 
<a name="l07076"></a>07076 <span class="keyword">typedef</span> <span class="keyword">struct </span>MprTestFailure {
<a name="l07077"></a>07077     <span class="keywordtype">char</span>            *loc;
<a name="l07078"></a>07078     <span class="keywordtype">char</span>            *message;
<a name="l07079"></a>07079 } MprTestFailure;
<a name="l07080"></a>07080 
<a name="l07081"></a>07081 
<a name="l07082"></a>07082 <span class="preprocessor">#endif </span><span class="comment">/* BLD_FEATURE_TEST */</span>
<a name="l07083"></a>07083 <span class="preprocessor">#endif </span><span class="comment">/* _h_MPR_TEST */</span>
<a name="l07084"></a>07084 
<a name="l07085"></a>07085 
<a name="l07086"></a>07086 <span class="comment">/*</span>
<a name="l07087"></a>07087 <span class="comment"> *  @copy   default</span>
<a name="l07088"></a>07088 <span class="comment"> *  </span>
<a name="l07089"></a>07089 <span class="comment"> *  Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.</span>
<a name="l07090"></a>07090 <span class="comment"> *  Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.</span>
<a name="l07091"></a>07091 <span class="comment"> *  </span>
<a name="l07092"></a>07092 <span class="comment"> *  This software is distributed under commercial and open source licenses.</span>
<a name="l07093"></a>07093 <span class="comment"> *  You may use the GPL open source license described below or you may acquire </span>
<a name="l07094"></a>07094 <span class="comment"> *  a commercial license from Embedthis Software. You agree to be fully bound </span>
<a name="l07095"></a>07095 <span class="comment"> *  by the terms of either license. Consult the LICENSE.TXT distributed with </span>
<a name="l07096"></a>07096 <span class="comment"> *  this software for full details.</span>
<a name="l07097"></a>07097 <span class="comment"> *  </span>
<a name="l07098"></a>07098 <span class="comment"> *  This software is open source; you can redistribute it and/or modify it </span>
<a name="l07099"></a>07099 <span class="comment"> *  under the terms of the GNU General Public License as published by the </span>
<a name="l07100"></a>07100 <span class="comment"> *  Free Software Foundation; either version 2 of the License, or (at your </span>
<a name="l07101"></a>07101 <span class="comment"> *  option) any later version. See the GNU General Public License for more </span>
<a name="l07102"></a>07102 <span class="comment"> *  details at: http://www.embedthis.com/downloads/gplLicense.html</span>
<a name="l07103"></a>07103 <span class="comment"> *  </span>
<a name="l07104"></a>07104 <span class="comment"> *  This program is distributed WITHOUT ANY WARRANTY; without even the </span>
<a name="l07105"></a>07105 <span class="comment"> *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </span>
<a name="l07106"></a>07106 <span class="comment"> *  </span>
<a name="l07107"></a>07107 <span class="comment"> *  This GPL license does NOT permit incorporating this software into </span>
<a name="l07108"></a>07108 <span class="comment"> *  proprietary programs. If you are unable to comply with the GPL, you must</span>
<a name="l07109"></a>07109 <span class="comment"> *  acquire a commercial license to use this software. Commercial licenses </span>
<a name="l07110"></a>07110 <span class="comment"> *  for this software and support services are available from Embedthis </span>
<a name="l07111"></a>07111 <span class="comment"> *  Software at http://www.embedthis.com </span>
<a name="l07112"></a>07112 <span class="comment"> *  </span>
<a name="l07113"></a>07113 <span class="comment"> *  Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=8 ts=8 expandtab

    @end</span>
<a name="l07114"></a>07114 <span class="comment"> */</span>
<a name="l07115"></a>07115 <span class="comment">/************************************************************************/</span>
<a name="l07116"></a>07116 <span class="comment">/*</span>
<a name="l07117"></a>07117 <span class="comment"> *  End of file "../src/include/mprTest.h"</span>
<a name="l07118"></a>07118 <span class="comment"> */</span>
<a name="l07119"></a>07119 <span class="comment">/************************************************************************/</span>
<a name="l07120"></a>07120 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jan 19 11:56:18 2011 for mpr by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
