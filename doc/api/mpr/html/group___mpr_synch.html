<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mpr: MprSynch</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>MprSynch</h1>Multithreaded Synchronization Services.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_cond.html">MprCond</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Condition variable for single and multi-thread synchronization.  <a href="struct_mpr_cond.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_mutex.html">MprMutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multithreading lock control structure.  <a href="struct_mpr_mutex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_spin.html">MprSpin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multithreading spin lock control structure.  <a href="struct_mpr_spin.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f">mprCreateCond</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a condition lock variable.  <a href="#g30046b7108565283ac168c6a90739a3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g825387252381219bd94edfa9c60855fa">mprCreateLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Mutex lock object.  <a href="#g825387252381219bd94edfa9c60855fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#ge63f87a8d093d294bd1ce6747cbb42ec">mprCreateSpinLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a spin lock lock object.  <a href="#ge63f87a8d093d294bd1ce6747cbb42ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g934273252bb4202c8adeb9d8841769a4">mprGlobalLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally lock the application.  <a href="#g934273252bb4202c8adeb9d8841769a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g9af03d596ad19cd7974d85d82a8c27ca">mprGlobalUnlock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the global mutex.  <a href="#g9af03d596ad19cd7974d85d82a8c27ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#ge5ac7172314ec00d74bc8a5b61ee98fa">mprInitLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="struct_mpr_mutex.html">MprMutex</a> *mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a statically allocated Mutex lock object.  <a href="#ge5ac7172314ec00d74bc8a5b61ee98fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gd0e8debf5fc06d66c839ef8979d8e4c9">mprInitSpinLock</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, <a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a statically allocated spinlock object.  <a href="#gd0e8debf5fc06d66c839ef8979d8e4c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede">mprLock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock access.  <a href="#gd193cb5549a1101dc17177f046144ede"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b">mprSignalCond</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal a condition lock variable.  <a href="#gb014329886bcb9a8cb9b970afc30378b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795">mprSpinLock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a spinlock.  <a href="#gf2a84bc9cee343c8ebfc3bfa49751795"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e">mprSpinUnlock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a spinlock.  <a href="#geb11c8a1f0c2c3f905967a932626121e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d">mprTryLock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock access.  <a href="#g2b3b8e824b92499192ea48512e31c26d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#gc257b932fcc7140852e6830640d2301b">mprTrySpinLock</a> (<a class="el" href="struct_mpr_spin.html">MprSpin</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock access on a spin lock.  <a href="#gc257b932fcc7140852e6830640d2301b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad">mprUnlock</a> (<a class="el" href="struct_mpr_mutex.html">MprMutex</a> *lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="#g40a516fe58b4b2998852cd0c853027ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5">mprWaitForCond</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a condition lock variable.  <a href="#g38ffd872f11254b3ca0a14e0388d98b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_synch.html#g4ce11896445416406d85d4d7a18bac7e">mprWaitForCondWithService</a> (<a class="el" href="struct_mpr_cond.html">MprCond</a> *cond, int timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a condition lock variable and pump events while waiting.  <a href="#g4ce11896445416406d85d4d7a18bac7e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Multithreaded Synchronization Services. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a>, mprCreateStaticLock, <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>, <a class="el" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede" title="Lock access.">mprLock</a>, <a class="el" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d" title="Attempt to lock access.">mprTryLock</a>, <a class="el" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad" title="Unlock a mutex.">mprUnlock</a>, <a class="el" href="group___mpr_synch.html#g934273252bb4202c8adeb9d8841769a4" title="Globally lock the application.">mprGlobalLock</a>, <a class="el" href="group___mpr_synch.html#g9af03d596ad19cd7974d85d82a8c27ca" title="Unlock the global mutex.">mprGlobalUnlock</a>, <a class="el" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a>, <a class="el" href="group___mpr_synch.html#ge63f87a8d093d294bd1ce6747cbb42ec" title="Create a spin lock lock object.">mprCreateSpinLock</a>, <a class="el" href="struct_mpr_cond.html" title="Condition variable for single and multi-thread synchronization.">MprCond</a>, <a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a>, <a class="el" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5" title="Wait for a condition lock variable.">mprWaitForCond</a>, <a class="el" href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b" title="Signal a condition lock variable.">mprSignalCond</a>, <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a> </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Evolving. </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g30046b7108565283ac168c6a90739a3f"></a><!-- doxytag: member="mpr.h::mprCreateCond" ref="g30046b7108565283ac168c6a90739a3f" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mpr_cond.html">MprCond</a>* mprCreateCond           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a condition lock variable. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call creates a condition variable object that can be used in <a class="el" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5" title="Wait for a condition lock variable.">mprWaitForCond</a> and <a class="el" href="group___mpr_synch.html#gb014329886bcb9a8cb9b970afc30378b" title="Signal a condition lock variable.">mprSignalCond</a> calls. Use <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a> to destroy the condition variable. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g825387252381219bd94edfa9c60855fa"></a><!-- doxytag: member="mpr.h::mprCreateLock" ref="g825387252381219bd94edfa9c60855fa" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mpr_mutex.html">MprMutex</a>* mprCreateLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a Mutex lock object. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call creates a Mutex lock object that can be used in <a class="el" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede" title="Lock access.">mprLock</a>, <a class="el" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d" title="Attempt to lock access.">mprTryLock</a> and <a class="el" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad" title="Unlock a mutex.">mprUnlock</a> calls. Use <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a> to destroy the lock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge63f87a8d093d294bd1ce6747cbb42ec"></a><!-- doxytag: member="mpr.h::mprCreateSpinLock" ref="ge63f87a8d093d294bd1ce6747cbb42ec" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mpr_spin.html">MprSpin</a>* mprCreateSpinLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a spin lock lock object. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call creates a spinlock object that can be used in <a class="el" href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795" title="Lock a spinlock.">mprSpinLock</a>, and <a class="el" href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e" title="Unlock a spinlock.">mprSpinUnlock</a> calls. Spin locks using <a class="el" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> are much faster than <a class="el" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> based locks on some systems. Use <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a> to destroy the lock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g934273252bb4202c8adeb9d8841769a4"></a><!-- doxytag: member="mpr.h::mprGlobalLock" ref="g934273252bb4202c8adeb9d8841769a4" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprGlobalLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Globally lock the application. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call asserts the application global lock so that other threads calling mprGlobalLock will block until the current thread calls mprGlobalUnlock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g9af03d596ad19cd7974d85d82a8c27ca"></a><!-- doxytag: member="mpr.h::mprGlobalUnlock" ref="g9af03d596ad19cd7974d85d82a8c27ca" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprGlobalUnlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock the global mutex. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call unlocks the global mutex previously locked via mprGlobalLock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge5ac7172314ec00d74bc8a5b61ee98fa"></a><!-- doxytag: member="mpr.h::mprInitLock" ref="ge5ac7172314ec00d74bc8a5b61ee98fa" args="(MprCtx ctx, MprMutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mpr_mutex.html">MprMutex</a>* mprInitLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a statically allocated Mutex lock object. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call initialized a Mutex lock object without allocation. The object can then be used used in <a class="el" href="group___mpr_synch.html#gd193cb5549a1101dc17177f046144ede" title="Lock access.">mprLock</a>, <a class="el" href="group___mpr_synch.html#g2b3b8e824b92499192ea48512e31c26d" title="Attempt to lock access.">mprTryLock</a> and <a class="el" href="group___mpr_synch.html#g40a516fe58b4b2998852cd0c853027ad" title="Unlock a mutex.">mprUnlock</a> calls. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>Reference to an <a class="el" href="struct_mpr_mutex.html" title="Multithreading lock control structure.">MprMutex</a> structure to initialize </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the supplied mutex. Returns null on errors. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd0e8debf5fc06d66c839ef8979d8e4c9"></a><!-- doxytag: member="mpr.h::mprInitSpinLock" ref="gd0e8debf5fc06d66c839ef8979d8e4c9" args="(MprCtx ctx, MprSpin *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mpr_spin.html">MprSpin</a>* mprInitSpinLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a statically allocated spinlock object. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call initialized a spinlock lock object without allocation. The object can then be used used in <a class="el" href="group___mpr_synch.html#gf2a84bc9cee343c8ebfc3bfa49751795" title="Lock a spinlock.">mprSpinLock</a> and <a class="el" href="group___mpr_synch.html#geb11c8a1f0c2c3f905967a932626121e" title="Unlock a spinlock.">mprSpinUnlock</a> calls. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Reference to a static <a class="el" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the <a class="el" href="struct_mpr_spin.html" title="Multithreading spin lock control structure.">MprSpin</a> object. Returns null on errors. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd193cb5549a1101dc17177f046144ede"></a><!-- doxytag: member="mpr.h::mprLock" ref="gd193cb5549a1101dc17177f046144ede" args="(MprMutex *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock access. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call asserts a lock on the given <em>lock</em> mutex so that other threads calling mprLock will block until the current thread calls mprUnlock. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb014329886bcb9a8cb9b970afc30378b"></a><!-- doxytag: member="mpr.h::mprSignalCond" ref="gb014329886bcb9a8cb9b970afc30378b" args="(MprCond *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSignalCond           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal a condition lock variable. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Signal a condition variable and set it to the <em>triggered</em> status. Existing or future callers of <a class="el" href="group___mpr_synch.html#g38ffd872f11254b3ca0a14e0388d98b5" title="Wait for a condition lock variable.">mprWaitForCond</a> will be awakened. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Condition variable object created via <a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf2a84bc9cee343c8ebfc3bfa49751795"></a><!-- doxytag: member="mpr.h::mprSpinLock" ref="gf2a84bc9cee343c8ebfc3bfa49751795" args="(MprSpin *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSpinLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock a spinlock. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call asserts a lock on the given <em>spinlock</em> so that other threads calling mprSpinLock will block until the curren thread calls mprSpinUnlock. </dd></dl>

</div>
</div><p>
<a class="anchor" name="geb11c8a1f0c2c3f905967a932626121e"></a><!-- doxytag: member="mpr.h::mprSpinUnlock" ref="geb11c8a1f0c2c3f905967a932626121e" args="(MprSpin *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSpinUnlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock a spinlock. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call unlocks a spinlock previously locked via mprSpinLock or mprTrySpinLock. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2b3b8e824b92499192ea48512e31c26d"></a><!-- doxytag: member="mpr.h::mprTryLock" ref="g2b3b8e824b92499192ea48512e31c26d" args="(MprMutex *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mprTryLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to lock access. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call attempts to assert a lock on the given <em>lock</em> mutex so that other threads calling mprLock or mprTryLock will block until the current thread calls mprUnlock. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the successful in locking the mutex. Returns a negative MPR error code if unsuccessful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc257b932fcc7140852e6830640d2301b"></a><!-- doxytag: member="mpr.h::mprTrySpinLock" ref="gc257b932fcc7140852e6830640d2301b" args="(MprSpin *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mprTrySpinLock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_spin.html">MprSpin</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to lock access on a spin lock. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call attempts to assert a lock on the given <em>spin</em> lock so that other threads calling mprSpinLock or mprTrySpinLock will block until the current thread calls mprSpinUnlock. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the successful in locking the spinlock. Returns a negative MPR error code if unsuccessful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g40a516fe58b4b2998852cd0c853027ad"></a><!-- doxytag: member="mpr.h::mprUnlock" ref="g40a516fe58b4b2998852cd0c853027ad" args="(MprMutex *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprUnlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_mutex.html">MprMutex</a> *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock a mutex. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call unlocks a mutex previously locked via mprLock or mprTryLock. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g38ffd872f11254b3ca0a14e0388d98b5"></a><!-- doxytag: member="mpr.h::mprWaitForCond" ref="g38ffd872f11254b3ca0a14e0388d98b5" args="(MprCond *cond, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprWaitForCond           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a condition lock variable. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Wait for a condition lock variable to be signaled. If the condition is signaled before the timeout expires this call will reset the condition variable and return. This way, it automatically resets the variable for future waiters. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Condition variable object created via <a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Time in milliseconds to wait for the condition variable to be signaled. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if the event was signalled. Returns &lt; 0 for a timeout. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4ce11896445416406d85d4d7a18bac7e"></a><!-- doxytag: member="mpr.h::mprWaitForCondWithService" ref="g4ce11896445416406d85d4d7a18bac7e" args="(MprCond *cond, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprWaitForCondWithService           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mpr_cond.html">MprCond</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a condition lock variable and pump events while waiting. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Wait for a condition lock variable to be signaled. If the condition is signaled before the timeout expires this call will reset the condition variable and return. This way, it automatically resets the variable for future waiters. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cond</em>&nbsp;</td><td>Condition variable object created via <a class="el" href="group___mpr_synch.html#g30046b7108565283ac168c6a90739a3f" title="Create a condition lock variable.">mprCreateCond</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Time in milliseconds to wait for the condition variable to be signaled. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Zero if the event was signalled. Returns &lt; 0 for a timeout. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jan 19 11:56:18 2010 for mpr by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
