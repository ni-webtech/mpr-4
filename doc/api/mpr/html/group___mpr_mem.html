<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>mpr: MprMem</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>MprMem</h1>Memory Allocation Service.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mpr_blk.html">MprBlk</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory Allocation Block Header.  <a href="struct_mpr_blk.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int64 size, int64 total, bool granted)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory allocation error callback.  <a href="#ge0e48d1c33f626b414aa311fe400cbf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory context type.  <a href="#g1413d66bb5356730c6fa08ca0af6bc0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> )(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mpr memory block destructors prototype.  <a href="#g9531f8722a082ef0334d496738303663"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec">mprAlloc</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory.  <a href="#g8453c59fd682fda78bbd18eb9f572dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1817af523c1a6f663c792c74190c7ae4">mprAllocArena</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint arenaSize, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory arena.  <a href="#g1817af523c1a6f663c792c74190c7ae4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g81a5827a39d536c462e9ed1145b50248">mprAllocHeap</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint heapSize, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory heap.  <a href="#g81a5827a39d536c462e9ed1145b50248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g95dfa054deaafadfbfdb740f0d7d97c3">mprAllocObj</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object of a given type.  <a href="#g95dfa054deaafadfbfdb740f0d7d97c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb61e0804fdc8e8398bacd18e06ed0b2e">mprAllocObjWithDestructor</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor) extern void *mprAllocObjWithDestructorZeroed(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object of a given type with a destructor.  <a href="#gb61e0804fdc8e8398bacd18e06ed0b2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g4681a304da368211a957c3d7f40c107e">mprAllocObjZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a zeroed object of a given type.  <a href="#g4681a304da368211a957c3d7f40c107e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MprHeap *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb4a28f8d8793b16758bef0cb22acc299">mprAllocSlab</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *name, uint objSize, uint count, bool threadSafe, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory slab heap.  <a href="#gb4a28f8d8793b16758bef0cb22acc299"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def">mprAllocWithDestructor</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object block of memory.  <a href="#g354a006ab1b3afa765ecf52369df6def"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g9765c5e6c3653ed716df99f1eb883fd3">mprAllocWithDestructorZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object block of memory and zero it.  <a href="#g9765c5e6c3653ed716df99f1eb883fd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gb6e0fd9b58e841c28bb49ec2ab37072d">mprAllocZeroed</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a zeroed block of memory.  <a href="#gb6e0fd9b58e841c28bb49ec2ab37072d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045">mprFree</a> (void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a block of memory.  <a href="#g6d2fdfc4a34dc8ef4e7172fbcf977045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ga2917f1fe62535e7f18549bad3c87c3f">mprGetParent</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the memory parent of a block.  <a href="#ga2917f1fe62535e7f18549bad3c87c3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g46b725c5e3a7818e3051401b016f7902">mprHasAllocError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the MPR has encountered memory allocation errors.  <a href="#g46b725c5e3a7818e3051401b016f7902"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g3fa0c34d79f33c76f6d6813f0774b8b4">mprRealloc</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, void *ptr, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocate a block.  <a href="#g3fa0c34d79f33c76f6d6813f0774b8b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g8a1a2ca6fb1f9e1cd45660ba1004e9a2">mprResetAllocError</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the memory allocation error flag.  <a href="#g8a1a2ca6fb1f9e1cd45660ba1004e9a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g1aba81525e6f3570db267f1a71c96d1d">mprSetAllocLimits</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, uint redline, uint maxMemory)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the application memory limits.  <a href="#g1aba81525e6f3570db267f1a71c96d1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#gdeb570e7b9f2ee67eef01e574baaecb4">mprSetDestructor</a> (void *ptr, <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a> destructor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the destructor for a block of memory.  <a href="#gdeb570e7b9f2ee67eef01e574baaecb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86">mprStrdup</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe replacement for strdup.  <a href="#ga08b7e0447aa2f5a380d9d3daa1f5f86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___mpr_mem.html#g857ed05b61f4112d319fe75545d0a081">mprStrndup</a> (<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, cchar *str, uint size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a string.  <a href="#g857ed05b61f4112d319fe75545d0a081"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Memory Allocation Service. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>The MPR provides a memory manager that sits above malloc. This layer provides arena and slab based allocations with a tree structured allocation mechanism. The goal of the layer is to provide a fast, secure, scalable memory allocator suited for embedded applications in multithreaded environments. <br>
<br>
 By using a tree structured network of memory contexts, error recovery in applications and memory freeing becomes much easier and more reliable. When a memory block is allocated a parent memory block must be specified. When the parent block is freed, all its children are automatically freed. <br>
<br>
 The MPR handles memory allocation errors globally. The application can configure a memory limits and redline so that memory depletion can be proactively detected and handled. This relieves most cost from detecting and handling allocation errors. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Evolving</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f" title="Memory context type.">MprCtx</a>, <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>, <a class="el" href="group___mpr_mem.html#g3fa0c34d79f33c76f6d6813f0774b8b4" title="Reallocate a block.">mprRealloc</a>, <a class="el" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec" title="Allocate a block of memory.">mprAlloc</a>, <a class="el" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def" title="Allocate an object block of memory.">mprAllocWithDestructor</a>, <a class="el" href="group___mpr_mem.html#g9765c5e6c3653ed716df99f1eb883fd3" title="Allocate an object block of memory and zero it.">mprAllocWithDestructorZeroed</a>, <a class="el" href="group___mpr_mem.html#gb6e0fd9b58e841c28bb49ec2ab37072d" title="Allocate a zeroed block of memory.">mprAllocZeroed</a>, <a class="el" href="group___mpr_mem.html#ga2917f1fe62535e7f18549bad3c87c3f" title="Get the memory parent of a block.">mprGetParent</a>, <a class="el" href="group___mpr.html#g4e84f505d5b6f74de677ffff29806906" title="Create an instance of the MPR.">mprCreate</a>, <a class="el" href="group___mpr_mem.html#g1aba81525e6f3570db267f1a71c96d1d" title="Configure the application memory limits.">mprSetAllocLimits</a>, <a class="el" href="group___mpr_mem.html#gb61e0804fdc8e8398bacd18e06ed0b2e" title="Allocate an object of a given type with a destructor.">mprAllocObjWithDestructor</a>, mprAllocObjWithDestructorZeroed, <a class="el" href="group___mpr_mem.html#g46b725c5e3a7818e3051401b016f7902" title="Determine if the MPR has encountered memory allocation errors.">mprHasAllocError</a> <a class="el" href="group___mpr_mem.html#g8a1a2ca6fb1f9e1cd45660ba1004e9a2" title="Reset the memory allocation error flag.">mprResetAllocError</a>, mprMemdup, <a class="el" href="group___mpr_mem.html#g857ed05b61f4112d319fe75545d0a081" title="Duplicate a string.">mprStrndup</a>, <a class="el" href="mpr_8h.html#bcb752b124b706ebff6798cfeafc9f99" title="Safe copy for a block of data.">mprMemcpy</a>, </dd></dl>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ge0e48d1c33f626b414aa311fe400cbf0"></a><!-- doxytag: member="mpr.h::MprAllocFailure" ref="ge0e48d1c33f626b414aa311fe400cbf0" args=")(MprCtx ctx, int64 size, int64 total, bool granted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group___mpr_mem.html#ge0e48d1c33f626b414aa311fe400cbf0">MprAllocFailure</a>)(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx, int64 size, int64 total, bool granted)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory allocation error callback. 
<p>
Notifiers are called if mprSetNotifier has been called on a context and a memory allocation fails. All notifiers up the parent context chain are called in order. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of memory allocation request that failed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>total</em>&nbsp;</td><td>Total memory allocations so far </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>granted</em>&nbsp;</td><td>Set to true if the request was actually granted, but the application is now exceeding its redline memory limit. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1413d66bb5356730c6fa08ca0af6bc0f"></a><!-- doxytag: member="mpr.h::MprCtx" ref="g1413d66bb5356730c6fa08ca0af6bc0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory context type. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Blocks of memory are allocated using a memory context as the parent. Any allocated memory block may serve as the memory context for subsequent memory allocations. Freeing a block via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045">mprFree</a> will release the allocated block and all child blocks. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9531f8722a082ef0334d496738303663"></a><!-- doxytag: member="mpr.h::MprDestructor" ref="g9531f8722a082ef0334d496738303663" args=")(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>)(<a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a> ctx)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mpr memory block destructors prototype. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return zero if the memory was actually freed. Return non-zero to prevent the memory being freed. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g8453c59fd682fda78bbd18eb9f572dec"></a><!-- doxytag: member="mpr.h::mprAlloc" ref="g8453c59fd682fda78bbd18eb9f572dec" args="(MprCtx ctx, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAlloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a block of memory using the supplied memory context <em>ctx</em> as the parent. <a class="el" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec" title="Allocate a block of memory.">mprAlloc</a> manages a tree structure of memory blocks. Freeing a block via mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory block to allocate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1817af523c1a6f663c792c74190c7ae4"></a><!-- doxytag: member="mpr.h::mprAllocArena" ref="g1817af523c1a6f663c792c74190c7ae4" args="(MprCtx ctx, cchar *name, uint arenaSize, bool threadSafe, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprHeap* mprAllocArena           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>arenaSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>threadSafe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a memory arena. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Memory arenas are virtual allocations. When subsequent allocations are done via mprAlloc, the memory will be pinned. On systems without virtual memory, the memory is physically allocated at the time of this call. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give the arena. Name must be persistent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arenaSize</em>&nbsp;</td><td>Size of the virtual arena. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadSafe</em>&nbsp;</td><td>If true, allocations for memory from the arena will be thread safe. Allocations are faster if threadSafe is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the reserved arena. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g81a5827a39d536c462e9ed1145b50248"></a><!-- doxytag: member="mpr.h::mprAllocHeap" ref="g81a5827a39d536c462e9ed1145b50248" args="(MprCtx ctx, cchar *name, uint heapSize, bool threadSafe, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprHeap* mprAllocHeap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>heapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>threadSafe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a memory heap. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Memory heaps map onto the standard system malloc() system. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give the heap. Name must be persistent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heapSize</em>&nbsp;</td><td>Size of the memory heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadSafe</em>&nbsp;</td><td>If true, allocations for memory from the heap will be thread safe. Allocations are faster if threadSafe is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the reserved heap. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g95dfa054deaafadfbfdb740f0d7d97c3"></a><!-- doxytag: member="mpr.h::mprAllocObj" ref="g95dfa054deaafadfbfdb740f0d7d97c3" args="(MprCtx ctx, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocObj           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an object of a given type. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a block of memory large enough to hold an instance of the specified type. This uses the supplied memory context <em>ctx</em> as the parent. This is implemented as a macro </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the object to allocate </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb61e0804fdc8e8398bacd18e06ed0b2e"></a><!-- doxytag: member="mpr.h::mprAllocObjWithDestructor" ref="gb61e0804fdc8e8398bacd18e06ed0b2e" args="(MprCtx ctx, Type type, MprDestructor destructor) extern void *mprAllocObjWithDestructorZeroed(MprCtx ctx" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocObjWithDestructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an object of a given type with a destructor. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a block of memory large enough to hold an instance of the specified type with a destructor. This uses the supplied memory context <em>ctx</em> as the parent. This is implemented as a macro. this call associates a destructor function with an object. This function will be invoked when the object is freed. Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the object to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. Allocate a zeroed object of a given type with a destructor </dd></dl>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a zeroed block of memory large enough to hold an instance of the specified type with a destructor. This uses the supplied memory context <em>ctx</em> as the parent. This is implemented as a macro. this call associates a destructor function with an object. This function will be invoked when the object is freed. Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the object to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4681a304da368211a957c3d7f40c107e"></a><!-- doxytag: member="mpr.h::mprAllocObjZeroed" ref="g4681a304da368211a957c3d7f40c107e" args="(MprCtx ctx, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocObjZeroed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a zeroed object of a given type. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a zeroed block of memory large enough to hold an instance of the specified type. This uses the supplied memory context <em>ctx</em> as the parent. This is implemented as a macro </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the object to allocate </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4a28f8d8793b16758bef0cb22acc299"></a><!-- doxytag: member="mpr.h::mprAllocSlab" ref="gb4a28f8d8793b16758bef0cb22acc299" args="(MprCtx ctx, cchar *name, uint objSize, uint count, bool threadSafe, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MprHeap* mprAllocSlab           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>objSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>threadSafe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a memory slab heap. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Memory slab heaps are heaps for constant sized object allocations. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give the heap. Name must be persistent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objSize</em>&nbsp;</td><td>Size of the virtual heap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Count of objects in slab </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadSafe</em>&nbsp;</td><td>If true, allocations for memory from the heap will be thread safe. Allocations are faster if threadSafe is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the reserved heap. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g354a006ab1b3afa765ecf52369df6def"></a><!-- doxytag: member="mpr.h::mprAllocWithDestructor" ref="g354a006ab1b3afa765ecf52369df6def" args="(MprCtx ctx, uint size, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocWithDestructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an object block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a block of memory using the supplied memory context <em>ctx</em> as the parent. <a class="el" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def" title="Allocate an object block of memory.">mprAllocWithDestructor</a> associates a destructor function with an object. This function will be invoked when the object is freed. Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory block to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9765c5e6c3653ed716df99f1eb883fd3"></a><!-- doxytag: member="mpr.h::mprAllocWithDestructorZeroed" ref="g9765c5e6c3653ed716df99f1eb883fd3" args="(MprCtx ctx, uint size, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocWithDestructorZeroed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate an object block of memory and zero it. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a zeroed block of memory using the supplied memory context <em>ctx</em> as the parent. <a class="el" href="group___mpr_mem.html#g354a006ab1b3afa765ecf52369df6def" title="Allocate an object block of memory.">mprAllocWithDestructor</a> associates a destructor function with an object. This function will be invoked when the object is freed. Freeing a block will first call the destructor and if that returns zero, mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory block to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when the allocation is freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>
<dl class="user" compact><dt><b><b>API</b> Stability:</b></dt><dd>Prototype. This function names are highly likely to be refactored. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb6e0fd9b58e841c28bb49ec2ab37072d"></a><!-- doxytag: member="mpr.h::mprAllocZeroed" ref="gb6e0fd9b58e841c28bb49ec2ab37072d" args="(MprCtx ctx, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprAllocZeroed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a zeroed block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Allocates a zeroed block of memory using the supplied memory context <em>ctx</em> as the parent. <a class="el" href="group___mpr_mem.html#g8453c59fd682fda78bbd18eb9f572dec" title="Allocate a block of memory.">mprAlloc</a> manages a tree structure of memory blocks. Freeing a block via mprFree will release the allocated block and all child blocks. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory block to allocate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to malloc and mprAlloc. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6d2fdfc4a34dc8ef4e7172fbcf977045"></a><!-- doxytag: member="mpr.h::mprFree" ref="g6d2fdfc4a34dc8ef4e7172fbcf977045" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mprFree           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>mprFree should be used to free memory allocated by mprAlloc, or mprRealloc. This call will ignore calls to free a null pointer, thus it is an acceptable idiom to free a pointer without testing its value for null. When mprFree is called it will first invoke any object destructor function for the allocated block. If this destructor returns zero, it will then proceed and free all allocated children before finally releasing the block. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Memory to free. If NULL, take no action. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns zero if the block was actually freed. If the destructor prevented the freeing, a non-zero value will be returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga2917f1fe62535e7f18549bad3c87c3f"></a><!-- doxytag: member="mpr.h::mprGetParent" ref="ga2917f1fe62535e7f18549bad3c87c3f" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprGetParent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the memory parent of a block. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Return the parent memory context for a block </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return the memory owning this block </dd></dl>

</div>
</div><p>
<a class="anchor" name="g46b725c5e3a7818e3051401b016f7902"></a><!-- doxytag: member="mpr.h::mprHasAllocError" ref="g46b725c5e3a7818e3051401b016f7902" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mprHasAllocError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the MPR has encountered memory allocation errors. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Returns true if the MPR has had a memory allocation error. Allocation errors occur if any memory allocation would cause the application to exceed the configured redline limit, or if any O/S memory allocation request fails. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if a memory allocation error has occurred. Otherwise returns FALSE. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3fa0c34d79f33c76f6d6813f0774b8b4"></a><!-- doxytag: member="mpr.h::mprRealloc" ref="g3fa0c34d79f33c76f6d6813f0774b8b4" args="(MprCtx ctx, void *ptr, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mprRealloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reallocate a block. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Reallocates a block increasing its size. If the specified size is less than the current block size, the call will ignore the request and simply return the existing block. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Memory to reallocate. If NULL, call malloc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>New size of the required memory block. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated block. If memory is not available the memory exhaustion handler specified via mprCreate will be called to allow global recovery. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Do not mix calls to realloc and mprRealloc. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8a1a2ca6fb1f9e1cd45660ba1004e9a2"></a><!-- doxytag: member="mpr.h::mprResetAllocError" ref="g8a1a2ca6fb1f9e1cd45660ba1004e9a2" args="(MprCtx ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprResetAllocError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the memory allocation error flag. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Reset the alloc error flag triggered. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by the MPR. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1aba81525e6f3570db267f1a71c96d1d"></a><!-- doxytag: member="mpr.h::mprSetAllocLimits" ref="g1aba81525e6f3570db267f1a71c96d1d" args="(MprCtx ctx, uint redline, uint maxMemory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetAllocLimits           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>redline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>maxMemory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure the application memory limits. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Configure memory limits to constrain memory usage by the application. The memory allocation subsystem will check these limits before granting memory allocation requrests. The redLine is a soft limit that if exceeded will invoke the memory allocation callback, but will still honor the request. The maxMemory limit is a hard limit. The MPR will prevent allocations which exceed this maximum. The memory callback handler is defined via the <a class="el" href="group___mpr.html#g4e84f505d5b6f74de677ffff29806906" title="Create an instance of the MPR.">mprCreate</a> call. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>redline</em>&nbsp;</td><td>Soft memory limit. If exceeded, the request will be granted, but the memory handler will be invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxMemory</em>&nbsp;</td><td>Hard memory limit. If exceeded, the request will not be granted, and the memory handler will be invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdeb570e7b9f2ee67eef01e574baaecb4"></a><!-- doxytag: member="mpr.h::mprSetDestructor" ref="gdeb570e7b9f2ee67eef01e574baaecb4" args="(void *ptr, MprDestructor destructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mprSetDestructor           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g9531f8722a082ef0334d496738303663">MprDestructor</a>&nbsp;</td>
          <td class="paramname"> <em>destructor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the destructor for a block of memory. 
<p>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>This call updates the destructor for a block of memory allocated via mprAllocWithDestructor. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Memory to free. If NULL, take no action. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destructor</em>&nbsp;</td><td>Destructor function to invoke when <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a> is called. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga08b7e0447aa2f5a380d9d3daa1f5f86"></a><!-- doxytag: member="mpr.h::mprStrdup" ref="ga08b7e0447aa2f5a380d9d3daa1f5f86" args="(MprCtx ctx, cchar *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrdup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safe replacement for strdup. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd><a class="el" href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86" title="Safe replacement for strdup.">mprStrdup()</a> should be used as a replacement for <b>strdup</b> wherever possible. It allows the strdup to be copied to be NULL, in which case it will allocate an empty string. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to string to duplicate. If <b>str</b> is NULL, allocate a new string containing only a trailing NULL character. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns an allocated string including trailing null. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Memory allocated via <a class="el" href="group___mpr_mem.html#ga08b7e0447aa2f5a380d9d3daa1f5f86" title="Safe replacement for strdup.">mprStrdup()</a> must be freed via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g857ed05b61f4112d319fe75545d0a081"></a><!-- doxytag: member="mpr.h::mprStrndup" ref="g857ed05b61f4112d319fe75545d0a081" args="(MprCtx ctx, cchar *str, uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mprStrndup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___mpr_mem.html#g1413d66bb5356730c6fa08ca0af6bc0f">MprCtx</a>&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cchar *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Duplicate a string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Any memory context allocated by mprAlloc or mprCreate. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b><b>Description</b>:</b></dt><dd>Copy a string into a newly allocated block. The new block will be sized to the maximum of the length of the existing string (plus a null) and the requested size. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to the block to duplicate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Requested minimum size of the allocated block holding the duplicated string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns an allocated block. Caller must free via <a class="el" href="group___mpr_mem.html#g6d2fdfc4a34dc8ef4e7172fbcf977045" title="Free a block of memory.">mprFree</a>. </dd></dl>
<div class="typeconstraint">
<dl compact><dt><b>Type Constraints</b><dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
</table>
</dl>
</div>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jan 19 11:56:18 2010 for mpr by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
