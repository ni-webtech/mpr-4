#!/usr/bin/env ejs
/*
    utest -- Embedthis Unit Test Framework
 */
module ejs.test {

require ejs.unix

enumerable class Test {

    use default namespace public

    var verbosity: Number = 0               // Verbosity level
    const TIMEOUT: Number = 15 * 60 * 1000  // Test timeout (15 minutes)

    /*
         Directories to omit from unit tests
     */
    const skipDirs = [ "out", "build", "package", "samples" ]

    /*
        Parsed args
     */
    var _bin: Path                          // Path to bin directory
    var config: Object                      // buildConfig.h features
    var continueOnErrors: Boolean = false   // Continue on errors 
    var data: Object                        // Opaque data
    var _depth: Number = 1                  // Test level. Higher levels mean deeper testing.
    var echo: Boolean = false               // Echo the command line 
    var errorMsg: String                    // Worker callback error msg
    var failed: Boolean                     // Did the test pass
    var filters: Array = []                 // Filter tests by pattern x.y.z... 
    var finish: Boolean                     // Set to true when time to exit 
    var _hostOs: String                     // Host operating system
    var iterations: Number = 1              // Number of iterations to run the test 
    var _lib: Path                          // Path to lib directory
    var logPath: Path                       // Loging filename
    var logSpec: String                     // Logging specifier (file:level) to output log messages
    var nth: Number = 0                     // Current iteration
    var noserver: Boolean = false           // Omit running a server (sets NOSERVER=1)
    var _os: String                         // Operating system
    var second: Boolean = false             // Second instance. Bypass some initializations
    var skipTest: Boolean = false           // Skip a test
    var skippedMsg: String                  // Test skipped message
    var step: Boolean = false               // Single step tests 
    var testName: String                    // Set test name 
    var testDirs: Array = [ "." ]           // Test directories to run
    var threads: Number = 1                 // Number of test threads 
    var _top: Path                          // Path to top of source tree
    var version: String = "0.1.0"           // Output version information 
    var workerImage: Worker                 // Clonable worker image

    var program: String                     // Program name
    var currentTest: String                 // Test currently executing
    var fullName: String                    // Full name of the current test 
    var log: Logger = App.log
    var start = Date.now()

    /*
        Stats
     */
    var assertCount: Number = 0
    var failedCount: Number = 0
    var passedCount: Number = 0
    var skippedCount: Number = 0
    var testCount: Number = 0

    public var tsession = { }
        
    function Test() {
        workerImage = new Worker
        program = Path(App.args[0]).basename
        if ((path = searchUp("configure")) == null) {
            throw "Can't find configure"
        }
        _top = path.dirname.absolute
        // _bin = App.exeDir
        _bin = Path(Cmd.locate("edep")).dirname
        _lib = App.exeDir.join("../lib")
        if (!_lib.exists) {
            _lib = _bin
        }
        parseBuildConfig(_top.join("out/inc/buildConfig.h"));
    }

    /*
        Parse args and invoke required commands
     */
    function parseArgs(args: Array): Void {
        for (let i: Number = 1; i < args.length; i++) {
            switch (args[i]) {
            case "--":
                i = args.length
                break
            case "-2": case "--second":
                second = true
                noserver = true
                App.putenv("SECOND", "1")
                App.putenv("NOSERVER", "1")
                break
            case "--chdir":
                App.chdir(args[++i])
                break
            case "-c" : case "--continue":
                continueOnErrors = true
                break
            case "-d": case "--depth":
                _depth = args[++i] cast Number
                if (_depth < 1 || _depth > 9) {
                    _depth = 1
                }
                break
            case "--debug": case "-D":
                Debug.mode = true
                break
            case "-e": case "--echo":
                echo = true
                break
            case "-i": case "--iterations":
                iterations = args[++i] cast Number
                break
            case "-l": case "--log":
                logSpec = args[++i]
                break
            case "-n": case "--noserver":
                noserver = true
                App.putenv("NOSERVER", "1")
                break
            case "--name":
                testName = args[++i]
                break
            case "-o": case "--os":
                _os = args[++i]
                break
            case "-s": case "--step":
                step = true
                break
            case "-t": case "--threads":
                threads = args[++i] cast Number
                break
            case "-v": case "--verbose": case "--verbosity":
                verbosity++
                break
            case "-V": case "--version":
                print(program.toString().toPascal() + " " + version)
                App.exit()
                break
            default:
                if (args[i].startsWith("-")) {
                    usage()
                }
                filters.append(new RegExp("^" + args[i].trimEnd(".tst") + "[\\.\/\\\\]"))
                break
            }
        }
    }

    function usage(): Void {
        error("Usage: " + program + " [options] [filter patterns...]\n" +
            "  --chdir dir           # Change to directory before testing\n" + 
            "  --continue            # Continue on errors\n" + 
            "  --depth number        # Zero == basic, 1 == throrough, 2 extensive\n" + 
            "  --debug               # Run in debug mode\n" + 
            "  --echo                # Echo the command line\n" + 
            "  --iterations count    # Number of iterations to run the test\n" + 
            "  --log logFile         # Send output to a log file \n" + 
            "  --name testName       # Set test name\n" + 
            "  --noserver            # Don't run server side of tests\n" + 
            "  --os O/S              # Set operating system\n" + 
            "  --second              # Second instance. Bypass some initializations\n" + 
            "  --step                # Single step tests\n" + 
            "  --threads count       # Number of test threads\n" + 
            "  --verbose             # Verbose mode (can use multiple times)\n" + 
            "  --version             # Output version information\n")
        App.exit(1)
    }

    function initialize(): Void {
        if (logSpec) {
            App.log.redirect(logSpec)
            App.mprLog.redirect(logSpec)
        }
        if (echo) {
            log.activity("Test", App.args.join(" "))
        }
    }

    /*
        Main test runner
     */
    function runner(): Void {
        log.activity("Test", "Starting tests. Test depth: " + _depth + ", iterations: " + iterations)
        for (i in testDirs) {
            testDirs[i] = new Path(testDirs[i])
        }
        let success = false
        try {
            runThread()
	    	success = true
        }
        finally {
            if (!success && test.verbosity == 1 && test.threads <= 1) {
                log.write("FAILED\n")
            }
        }
    }

    function runThread(): Void {
        for (nth = 0; nth < iterations && !finish; nth++) {
            for each (dir in testDirs) {
                runGroupTests(dir)
            }
            log.activity("Progress", "Completed iteration " + nth)
        }
    }

    function runGroupTests(dir: Path): Void {
        if (dir != "." && dir.name.startsWith(".")) {
            return
        }
        if (skipDirs.contains(dir.toString())) {
            return
        }
        if (!runSetup(dir, "init")) {
            return
        }
        if (!runPrePost(dir, "init")) {
            return
        }
        try {
            if (!dir.exists) {
                error("Can't read directory: " + dir)
            }
            for each (file in ls(dir, true)) {
                if (finish) { 
                    break
                }
                if (file.isDir) {
                    runGroupTests(file)
                } else if (file.extension == "tst") {
                    if (filters.length == 0) {
                        runTest(file)
                    } else {
                        for each (pat in filters) {
                            if (file.toString().match(pat)) {
                                runTest(file)
                                break
                            }
                        }
                    }
                }
            }
        } finally {
            runPrePost(dir, "term")
            runSetup(dir, "term")
        }
    }

    function runTest(file: Path, phase: String = null): Void {
        skipTest = false
        let home = App.dir
        try {
            logTest(file)
            App.chdir(file.dirname)
            file = file.basename
            let workers
            let ext = file.extension
            if (ext == "init" || ext == "term") {
                workers = startWorker(file, phase)
            } else {
                workers = []
                for (thread in threads) {
                    workers.append(startWorker(file, phase))
                }
            }
            if (!Worker.join(workers, TIMEOUT)) {
                for each (w in workers) {
                    w.terminate()
                }
                Worker.join(workers, 0)
                throw "Test Failed: \"" + test.fullName + "\". Timeout of " + TIMEOUT + " expired."
            }
            workers = null
        } catch (e) {
            failedCount++
            if (!continueOnErrors) {
                finish = true
                throw e
            }
        } finally {
            App.chdir(home)
        }
        GC.run()
    }

    function initWorker(w: Worker, export: Object) {
        w.preload(_top.join("build/bin/utest.worker"))
        let estr = serialize(export)
        //  MOB OPT. Better not to use eval here. Slower.
        w.preeval('
            data = deserialize(\'' + estr.replace(/\\/g, "\\\\") + '\')

            public var test: Test = new Test
            public var tsession: Object

            test.depth = data.depth
            test.bin = Path(data.bin)
            test.dir = Path(data.dir)
            test.lib = Path(data.lib)
            test.os = data.os
            test.phase = data.phase
            test.hostOs = data.hostOs
            test.threads = data.threads
            test.top = Path(data.top)
            test.verbosity = Number(data.verbosity)
            test.config = data.config
            blend(App.config.test, test.config, false)
            // test.multithread = test.config.multithread
            tsession = data.tsession
            if (data.logPath) {
                test.setLogPath(Path(data.logPath))
            }
        ')
    }

    function startWorker(file: Path, phase: String = null): Worker {
        let export = { 
            bin: _bin, 
            config: config,
            depth: _depth, 
            dir: file.dirname,
            hostOs: _hostOs, 
            lib: _lib, 
            log: logPath,
            os: _os, 
            phase: phase,
            tsession: tsession,
            threads: threads, 
            top: _top, 
            verbosity: verbosity, 
        }
        let w: Worker = workerImage.clone()
        w.name = fullName
        initWorker(w, export)

        let priorCount = testCount
        let test = this
        test.failed = false
        w.onmessage = function (e) {
            obj = deserialize(e.data)
            if (obj.passed) {
                test.passedCount++
                test.testCount++
            } else if (obj.skip) {
                test.skipTest = true
                test.skippedMsg = obj.skip
                test.skippedCount++
            } else if (obj.key) {
                test.tsession[obj.key] = obj.value
            }
        }
        w.onerror = function (e) {
            if (test.verbosity == 1 && test.threads <= 1) {
                App.log.write("FAILED\n\n")
            }
            test.failed = true
            test.failedCount++
            if (e.stack) {
                test.testCount++
                let stack = e.formatStack()
                // let where = stack.replace(/.*\[00\] .*\n/m, "")
                if (!test.continueOnErrors) {
                    test.finish = true
                    App.log.write("Test Failed: \"" + test.fullName + "\". " + e.message + " At:\n" + stack + "\n")
                }
            } else {
                App.log.write("Test Failed: " + e.message + "\n")
            }
        }
        w.onclose = function (e) {
            if (test.testCount == priorCount) {
                /*
                    Test did not invoke assert. At least it did not crash, so count it as passed.
                 */
                test.passedCount++
                test.testCount++
            }
            if (test.verbosity == 1 && test.threads <= 1) {
                if (test.skippedMsg) {
                    App.log.write("SKIPPED (" + test.skippedMsg + ")\n")
                    test.skippedMsg = null
                } else if (!test.failed) {
                    App.log.write("PASSED\n")
                }
            }
        }
        w.load(file)
        return w
    }

    //  DEPRECATE
    /*
        Run a pre/post script. If it calls skip(), 
        then return skip so the whole directory can be skipped.
     */
    function runPrePost(path: Path, suffix: String = "pre"): Boolean {
        let file = path.join(path.absolute.basename.toString()).joinExt(suffix)
        if (file.exists) {
            if (filters.length == 0) {
                runTest(file)
                return !skipTest 
            } else for each (pat in filters) {
                if (file.toString().match(pat)) {
                    runTest(file)
                    return !skipTest 
                }
            }
        }
        return true
    }

    /*
        Run a test.setup script. If it calls skip(), 
        then return skip so the whole directory can be skipped.
     */
    function runSetup(path: Path, phase: String): Boolean {
        let file = path.join("test.setup")
        if (file.exists) {
            if (filters.length == 0) {
                runTest(file, phase)
                return !skipTest 
            } else for each (pat in filters) {
                if (file.toString().match(pat)) {
                    runTest(file, phase)
                    return !skipTest 
                }
            }
        }
        return true
    }

    function summary() {
        log.activity("Test", ((failedCount == 0) ? "PASSED" : "FAILED") + ": " + 
            testCount + " tests completed, " + failedCount +
            " tests(s) failed, " + skippedCount + " tests(s) skipped. " + 
            "Elapsed time " + ("%.2f" % ((Date.now() - start) / 1000)) + " secs.")
    }

    function exit(): Void {
        App.exit(failedCount > 0 ? 1 : 0)
    }

    function logTest(file: Path): Void {
        let ext = file.extension
        if (ext == "init" || ext == "term") {
            prefix = "[" + ext.toPascal() + "]"
            // currentTest = file.dirname.joinExt(ext).toString().replace(/\//, ".")
        } else {
            prefix = "[Test]"
            // currentTest = file.trimExt().toString().replace(/\//g, ".")
        }
        currentTest = file.toString()
        this.fullName = testName ? (testName + "." + currentTest) : currentTest
        if (verbosity || step) {
            log.write("%12s " % prefix)
        }
        if (step) {
            log.write(fullName + ", press <ENTER>: ")
            if (step) stdin.readLine()
        } else if (verbosity > 0) {
            log.write(fullName)
            if (verbosity == 1 && threads == 1) {
                log.write(" ... ")
            }
        }
        if (verbosity > 1 || threads > 1) {
            log.write("\n")
        }
    }
        
    function getKey(data: String, key: String): String {
        r = RegExp(key + "=(.*)")
        match = data.match(r)
        if (match) {
            return match[0].split("=")[1]
        }
        return null
    }

    function parseBuildConfig(path: Path) {
        let data = Path(path).readString()
        _os = getKey(data, "BLD_BUILD_OS")
        _hostOs = getKey(data, "BLD_HOST_OS")
        config = {}
        config["debug"] = getKey(data, "BLD_DEBUG")
        data = data.match(/BLD_FEATURE.*|BLD_HTTP_PORT.*|BLD_SSL_PORT.*/g)
        for each (item in data) {
            if (!item.contains("=")) {
                continue
            }
            let [key, value] = item.split("=")
            key = key.replace(/BLD_FEATURE_/, "")
            key = key.replace(/BLD_/, "").toLowerCase()
            if (value == "1" || value == "0") {
                value = value cast Number
            }
            config[key] = value
        }
        if (config["multithread"] == 0) {
            error("Requires configure --enable-multithread")
        }
    }

    function searchUp(path: Path): Path {
        if (path.exists) {
            return path
        }
        path = Path(path).relative
        dir = Path("..")
        while (true) {
            up = Path(dir.relative).join(path)
            if (up.exists) {
                return up
            }
            if (dir.parent == dir) {
                break
            }
            dir = dir.parent
        }
        return null
    }

    function error(...msg): Void {
        App.log.error("\nutest: " + msg + "\n\n")
        App.exit(1)
    }
}

/*
    Main program
 */
var test: Test = new Test
test.parseArgs(App.args)
test.initialize()

try {
    test.runner()
} catch (e) { 
    App.log.error(e)
}
test.summary()
test.exit()

} /* module ejs.test */

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2011. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2011. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
