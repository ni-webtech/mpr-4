/*
    utest.worker - Injected into the unit test global scope
 */

require ejs.unix

enumerable public class Test {
    public var bin: Path
    public var config: Object
    public var depth: Number
    public var dir: Path
    public var lib: Path
    public var multithread: Boolean
    public var phase: String
    public var threads: Number
    public var top: Path
    public var os: Path
    public var hostOs: Path
    public var verbosity: Number = false

    var out = App.outputStream

    public function log(level: Number, name: String, ...items) {
        if (verbosity >= level) {
            out.write("%12s " % [name])
            out.write(items)
            if (verbosity > 1) {
                out.write("\n")
            } else {
                out.write(": ")
            }
        }
    }

    public function mapVerbosity(adj: Number): String {
        str = ""
        for (i = test.verbosity + adj; i > 0; i--)
            str += "-v "
        return str
    }

    function searchUp(path: Path): String {
        if (exists(path))
            return path
        path = Path(path).relative
        dir = Path("..")
        while (true) {
            up = Path(dir.relative).join(path)
            if (exists(up))
                return up
            if (dir.parent == dir) break
            dir = dir.parent
        }
        return null
    }

    public function setLogPath(path: Path): Void {
        if (path) {
            out = File(path).open("aw")
        } else {
            out = App.outputStream
        }
    }

    public function skip(message: String): Void
        postMessage({ skip: message })
}


/*
    Global functions
 */
function assert(cond: Boolean, message: String = null): Void {
    if (cond) {
        postMessage({ passed: true })
    } else {
        throw new AssertError(message.toString())
    }
}

/* 
    Redefine the Global.assert function 
*/
Object.defineProperty(global, "assert", { writable: true, value: assert})


public function cleanDir(path) {
    rmdir(path, true)
    mkdir(path)
}


/*
    Used to start support programs. This does capture output.
 */
public function sh(args): String {
    test.log(2, "[Run]", "Run: " + args)
    // return Cmd.sh(args)
    return System.run(("/bin/sh -c \"" + args.replace(/\\/g, "\\\\") + "\"").trim('\n'))
}


/*
    Test a command
    MOB - what does this function really do?
 */
public function testCmdNoCapture(args): Boolean {
    test.log(2, "[Test]", "Run test: " + args)
    try {
        args = args.toString().toJSON().trim('"')
        System.runx(("/bin/sh -c \"" + args + "\"").trim('\n'))
        assert(true)
        return true
    } catch (e) {
        print("testCmdNoCapture: CATCH " + e)
        assert(false)
        return false
    }
}


// MOB - what does this function really do? - why not just use sh?

public function testCmd(args): Boolean {
    test.log(2, "[Test]", "Run test: " + args)
    try {
        args = args.toString().toJSON().trim('"')
        System.run(("/bin/sh -c \"" + args + "\"").trim('\n'))
        assert(true)
        return true
    } catch (e) {
        print("testCmd: CATCH " + e)
        assert(false)
        return false
    }
}


public function locate(program): String {
    return test.bin.join(program).portable.toString()
}


public function share(key: String, value: String) {
    postMessage({ key: key, value: value })
}


const PIDFILE = ".pidfile"

public function stopService() {
    if (Path(PIDFILE).exists) {
        pid = Path(PIDFILE).readString()
        Path(PIDFILE).remove()
        try { kill(pid, 9); } catch (e) { }
    }
}


public function startService(cmd: String, port: Number): Void {
    stopService()
    if (!App.getenv("NOSERVER")) {
        let pid = System.daemon(App.exePath + " " + cmd)
        Path(PIDFILE).write(pid)

        port ||= App.config.test.http_port
        let url = ":" + port + "/web/ready.ready"
        for (i in 10) {
            http = new Http
            try { http.get(url); 
                /* Expect to get a not-found response */
                if (http.status == 404 || http.status == 200) {
                    break
                }
            } catch (e) { }
            App.sleep(100)
            http.close()
        }
        if (http.status != 404 && http.status != 200) {
            throw "Can't start web server"
        }
        http.close()
    }
}

public function httpService(cmd: String, port: Number = 80): Void {
    if (test.phase == "init") {
        startService(cmd)
    } else {
        stopService()
    }
}

